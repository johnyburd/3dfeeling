{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _Three = require('./Three');\n\nvar _Three2 = _interopRequireDefault(_Three);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar OrbitControls = require('three-orbit-controls')(_Three2.default);\n\nvar DIRECTIONAL_LIGHT = 'directionalLight';\n\nvar Paint = function () {\n  function Paint() {\n    _classCallCheck(this, Paint);\n\n    this.loader = new _Three2.default.STLLoader();\n    this.scene = new _Three2.default.Scene();\n    this.renderer = new _Three2.default.WebGLRenderer({\n      antialias: true\n    });\n    this.reqNumber = 0;\n  }\n\n  _createClass(Paint, [{\n    key: 'init',\n    value: function init(context) {\n      this.component = context;\n      this.width = context.props.width;\n      this.height = context.props.height;\n      this.modelColor = context.props.modelColor;\n      this.backgroundColor = context.props.backgroundColor;\n      this.orbitControls = context.props.orbitControls;\n      this.rotate = context.props.rotate;\n      this.cameraX = context.props.cameraX;\n      this.cameraY = context.props.cameraY;\n      this.cameraZ = context.props.cameraZ;\n      this.rotationSpeeds = context.props.rotationSpeeds;\n      this.lights = context.props.lights;\n      this.lightColor = context.props.lightColor;\n      this.model = context.props.model;\n\n      if (this.mesh !== undefined) {\n        this.scene.remove(this.mesh);\n        this.mesh.geometry.dispose();\n        this.mesh.material.dispose();\n        this.scene.remove(this.grid);\n      }\n\n      var directionalLightObj = this.scene.getObjectByName(DIRECTIONAL_LIGHT);\n\n      if (directionalLightObj) {\n        this.scene.remove(directionalLightObj);\n      }\n\n      if (this.animationRequestId) {\n        cancelAnimationFrame(this.animationRequestId);\n      } //Detector.addGetWebGLMessage();\n\n\n      this.distance = 10000; // lights processing\n\n      var hasMultipleLights = this.lights.reduce(function (acc, item) {\n        return acc && Array.isArray(item);\n      }, true);\n\n      if (hasMultipleLights) {\n        this.lights.forEach(this.addLight.bind(this));\n      } else {\n        this.addLight(this.lights);\n      }\n\n      this.reqNumber += 1;\n      this.addSTLToScene(this.reqNumber);\n    }\n  }, {\n    key: 'addLight',\n    value: function addLight(lights) {\n      var _directionalLight$pos;\n\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var directionalLight = new _Three2.default.DirectionalLight(this.lightColor);\n\n      (_directionalLight$pos = directionalLight.position).set.apply(_directionalLight$pos, _toConsumableArray(lights));\n\n      directionalLight.name = DIRECTIONAL_LIGHT + index;\n      directionalLight.position.normalize();\n      this.scene.add(directionalLight);\n    }\n  }, {\n    key: 'loadSTLFromUrl',\n    value: function loadSTLFromUrl(url, reqId) {\n      var _this = this;\n\n      return new Promise(function (resolve) {\n        _this.loader.crossOrigin = '';\n\n        _this.loader.loadFromUrl(url, function (geometry) {\n          if (_this.reqNumber !== reqId) {\n            return;\n          }\n\n          resolve(geometry);\n        });\n      });\n    }\n  }, {\n    key: 'loadFromFile',\n    value: function loadFromFile(file) {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        _this2.loader.loadFromFile(file, function (geometry) {\n          resolve(geometry);\n        });\n      });\n    }\n  }, {\n    key: 'addSTLToScene',\n    value: function addSTLToScene(reqId) {\n      var _this3 = this;\n\n      var loadPromise = void 0;\n\n      if (typeof this.model === 'string') {\n        loadPromise = this.loadSTLFromUrl(this.model, reqId);\n      } else if (this.model instanceof ArrayBuffer) {\n        loadPromise = this.loadFromFile(this.model);\n      } else {\n        return Promise.resolve(null);\n      }\n\n      return loadPromise.then(function (geometry) {\n        // Calculate mesh noramls for MeshLambertMaterial.\n        geometry.computeFaceNormals();\n        geometry.computeVertexNormals(); // Center the object\n\n        geometry.center();\n        var material = new _Three2.default.MeshLambertMaterial({\n          overdraw: true,\n          color: _this3.modelColor\n        });\n\n        if (geometry.hasColors) {\n          material = new _Three2.default.MeshPhongMaterial({\n            opacity: geometry.alpha,\n            vertexColors: _Three2.default.VertexColors\n          });\n        }\n\n        _this3.mesh = new _Three2.default.Mesh(geometry, material); // Set the object's dimensions\n\n        geometry.computeBoundingBox();\n        _this3.xDims = geometry.boundingBox.max.x - geometry.boundingBox.min.x;\n        _this3.yDims = geometry.boundingBox.max.y - geometry.boundingBox.min.y;\n        _this3.zDims = geometry.boundingBox.max.z - geometry.boundingBox.min.z;\n\n        if (_this3.rotate) {\n          _this3.mesh.rotation.x = _this3.rotationSpeeds[0];\n          _this3.mesh.rotation.y = _this3.rotationSpeeds[1];\n          _this3.mesh.rotation.z = _this3.rotationSpeeds[2];\n        }\n\n        _this3.scene.add(_this3.mesh);\n\n        _this3.addCamera();\n\n        _this3.addInteractionControls();\n\n        _this3.addToReactComponent(); // Start the animation\n\n\n        _this3.animate();\n      });\n    }\n  }, {\n    key: 'addCamera',\n    value: function addCamera() {\n      // Add the camera\n      this.camera = new _Three2.default.PerspectiveCamera(30, this.width / this.height, 1, this.distance);\n\n      if (this.cameraZ === null) {\n        this.cameraZ = Math.max(this.xDims * 3, this.yDims * 3, this.zDims * 3);\n      }\n\n      this.camera.position.set(this.cameraX, this.cameraY, this.cameraZ);\n      this.scene.add(this.camera);\n      this.camera.lookAt(this.mesh);\n      this.renderer.set;\n      this.renderer.setSize(this.width, this.height);\n      this.renderer.setClearColor(this.backgroundColor, 1);\n    }\n  }, {\n    key: 'addInteractionControls',\n    value: function addInteractionControls() {\n      // Add controls for mouse interaction\n      if (this.orbitControls) {\n        this.controls = new OrbitControls(this.camera, _reactDom2.default.findDOMNode(this.component));\n        this.controls.enableKeys = false;\n        this.controls.addEventListener('change', this.orbitRender.bind(this));\n      }\n    }\n  }, {\n    key: 'addToReactComponent',\n    value: function addToReactComponent() {\n      // Add to the React Component\n      _reactDom2.default.findDOMNode(this.component).replaceChild(this.renderer.domElement, _reactDom2.default.findDOMNode(this.component).firstChild);\n    }\n    /**\n     * Animate the scene\n     * @returns {void}\n     */\n\n  }, {\n    key: 'animate',\n    value: function animate() {\n      // note: three.js includes requestAnimationFrame shim\n      if (this.rotate) {\n        this.animationRequestId = requestAnimationFrame(this.animate.bind(this));\n      }\n\n      if (this.orbitControls) {\n        this.controls.update();\n      }\n\n      this.render();\n    }\n    /**\n     * Render the scene after turning off the rotation\n     * @returns {void}\n     */\n\n  }, {\n    key: 'orbitRender',\n    value: function orbitRender() {\n      if (this.rotate) {\n        this.rotate = false;\n      }\n\n      this.render();\n    }\n    /**\n     * Deallocate Mesh, renderer context.\n     * @returns {void}\n     */\n\n  }, {\n    key: 'clean',\n    value: function clean() {\n      if (this.mesh !== undefined) {\n        this.mesh.geometry.dispose();\n        this.mesh.material.dispose();\n        this.scene.remove(this.mesh);\n        delete this.mesh;\n      }\n\n      var directionalLightObj = this.scene.getObjectByName(DIRECTIONAL_LIGHT);\n\n      if (directionalLightObj) {\n        this.scene.remove(directionalLightObj);\n      }\n\n      if (this.animationRequestId) {\n        cancelAnimationFrame(this.animationRequestId);\n      }\n\n      this.renderer.dispose();\n      this.renderer.forceContextLoss();\n    }\n    /**\n     * Render the scene\n     * @returns {void}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      if (this.mesh && this.rotate) {\n        this.mesh.rotation.x += this.rotationSpeeds[0];\n        this.mesh.rotation.y += this.rotationSpeeds[1];\n        this.mesh.rotation.z += this.rotationSpeeds[2];\n      }\n\n      this.renderer.render(this.scene, this.camera);\n    }\n  }]);\n\n  return Paint;\n}();\n\nexports.default = Paint;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}