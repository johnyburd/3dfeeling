{"ast":null,"code":"var self = self || {}; // File:src/Three.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nvar THREE = {\n  REVISION: '72'\n}; //\n\nif (typeof define === 'function' && define.amd) {\n  define('three', THREE);\n} else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {\n  module.exports = THREE;\n} // polyfills\n\n\nif (self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined) {\n  // Missing in Android stock browser.\n  (function () {\n    var lastTime = 0;\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\n\n    for (var x = 0; x < vendors.length && !self.requestAnimationFrame; ++x) {\n      self.requestAnimationFrame = self[vendors[x] + 'RequestAnimationFrame'];\n      self.cancelAnimationFrame = self[vendors[x] + 'CancelAnimationFrame'] || self[vendors[x] + 'CancelRequestAnimationFrame'];\n    }\n\n    if (self.requestAnimationFrame === undefined && self.setTimeout !== undefined) {\n      self.requestAnimationFrame = function (callback) {\n        var currTime = Date.now(),\n            timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        var id = self.setTimeout(function () {\n          callback(currTime + timeToCall);\n        }, timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n    }\n\n    if (self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined) {\n      self.cancelAnimationFrame = function (id) {\n        self.clearTimeout(id);\n      };\n    }\n  })();\n}\n\nif (Math.sign === undefined) {\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n  Math.sign = function (x) {\n    return x < 0 ? -1 : x > 0 ? 1 : +x;\n  };\n}\n\nif (Function.prototype.name === undefined && Object.defineProperty !== undefined) {\n  // Missing in IE9-11.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n  Object.defineProperty(Function.prototype, 'name', {\n    get: function get() {\n      return this.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n    }\n  });\n} // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\n\n\nTHREE.MOUSE = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2\n}; // GL STATE CONSTANTS\n\nTHREE.CullFaceNone = 0;\nTHREE.CullFaceBack = 1;\nTHREE.CullFaceFront = 2;\nTHREE.CullFaceFrontBack = 3;\nTHREE.FrontFaceDirectionCW = 0;\nTHREE.FrontFaceDirectionCCW = 1; // SHADOWING TYPES\n\nTHREE.BasicShadowMap = 0;\nTHREE.PCFShadowMap = 1;\nTHREE.PCFSoftShadowMap = 2; // MATERIAL CONSTANTS\n// side\n\nTHREE.FrontSide = 0;\nTHREE.BackSide = 1;\nTHREE.DoubleSide = 2; // shading\n\nTHREE.FlatShading = 1;\nTHREE.SmoothShading = 2; // colors\n\nTHREE.NoColors = 0;\nTHREE.FaceColors = 1;\nTHREE.VertexColors = 2; // blending modes\n\nTHREE.NoBlending = 0;\nTHREE.NormalBlending = 1;\nTHREE.AdditiveBlending = 2;\nTHREE.SubtractiveBlending = 3;\nTHREE.MultiplyBlending = 4;\nTHREE.CustomBlending = 5; // custom blending equations\n// (numbers start from 100 not to clash with other\n// mappings to OpenGL constants defined in Texture.js)\n\nTHREE.AddEquation = 100;\nTHREE.SubtractEquation = 101;\nTHREE.ReverseSubtractEquation = 102;\nTHREE.MinEquation = 103;\nTHREE.MaxEquation = 104; // custom blending destination factors\n\nTHREE.ZeroFactor = 200;\nTHREE.OneFactor = 201;\nTHREE.SrcColorFactor = 202;\nTHREE.OneMinusSrcColorFactor = 203;\nTHREE.SrcAlphaFactor = 204;\nTHREE.OneMinusSrcAlphaFactor = 205;\nTHREE.DstAlphaFactor = 206;\nTHREE.OneMinusDstAlphaFactor = 207; // custom blending source factors\n//THREE.ZeroFactor = 200;\n//THREE.OneFactor = 201;\n//THREE.SrcAlphaFactor = 204;\n//THREE.OneMinusSrcAlphaFactor = 205;\n//THREE.DstAlphaFactor = 206;\n//THREE.OneMinusDstAlphaFactor = 207;\n\nTHREE.DstColorFactor = 208;\nTHREE.OneMinusDstColorFactor = 209;\nTHREE.SrcAlphaSaturateFactor = 210; // depth modes\n\nTHREE.NeverDepth = 0;\nTHREE.AlwaysDepth = 1;\nTHREE.LessDepth = 2;\nTHREE.LessEqualDepth = 3;\nTHREE.EqualDepth = 4;\nTHREE.GreaterEqualDepth = 5;\nTHREE.GreaterDepth = 6;\nTHREE.NotEqualDepth = 7; // TEXTURE CONSTANTS\n\nTHREE.MultiplyOperation = 0;\nTHREE.MixOperation = 1;\nTHREE.AddOperation = 2; // Mapping modes\n\nTHREE.UVMapping = 300;\nTHREE.CubeReflectionMapping = 301;\nTHREE.CubeRefractionMapping = 302;\nTHREE.EquirectangularReflectionMapping = 303;\nTHREE.EquirectangularRefractionMapping = 304;\nTHREE.SphericalReflectionMapping = 305; // Wrapping modes\n\nTHREE.RepeatWrapping = 1000;\nTHREE.ClampToEdgeWrapping = 1001;\nTHREE.MirroredRepeatWrapping = 1002; // Filters\n\nTHREE.NearestFilter = 1003;\nTHREE.NearestMipMapNearestFilter = 1004;\nTHREE.NearestMipMapLinearFilter = 1005;\nTHREE.LinearFilter = 1006;\nTHREE.LinearMipMapNearestFilter = 1007;\nTHREE.LinearMipMapLinearFilter = 1008; // Data types\n\nTHREE.UnsignedByteType = 1009;\nTHREE.ByteType = 1010;\nTHREE.ShortType = 1011;\nTHREE.UnsignedShortType = 1012;\nTHREE.IntType = 1013;\nTHREE.UnsignedIntType = 1014;\nTHREE.FloatType = 1015;\nTHREE.HalfFloatType = 1025; // Pixel types\n//THREE.UnsignedByteType = 1009;\n\nTHREE.UnsignedShort4444Type = 1016;\nTHREE.UnsignedShort5551Type = 1017;\nTHREE.UnsignedShort565Type = 1018; // Pixel formats\n\nTHREE.AlphaFormat = 1019;\nTHREE.RGBFormat = 1020;\nTHREE.RGBAFormat = 1021;\nTHREE.LuminanceFormat = 1022;\nTHREE.LuminanceAlphaFormat = 1023; // THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\n\nTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\n// DDS / ST3C Compressed texture formats\n\nTHREE.RGB_S3TC_DXT1_Format = 2001;\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\nTHREE.RGBA_S3TC_DXT5_Format = 2004; // PVRTC compressed texture formats\n\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103; // DEPRECATED\n\nTHREE.Projector = function () {\n  console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');\n\n  this.projectVector = function (vector, camera) {\n    console.warn('THREE.Projector: .projectVector() is now vector.project().');\n    vector.project(camera);\n  };\n\n  this.unprojectVector = function (vector, camera) {\n    console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');\n    vector.unproject(camera);\n  };\n\n  this.pickingRay = function (vector, camera) {\n    console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');\n  };\n};\n\nTHREE.CanvasRenderer = function () {\n  console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');\n  this.domElement = document.createElement('canvas');\n\n  this.clear = function () {};\n\n  this.render = function () {};\n\n  this.setClearColor = function () {};\n\n  this.setSize = function () {};\n}; // File:src/math/Color.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.Color = function (color) {\n  if (arguments.length === 3) {\n    return this.setRGB(arguments[0], arguments[1], arguments[2]);\n  }\n\n  return this.set(color);\n};\n\nTHREE.Color.prototype = {\n  constructor: THREE.Color,\n  r: 1,\n  g: 1,\n  b: 1,\n  set: function set(value) {\n    if (value instanceof THREE.Color) {\n      this.copy(value);\n    } else if (typeof value === 'number') {\n      this.setHex(value);\n    } else if (typeof value === 'string') {\n      this.setStyle(value);\n    }\n\n    return this;\n  },\n  setHex: function setHex(hex) {\n    hex = Math.floor(hex);\n    this.r = (hex >> 16 & 255) / 255;\n    this.g = (hex >> 8 & 255) / 255;\n    this.b = (hex & 255) / 255;\n    return this;\n  },\n  setRGB: function setRGB(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    return this;\n  },\n  setHSL: function () {\n    function hue2rgb(p, q, t) {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n      return p;\n    }\n\n    return function (h, s, l) {\n      // h,s,l ranges are in 0.0 - 1.0\n      h = THREE.Math.euclideanModulo(h, 1);\n      s = THREE.Math.clamp(s, 0, 1);\n      l = THREE.Math.clamp(l, 0, 1);\n\n      if (s === 0) {\n        this.r = this.g = this.b = l;\n      } else {\n        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n        var q = 2 * l - p;\n        this.r = hue2rgb(q, p, h + 1 / 3);\n        this.g = hue2rgb(q, p, h);\n        this.b = hue2rgb(q, p, h - 1 / 3);\n      }\n\n      return this;\n    };\n  }(),\n  setStyle: function setStyle(style) {\n    var parseAlpha = function parseAlpha(strAlpha) {\n      var alpha = parseFloat(strAlpha);\n\n      if (alpha < 1) {\n        console.warn('THREE.Color: Alpha component of color ' + style + ' will be ignored.');\n      }\n\n      return alpha;\n    };\n\n    var m;\n\n    if (m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec(style)) {\n      // rgb / hsl\n      var color;\n      var name = m[1];\n      var components = m[2];\n\n      switch (name) {\n        case 'rgb':\n          if (color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*$/.exec(components)) {\n            // rgb(255,0,0)\n            this.r = Math.min(255, parseInt(color[1], 10)) / 255;\n            this.g = Math.min(255, parseInt(color[2], 10)) / 255;\n            this.b = Math.min(255, parseInt(color[3], 10)) / 255;\n            return this;\n          }\n\n          if (color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*$/.exec(components)) {\n            // rgb(100%,0%,0%)\n            this.r = Math.min(100, parseInt(color[1], 10)) / 100;\n            this.g = Math.min(100, parseInt(color[2], 10)) / 100;\n            this.b = Math.min(100, parseInt(color[3], 10)) / 100;\n            return this;\n          }\n\n          break;\n\n        case 'rgba':\n          if (color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([0-9]*\\.?[0-9]+)\\s*$/.exec(components)) {\n            // rgba(255,0,0,0.5)\n            this.r = Math.min(255, parseInt(color[1], 10)) / 255;\n            this.g = Math.min(255, parseInt(color[2], 10)) / 255;\n            this.b = Math.min(255, parseInt(color[3], 10)) / 255;\n            parseAlpha(color[4]);\n            return this;\n          }\n\n          if (color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*([0-9]*\\.?[0-9]+)\\s*$/.exec(components)) {\n            // rgba(100%,0%,0%,0.5)\n            this.r = Math.min(100, parseInt(color[1], 10)) / 100;\n            this.g = Math.min(100, parseInt(color[2], 10)) / 100;\n            this.b = Math.min(100, parseInt(color[3], 10)) / 100;\n            parseAlpha(color[4]);\n            return this;\n          }\n\n          break;\n\n        case 'hsl':\n          if (color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*$/.exec(components)) {\n            // hsl(120,50%,50%)\n            var h = parseFloat(color[1]);\n            var s = parseInt(color[2], 10) / 100;\n            var l = parseInt(color[3], 10) / 100;\n            return this.setHSL(h, s, l);\n          }\n\n          break;\n\n        case 'hsla':\n          if (color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*([0-9]*\\.?[0-9]+)\\s*$/.exec(components)) {\n            // hsla(120,50%,50%,0.5)\n            var h = parseFloat(color[1]);\n            var s = parseInt(color[2], 10) / 100;\n            var l = parseInt(color[3], 10) / 100;\n            parseAlpha(color[4]);\n            return this.setHSL(h, s, l);\n          }\n\n          break;\n      }\n    } else if (m = /^\\#([A-Fa-f0-9]+)$/.exec(style)) {\n      // hex color\n      var hex = m[1];\n      var size = hex.length;\n\n      if (size === 3) {\n        // #ff0\n        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n        return this;\n      } else if (size === 6) {\n        // #ff0000\n        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n        return this;\n      }\n    }\n\n    if (style && style.length > 0) {\n      // color keywords\n      var hex = THREE.ColorKeywords[style];\n\n      if (hex !== undefined) {\n        // red\n        this.setHex(hex);\n      } else {\n        // unknown color\n        console.warn('THREE.Color: Unknown color ' + style);\n      }\n    }\n\n    return this;\n  },\n  clone: function clone() {\n    return new this.constructor(this.r, this.g, this.b);\n  },\n  copy: function copy(color) {\n    this.r = color.r;\n    this.g = color.g;\n    this.b = color.b;\n    return this;\n  },\n  copyGammaToLinear: function copyGammaToLinear(color, gammaFactor) {\n    if (gammaFactor === undefined) gammaFactor = 2.0;\n    this.r = Math.pow(color.r, gammaFactor);\n    this.g = Math.pow(color.g, gammaFactor);\n    this.b = Math.pow(color.b, gammaFactor);\n    return this;\n  },\n  copyLinearToGamma: function copyLinearToGamma(color, gammaFactor) {\n    if (gammaFactor === undefined) gammaFactor = 2.0;\n    var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;\n    this.r = Math.pow(color.r, safeInverse);\n    this.g = Math.pow(color.g, safeInverse);\n    this.b = Math.pow(color.b, safeInverse);\n    return this;\n  },\n  convertGammaToLinear: function convertGammaToLinear() {\n    var r = this.r,\n        g = this.g,\n        b = this.b;\n    this.r = r * r;\n    this.g = g * g;\n    this.b = b * b;\n    return this;\n  },\n  convertLinearToGamma: function convertLinearToGamma() {\n    this.r = Math.sqrt(this.r);\n    this.g = Math.sqrt(this.g);\n    this.b = Math.sqrt(this.b);\n    return this;\n  },\n  getHex: function getHex() {\n    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;\n  },\n  getHexString: function getHexString() {\n    return ('000000' + this.getHex().toString(16)).slice(-6);\n  },\n  getHSL: function getHSL(optionalTarget) {\n    // h,s,l ranges are in 0.0 - 1.0\n    var hsl = optionalTarget || {\n      h: 0,\n      s: 0,\n      l: 0\n    };\n    var r = this.r,\n        g = this.g,\n        b = this.b;\n    var max = Math.max(r, g, b);\n    var min = Math.min(r, g, b);\n    var hue, saturation;\n    var lightness = (min + max) / 2.0;\n\n    if (min === max) {\n      hue = 0;\n      saturation = 0;\n    } else {\n      var delta = max - min;\n      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n\n      switch (max) {\n        case r:\n          hue = (g - b) / delta + (g < b ? 6 : 0);\n          break;\n\n        case g:\n          hue = (b - r) / delta + 2;\n          break;\n\n        case b:\n          hue = (r - g) / delta + 4;\n          break;\n      }\n\n      hue /= 6;\n    }\n\n    hsl.h = hue;\n    hsl.s = saturation;\n    hsl.l = lightness;\n    return hsl;\n  },\n  getStyle: function getStyle() {\n    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';\n  },\n  offsetHSL: function offsetHSL(h, s, l) {\n    var hsl = this.getHSL();\n    hsl.h += h;\n    hsl.s += s;\n    hsl.l += l;\n    this.setHSL(hsl.h, hsl.s, hsl.l);\n    return this;\n  },\n  add: function add(color) {\n    this.r += color.r;\n    this.g += color.g;\n    this.b += color.b;\n    return this;\n  },\n  addColors: function addColors(color1, color2) {\n    this.r = color1.r + color2.r;\n    this.g = color1.g + color2.g;\n    this.b = color1.b + color2.b;\n    return this;\n  },\n  addScalar: function addScalar(s) {\n    this.r += s;\n    this.g += s;\n    this.b += s;\n    return this;\n  },\n  multiply: function multiply(color) {\n    this.r *= color.r;\n    this.g *= color.g;\n    this.b *= color.b;\n    return this;\n  },\n  multiplyScalar: function multiplyScalar(s) {\n    this.r *= s;\n    this.g *= s;\n    this.b *= s;\n    return this;\n  },\n  lerp: function lerp(color, alpha) {\n    this.r += (color.r - this.r) * alpha;\n    this.g += (color.g - this.g) * alpha;\n    this.b += (color.b - this.b) * alpha;\n    return this;\n  },\n  equals: function equals(c) {\n    return c.r === this.r && c.g === this.g && c.b === this.b;\n  },\n  fromArray: function fromArray(array) {\n    this.r = array[0];\n    this.g = array[1];\n    this.b = array[2];\n    return this;\n  },\n  toArray: function toArray(array, offset) {\n    if (array === undefined) array = [];\n    if (offset === undefined) offset = 0;\n    array[offset] = this.r;\n    array[offset + 1] = this.g;\n    array[offset + 2] = this.b;\n    return array;\n  }\n};\nTHREE.ColorKeywords = {\n  'aliceblue': 0xF0F8FF,\n  'antiquewhite': 0xFAEBD7,\n  'aqua': 0x00FFFF,\n  'aquamarine': 0x7FFFD4,\n  'azure': 0xF0FFFF,\n  'beige': 0xF5F5DC,\n  'bisque': 0xFFE4C4,\n  'black': 0x000000,\n  'blanchedalmond': 0xFFEBCD,\n  'blue': 0x0000FF,\n  'blueviolet': 0x8A2BE2,\n  'brown': 0xA52A2A,\n  'burlywood': 0xDEB887,\n  'cadetblue': 0x5F9EA0,\n  'chartreuse': 0x7FFF00,\n  'chocolate': 0xD2691E,\n  'coral': 0xFF7F50,\n  'cornflowerblue': 0x6495ED,\n  'cornsilk': 0xFFF8DC,\n  'crimson': 0xDC143C,\n  'cyan': 0x00FFFF,\n  'darkblue': 0x00008B,\n  'darkcyan': 0x008B8B,\n  'darkgoldenrod': 0xB8860B,\n  'darkgray': 0xA9A9A9,\n  'darkgreen': 0x006400,\n  'darkgrey': 0xA9A9A9,\n  'darkkhaki': 0xBDB76B,\n  'darkmagenta': 0x8B008B,\n  'darkolivegreen': 0x556B2F,\n  'darkorange': 0xFF8C00,\n  'darkorchid': 0x9932CC,\n  'darkred': 0x8B0000,\n  'darksalmon': 0xE9967A,\n  'darkseagreen': 0x8FBC8F,\n  'darkslateblue': 0x483D8B,\n  'darkslategray': 0x2F4F4F,\n  'darkslategrey': 0x2F4F4F,\n  'darkturquoise': 0x00CED1,\n  'darkviolet': 0x9400D3,\n  'deeppink': 0xFF1493,\n  'deepskyblue': 0x00BFFF,\n  'dimgray': 0x696969,\n  'dimgrey': 0x696969,\n  'dodgerblue': 0x1E90FF,\n  'firebrick': 0xB22222,\n  'floralwhite': 0xFFFAF0,\n  'forestgreen': 0x228B22,\n  'fuchsia': 0xFF00FF,\n  'gainsboro': 0xDCDCDC,\n  'ghostwhite': 0xF8F8FF,\n  'gold': 0xFFD700,\n  'goldenrod': 0xDAA520,\n  'gray': 0x808080,\n  'green': 0x008000,\n  'greenyellow': 0xADFF2F,\n  'grey': 0x808080,\n  'honeydew': 0xF0FFF0,\n  'hotpink': 0xFF69B4,\n  'indianred': 0xCD5C5C,\n  'indigo': 0x4B0082,\n  'ivory': 0xFFFFF0,\n  'khaki': 0xF0E68C,\n  'lavender': 0xE6E6FA,\n  'lavenderblush': 0xFFF0F5,\n  'lawngreen': 0x7CFC00,\n  'lemonchiffon': 0xFFFACD,\n  'lightblue': 0xADD8E6,\n  'lightcoral': 0xF08080,\n  'lightcyan': 0xE0FFFF,\n  'lightgoldenrodyellow': 0xFAFAD2,\n  'lightgray': 0xD3D3D3,\n  'lightgreen': 0x90EE90,\n  'lightgrey': 0xD3D3D3,\n  'lightpink': 0xFFB6C1,\n  'lightsalmon': 0xFFA07A,\n  'lightseagreen': 0x20B2AA,\n  'lightskyblue': 0x87CEFA,\n  'lightslategray': 0x778899,\n  'lightslategrey': 0x778899,\n  'lightsteelblue': 0xB0C4DE,\n  'lightyellow': 0xFFFFE0,\n  'lime': 0x00FF00,\n  'limegreen': 0x32CD32,\n  'linen': 0xFAF0E6,\n  'magenta': 0xFF00FF,\n  'maroon': 0x800000,\n  'mediumaquamarine': 0x66CDAA,\n  'mediumblue': 0x0000CD,\n  'mediumorchid': 0xBA55D3,\n  'mediumpurple': 0x9370DB,\n  'mediumseagreen': 0x3CB371,\n  'mediumslateblue': 0x7B68EE,\n  'mediumspringgreen': 0x00FA9A,\n  'mediumturquoise': 0x48D1CC,\n  'mediumvioletred': 0xC71585,\n  'midnightblue': 0x191970,\n  'mintcream': 0xF5FFFA,\n  'mistyrose': 0xFFE4E1,\n  'moccasin': 0xFFE4B5,\n  'navajowhite': 0xFFDEAD,\n  'navy': 0x000080,\n  'oldlace': 0xFDF5E6,\n  'olive': 0x808000,\n  'olivedrab': 0x6B8E23,\n  'orange': 0xFFA500,\n  'orangered': 0xFF4500,\n  'orchid': 0xDA70D6,\n  'palegoldenrod': 0xEEE8AA,\n  'palegreen': 0x98FB98,\n  'paleturquoise': 0xAFEEEE,\n  'palevioletred': 0xDB7093,\n  'papayawhip': 0xFFEFD5,\n  'peachpuff': 0xFFDAB9,\n  'peru': 0xCD853F,\n  'pink': 0xFFC0CB,\n  'plum': 0xDDA0DD,\n  'powderblue': 0xB0E0E6,\n  'purple': 0x800080,\n  'red': 0xFF0000,\n  'rosybrown': 0xBC8F8F,\n  'royalblue': 0x4169E1,\n  'saddlebrown': 0x8B4513,\n  'salmon': 0xFA8072,\n  'sandybrown': 0xF4A460,\n  'seagreen': 0x2E8B57,\n  'seashell': 0xFFF5EE,\n  'sienna': 0xA0522D,\n  'silver': 0xC0C0C0,\n  'skyblue': 0x87CEEB,\n  'slateblue': 0x6A5ACD,\n  'slategray': 0x708090,\n  'slategrey': 0x708090,\n  'snow': 0xFFFAFA,\n  'springgreen': 0x00FF7F,\n  'steelblue': 0x4682B4,\n  'tan': 0xD2B48C,\n  'teal': 0x008080,\n  'thistle': 0xD8BFD8,\n  'tomato': 0xFF6347,\n  'turquoise': 0x40E0D0,\n  'violet': 0xEE82EE,\n  'wheat': 0xF5DEB3,\n  'white': 0xFFFFFF,\n  'whitesmoke': 0xF5F5F5,\n  'yellow': 0xFFFF00,\n  'yellowgreen': 0x9ACD32\n}; // File:src/math/Quaternion.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\n\nTHREE.Quaternion = function (x, y, z, w) {\n  this._x = x || 0;\n  this._y = y || 0;\n  this._z = z || 0;\n  this._w = w !== undefined ? w : 1;\n};\n\nTHREE.Quaternion.prototype = {\n  constructor: THREE.Quaternion,\n\n  get x() {\n    return this._x;\n  },\n\n  set x(value) {\n    this._x = value;\n    this.onChangeCallback();\n  },\n\n  get y() {\n    return this._y;\n  },\n\n  set y(value) {\n    this._y = value;\n    this.onChangeCallback();\n  },\n\n  get z() {\n    return this._z;\n  },\n\n  set z(value) {\n    this._z = value;\n    this.onChangeCallback();\n  },\n\n  get w() {\n    return this._w;\n  },\n\n  set w(value) {\n    this._w = value;\n    this.onChangeCallback();\n  },\n\n  set: function set(x, y, z, w) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n    this.onChangeCallback();\n    return this;\n  },\n  clone: function clone() {\n    return new this.constructor(this._x, this._y, this._z, this._w);\n  },\n  copy: function copy(quaternion) {\n    this._x = quaternion.x;\n    this._y = quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n    this.onChangeCallback();\n    return this;\n  },\n  setFromEuler: function setFromEuler(euler, update) {\n    if (euler instanceof THREE.Euler === false) {\n      throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\n    } // http://www.mathworks.com/matlabcentral/fileexchange/\n    // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n    //\tcontent/SpinCalc.m\n\n\n    var c1 = Math.cos(euler._x / 2);\n    var c2 = Math.cos(euler._y / 2);\n    var c3 = Math.cos(euler._z / 2);\n    var s1 = Math.sin(euler._x / 2);\n    var s2 = Math.sin(euler._y / 2);\n    var s3 = Math.sin(euler._z / 2);\n    var order = euler.order;\n\n    if (order === 'XYZ') {\n      this._x = s1 * c2 * c3 + c1 * s2 * s3;\n      this._y = c1 * s2 * c3 - s1 * c2 * s3;\n      this._z = c1 * c2 * s3 + s1 * s2 * c3;\n      this._w = c1 * c2 * c3 - s1 * s2 * s3;\n    } else if (order === 'YXZ') {\n      this._x = s1 * c2 * c3 + c1 * s2 * s3;\n      this._y = c1 * s2 * c3 - s1 * c2 * s3;\n      this._z = c1 * c2 * s3 - s1 * s2 * c3;\n      this._w = c1 * c2 * c3 + s1 * s2 * s3;\n    } else if (order === 'ZXY') {\n      this._x = s1 * c2 * c3 - c1 * s2 * s3;\n      this._y = c1 * s2 * c3 + s1 * c2 * s3;\n      this._z = c1 * c2 * s3 + s1 * s2 * c3;\n      this._w = c1 * c2 * c3 - s1 * s2 * s3;\n    } else if (order === 'ZYX') {\n      this._x = s1 * c2 * c3 - c1 * s2 * s3;\n      this._y = c1 * s2 * c3 + s1 * c2 * s3;\n      this._z = c1 * c2 * s3 - s1 * s2 * c3;\n      this._w = c1 * c2 * c3 + s1 * s2 * s3;\n    } else if (order === 'YZX') {\n      this._x = s1 * c2 * c3 + c1 * s2 * s3;\n      this._y = c1 * s2 * c3 + s1 * c2 * s3;\n      this._z = c1 * c2 * s3 - s1 * s2 * c3;\n      this._w = c1 * c2 * c3 - s1 * s2 * s3;\n    } else if (order === 'XZY') {\n      this._x = s1 * c2 * c3 - c1 * s2 * s3;\n      this._y = c1 * s2 * c3 - s1 * c2 * s3;\n      this._z = c1 * c2 * s3 + s1 * s2 * c3;\n      this._w = c1 * c2 * c3 + s1 * s2 * s3;\n    }\n\n    if (update !== false) this.onChangeCallback();\n    return this;\n  },\n  setFromAxisAngle: function setFromAxisAngle(axis, angle) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n    // assumes axis is normalized\n    var halfAngle = angle / 2,\n        s = Math.sin(halfAngle);\n    this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n    this._w = Math.cos(halfAngle);\n    this.onChangeCallback();\n    return this;\n  },\n  setFromRotationMatrix: function setFromRotationMatrix(m) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n    var te = m.elements,\n        m11 = te[0],\n        m12 = te[4],\n        m13 = te[8],\n        m21 = te[1],\n        m22 = te[5],\n        m23 = te[9],\n        m31 = te[2],\n        m32 = te[6],\n        m33 = te[10],\n        trace = m11 + m22 + m33,\n        s;\n\n    if (trace > 0) {\n      s = 0.5 / Math.sqrt(trace + 1.0);\n      this._w = 0.25 / s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      this._z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n      this._w = (m32 - m23) / s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      this._z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n      this._w = (m13 - m31) / s;\n      this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + m32) / s;\n    } else {\n      s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n      this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n    }\n\n    this.onChangeCallback();\n    return this;\n  },\n  setFromUnitVectors: function () {\n    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n    // assumes direction vectors vFrom and vTo are normalized\n    var v1, r;\n    var EPS = 0.000001;\n    return function (vFrom, vTo) {\n      if (v1 === undefined) v1 = new THREE.Vector3();\n      r = vFrom.dot(vTo) + 1;\n\n      if (r < EPS) {\n        r = 0;\n\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n          v1.set(-vFrom.y, vFrom.x, 0);\n        } else {\n          v1.set(0, -vFrom.z, vFrom.y);\n        }\n      } else {\n        v1.crossVectors(vFrom, vTo);\n      }\n\n      this._x = v1.x;\n      this._y = v1.y;\n      this._z = v1.z;\n      this._w = r;\n      this.normalize();\n      return this;\n    };\n  }(),\n  inverse: function inverse() {\n    this.conjugate().normalize();\n    return this;\n  },\n  conjugate: function conjugate() {\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n    this.onChangeCallback();\n    return this;\n  },\n  dot: function dot(v) {\n    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n  },\n  lengthSq: function lengthSq() {\n    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n  },\n  length: function length() {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  },\n  normalize: function normalize() {\n    var l = this.length();\n\n    if (l === 0) {\n      this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n    } else {\n      l = 1 / l;\n      this._x = this._x * l;\n      this._y = this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n    }\n\n    this.onChangeCallback();\n    return this;\n  },\n  multiply: function multiply(q, p) {\n    if (p !== undefined) {\n      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\n      return this.multiplyQuaternions(q, p);\n    }\n\n    return this.multiplyQuaternions(this, q);\n  },\n  multiplyQuaternions: function multiplyQuaternions(a, b) {\n    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n    var qax = a._x,\n        qay = a._y,\n        qaz = a._z,\n        qaw = a._w;\n    var qbx = b._x,\n        qby = b._y,\n        qbz = b._z,\n        qbw = b._w;\n    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n    this.onChangeCallback();\n    return this;\n  },\n  multiplyVector3: function multiplyVector3(vector) {\n    console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');\n    return vector.applyQuaternion(this);\n  },\n  slerp: function slerp(qb, t) {\n    if (t === 0) return this;\n    if (t === 1) return this.copy(qb);\n    var x = this._x,\n        y = this._y,\n        z = this._z,\n        w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n    if (cosHalfTheta < 0) {\n      this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n      this._z = -qb._z;\n      cosHalfTheta = -cosHalfTheta;\n    } else {\n      this.copy(qb);\n    }\n\n    if (cosHalfTheta >= 1.0) {\n      this._w = w;\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      return this;\n    }\n\n    var halfTheta = Math.acos(cosHalfTheta);\n    var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n    if (Math.abs(sinHalfTheta) < 0.001) {\n      this._w = 0.5 * (w + this._w);\n      this._x = 0.5 * (x + this._x);\n      this._y = 0.5 * (y + this._y);\n      this._z = 0.5 * (z + this._z);\n      return this;\n    }\n\n    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n        ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n    this._w = w * ratioA + this._w * ratioB;\n    this._x = x * ratioA + this._x * ratioB;\n    this._y = y * ratioA + this._y * ratioB;\n    this._z = z * ratioA + this._z * ratioB;\n    this.onChangeCallback();\n    return this;\n  },\n  equals: function equals(quaternion) {\n    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n  },\n  fromArray: function fromArray(array, offset) {\n    if (offset === undefined) offset = 0;\n    this._x = array[offset];\n    this._y = array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = array[offset + 3];\n    this.onChangeCallback();\n    return this;\n  },\n  toArray: function toArray(array, offset) {\n    if (array === undefined) array = [];\n    if (offset === undefined) offset = 0;\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._w;\n    return array;\n  },\n  onChange: function onChange(callback) {\n    this.onChangeCallback = callback;\n    return this;\n  },\n  onChangeCallback: function onChangeCallback() {}\n};\n\nTHREE.Quaternion.slerp = function (qa, qb, qm, t) {\n  return qm.copy(qa).slerp(qb, t);\n}; // File:src/math/Vector2.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\n\n\nTHREE.Vector2 = function (x, y) {\n  this.x = x || 0;\n  this.y = y || 0;\n};\n\nTHREE.Vector2.prototype = {\n  constructor: THREE.Vector2,\n  set: function set(x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  setX: function setX(x) {\n    this.x = x;\n    return this;\n  },\n  setY: function setY(y) {\n    this.y = y;\n    return this;\n  },\n  setComponent: function setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n\n      case 1:\n        this.y = value;\n        break;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  },\n  getComponent: function getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n\n      case 1:\n        return this.y;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  },\n  clone: function clone() {\n    return new this.constructor(this.x, this.y);\n  },\n  copy: function copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    return this;\n  },\n  add: function add(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n      return this.addVectors(v, w);\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n    return this;\n  },\n  addScalar: function addScalar(s) {\n    this.x += s;\n    this.y += s;\n    return this;\n  },\n  addVectors: function addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    return this;\n  },\n  addScaledVector: function addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    return this;\n  },\n  sub: function sub(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n      return this.subVectors(v, w);\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n    return this;\n  },\n  subScalar: function subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    return this;\n  },\n  subVectors: function subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    return this;\n  },\n  multiply: function multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    return this;\n  },\n  multiplyScalar: function multiplyScalar(s) {\n    this.x *= s;\n    this.y *= s;\n    return this;\n  },\n  divide: function divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    return this;\n  },\n  divideScalar: function divideScalar(scalar) {\n    if (scalar !== 0) {\n      var invScalar = 1 / scalar;\n      this.x *= invScalar;\n      this.y *= invScalar;\n    } else {\n      this.x = 0;\n      this.y = 0;\n    }\n\n    return this;\n  },\n  min: function min(v) {\n    if (this.x > v.x) {\n      this.x = v.x;\n    }\n\n    if (this.y > v.y) {\n      this.y = v.y;\n    }\n\n    return this;\n  },\n  max: function max(v) {\n    if (this.x < v.x) {\n      this.x = v.x;\n    }\n\n    if (this.y < v.y) {\n      this.y = v.y;\n    }\n\n    return this;\n  },\n  clamp: function clamp(min, max) {\n    // This function assumes min < max, if this assumption isn't true it will not operate correctly\n    if (this.x < min.x) {\n      this.x = min.x;\n    } else if (this.x > max.x) {\n      this.x = max.x;\n    }\n\n    if (this.y < min.y) {\n      this.y = min.y;\n    } else if (this.y > max.y) {\n      this.y = max.y;\n    }\n\n    return this;\n  },\n  clampScalar: function () {\n    var min, max;\n    return function clampScalar(minVal, maxVal) {\n      if (min === undefined) {\n        min = new THREE.Vector2();\n        max = new THREE.Vector2();\n      }\n\n      min.set(minVal, minVal);\n      max.set(maxVal, maxVal);\n      return this.clamp(min, max);\n    };\n  }(),\n  floor: function floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    return this;\n  },\n  ceil: function ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    return this;\n  },\n  round: function round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  },\n  roundToZero: function roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    return this;\n  },\n  negate: function negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  },\n  dot: function dot(v) {\n    return this.x * v.x + this.y * v.y;\n  },\n  lengthSq: function lengthSq() {\n    return this.x * this.x + this.y * this.y;\n  },\n  length: function length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  },\n  lengthManhattan: function lengthManhattan() {\n    return Math.abs(this.x) + Math.abs(this.y);\n  },\n  normalize: function normalize() {\n    return this.divideScalar(this.length());\n  },\n  distanceTo: function distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  },\n  distanceToSquared: function distanceToSquared(v) {\n    var dx = this.x - v.x,\n        dy = this.y - v.y;\n    return dx * dx + dy * dy;\n  },\n  setLength: function setLength(l) {\n    var oldLength = this.length();\n\n    if (oldLength !== 0 && l !== oldLength) {\n      this.multiplyScalar(l / oldLength);\n    }\n\n    return this;\n  },\n  lerp: function lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    return this;\n  },\n  lerpVectors: function lerpVectors(v1, v2, alpha) {\n    this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\n    return this;\n  },\n  equals: function equals(v) {\n    return v.x === this.x && v.y === this.y;\n  },\n  fromArray: function fromArray(array, offset) {\n    if (offset === undefined) offset = 0;\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    return this;\n  },\n  toArray: function toArray(array, offset) {\n    if (array === undefined) array = [];\n    if (offset === undefined) offset = 0;\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    return array;\n  },\n  fromAttribute: function fromAttribute(attribute, index, offset) {\n    if (offset === undefined) offset = 0;\n    index = index * attribute.itemSize + offset;\n    this.x = attribute.array[index];\n    this.y = attribute.array[index + 1];\n    return this;\n  }\n}; // File:src/math/Vector3.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\n\nTHREE.Vector3 = function (x, y, z) {\n  this.x = x || 0;\n  this.y = y || 0;\n  this.z = z || 0;\n};\n\nTHREE.Vector3.prototype = {\n  constructor: THREE.Vector3,\n  set: function set(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  },\n  setX: function setX(x) {\n    this.x = x;\n    return this;\n  },\n  setY: function setY(y) {\n    this.y = y;\n    return this;\n  },\n  setZ: function setZ(z) {\n    this.z = z;\n    return this;\n  },\n  setComponent: function setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n\n      case 1:\n        this.y = value;\n        break;\n\n      case 2:\n        this.z = value;\n        break;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  },\n  getComponent: function getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n\n      case 1:\n        return this.y;\n\n      case 2:\n        return this.z;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  },\n  clone: function clone() {\n    return new this.constructor(this.x, this.y, this.z);\n  },\n  copy: function copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    return this;\n  },\n  add: function add(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n      return this.addVectors(v, w);\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    return this;\n  },\n  addScalar: function addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    return this;\n  },\n  addVectors: function addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    return this;\n  },\n  addScaledVector: function addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    return this;\n  },\n  sub: function sub(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n      return this.subVectors(v, w);\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    return this;\n  },\n  subScalar: function subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    return this;\n  },\n  subVectors: function subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    return this;\n  },\n  multiply: function multiply(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\n      return this.multiplyVectors(v, w);\n    }\n\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    return this;\n  },\n  multiplyScalar: function multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n  },\n  multiplyVectors: function multiplyVectors(a, b) {\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n    return this;\n  },\n  applyEuler: function () {\n    var quaternion;\n    return function applyEuler(euler) {\n      if (euler instanceof THREE.Euler === false) {\n        console.error('THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.');\n      }\n\n      if (quaternion === undefined) quaternion = new THREE.Quaternion();\n      this.applyQuaternion(quaternion.setFromEuler(euler));\n      return this;\n    };\n  }(),\n  applyAxisAngle: function () {\n    var quaternion;\n    return function applyAxisAngle(axis, angle) {\n      if (quaternion === undefined) quaternion = new THREE.Quaternion();\n      this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));\n      return this;\n    };\n  }(),\n  applyMatrix3: function applyMatrix3(m) {\n    var x = this.x;\n    var y = this.y;\n    var z = this.z;\n    var e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6] * z;\n    this.y = e[1] * x + e[4] * y + e[7] * z;\n    this.z = e[2] * x + e[5] * y + e[8] * z;\n    return this;\n  },\n  applyMatrix4: function applyMatrix4(m) {\n    // input: THREE.Matrix4 affine matrix\n    var x = this.x,\n        y = this.y,\n        z = this.z;\n    var e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12];\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13];\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n    return this;\n  },\n  applyProjection: function applyProjection(m) {\n    // input: THREE.Matrix4 projection matrix\n    var x = this.x,\n        y = this.y,\n        z = this.z;\n    var e = m.elements;\n    var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]); // perspective divide\n\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;\n    return this;\n  },\n  applyQuaternion: function applyQuaternion(q) {\n    var x = this.x;\n    var y = this.y;\n    var z = this.z;\n    var qx = q.x;\n    var qy = q.y;\n    var qz = q.z;\n    var qw = q.w; // calculate quat * vector\n\n    var ix = qw * x + qy * z - qz * y;\n    var iy = qw * y + qz * x - qx * z;\n    var iz = qw * z + qx * y - qy * x;\n    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return this;\n  },\n  project: function () {\n    var matrix;\n    return function project(camera) {\n      if (matrix === undefined) matrix = new THREE.Matrix4();\n      matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));\n      return this.applyProjection(matrix);\n    };\n  }(),\n  unproject: function () {\n    var matrix;\n    return function unproject(camera) {\n      if (matrix === undefined) matrix = new THREE.Matrix4();\n      matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));\n      return this.applyProjection(matrix);\n    };\n  }(),\n  transformDirection: function transformDirection(m) {\n    // input: THREE.Matrix4 affine matrix\n    // vector interpreted as a direction\n    var x = this.x,\n        y = this.y,\n        z = this.z;\n    var e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z;\n    this.y = e[1] * x + e[5] * y + e[9] * z;\n    this.z = e[2] * x + e[6] * y + e[10] * z;\n    this.normalize();\n    return this;\n  },\n  divide: function divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n    return this;\n  },\n  divideScalar: function divideScalar(scalar) {\n    if (scalar !== 0) {\n      var invScalar = 1 / scalar;\n      this.x *= invScalar;\n      this.y *= invScalar;\n      this.z *= invScalar;\n    } else {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n    }\n\n    return this;\n  },\n  min: function min(v) {\n    if (this.x > v.x) {\n      this.x = v.x;\n    }\n\n    if (this.y > v.y) {\n      this.y = v.y;\n    }\n\n    if (this.z > v.z) {\n      this.z = v.z;\n    }\n\n    return this;\n  },\n  max: function max(v) {\n    if (this.x < v.x) {\n      this.x = v.x;\n    }\n\n    if (this.y < v.y) {\n      this.y = v.y;\n    }\n\n    if (this.z < v.z) {\n      this.z = v.z;\n    }\n\n    return this;\n  },\n  clamp: function clamp(min, max) {\n    // This function assumes min < max, if this assumption isn't true it will not operate correctly\n    if (this.x < min.x) {\n      this.x = min.x;\n    } else if (this.x > max.x) {\n      this.x = max.x;\n    }\n\n    if (this.y < min.y) {\n      this.y = min.y;\n    } else if (this.y > max.y) {\n      this.y = max.y;\n    }\n\n    if (this.z < min.z) {\n      this.z = min.z;\n    } else if (this.z > max.z) {\n      this.z = max.z;\n    }\n\n    return this;\n  },\n  clampScalar: function () {\n    var min, max;\n    return function clampScalar(minVal, maxVal) {\n      if (min === undefined) {\n        min = new THREE.Vector3();\n        max = new THREE.Vector3();\n      }\n\n      min.set(minVal, minVal, minVal);\n      max.set(maxVal, maxVal, maxVal);\n      return this.clamp(min, max);\n    };\n  }(),\n  floor: function floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    return this;\n  },\n  ceil: function ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    return this;\n  },\n  round: function round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    return this;\n  },\n  roundToZero: function roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n    return this;\n  },\n  negate: function negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  },\n  dot: function dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  },\n  lengthSq: function lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  },\n  length: function length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  },\n  lengthManhattan: function lengthManhattan() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n  },\n  normalize: function normalize() {\n    return this.divideScalar(this.length());\n  },\n  setLength: function setLength(l) {\n    var oldLength = this.length();\n\n    if (oldLength !== 0 && l !== oldLength) {\n      this.multiplyScalar(l / oldLength);\n    }\n\n    return this;\n  },\n  lerp: function lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    return this;\n  },\n  lerpVectors: function lerpVectors(v1, v2, alpha) {\n    this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\n    return this;\n  },\n  cross: function cross(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\n      return this.crossVectors(v, w);\n    }\n\n    var x = this.x,\n        y = this.y,\n        z = this.z;\n    this.x = y * v.z - z * v.y;\n    this.y = z * v.x - x * v.z;\n    this.z = x * v.y - y * v.x;\n    return this;\n  },\n  crossVectors: function crossVectors(a, b) {\n    var ax = a.x,\n        ay = a.y,\n        az = a.z;\n    var bx = b.x,\n        by = b.y,\n        bz = b.z;\n    this.x = ay * bz - az * by;\n    this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n    return this;\n  },\n  projectOnVector: function () {\n    var v1, dot;\n    return function projectOnVector(vector) {\n      if (v1 === undefined) v1 = new THREE.Vector3();\n      v1.copy(vector).normalize();\n      dot = this.dot(v1);\n      return this.copy(v1).multiplyScalar(dot);\n    };\n  }(),\n  projectOnPlane: function () {\n    var v1;\n    return function projectOnPlane(planeNormal) {\n      if (v1 === undefined) v1 = new THREE.Vector3();\n      v1.copy(this).projectOnVector(planeNormal);\n      return this.sub(v1);\n    };\n  }(),\n  reflect: function () {\n    // reflect incident vector off plane orthogonal to normal\n    // normal is assumed to have unit length\n    var v1;\n    return function reflect(normal) {\n      if (v1 === undefined) v1 = new THREE.Vector3();\n      return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    };\n  }(),\n  angleTo: function angleTo(v) {\n    var theta = this.dot(v) / (this.length() * v.length()); // clamp, to handle numerical problems\n\n    return Math.acos(THREE.Math.clamp(theta, -1, 1));\n  },\n  distanceTo: function distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  },\n  distanceToSquared: function distanceToSquared(v) {\n    var dx = this.x - v.x;\n    var dy = this.y - v.y;\n    var dz = this.z - v.z;\n    return dx * dx + dy * dy + dz * dz;\n  },\n  setEulerFromRotationMatrix: function setEulerFromRotationMatrix(m, order) {\n    console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');\n  },\n  setEulerFromQuaternion: function setEulerFromQuaternion(q, order) {\n    console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');\n  },\n  getPositionFromMatrix: function getPositionFromMatrix(m) {\n    console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');\n    return this.setFromMatrixPosition(m);\n  },\n  getScaleFromMatrix: function getScaleFromMatrix(m) {\n    console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');\n    return this.setFromMatrixScale(m);\n  },\n  getColumnFromMatrix: function getColumnFromMatrix(index, matrix) {\n    console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');\n    return this.setFromMatrixColumn(index, matrix);\n  },\n  setFromMatrixPosition: function setFromMatrixPosition(m) {\n    this.x = m.elements[12];\n    this.y = m.elements[13];\n    this.z = m.elements[14];\n    return this;\n  },\n  setFromMatrixScale: function setFromMatrixScale(m) {\n    var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();\n    var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();\n    var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();\n    this.x = sx;\n    this.y = sy;\n    this.z = sz;\n    return this;\n  },\n  setFromMatrixColumn: function setFromMatrixColumn(index, matrix) {\n    var offset = index * 4;\n    var me = matrix.elements;\n    this.x = me[offset];\n    this.y = me[offset + 1];\n    this.z = me[offset + 2];\n    return this;\n  },\n  equals: function equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z;\n  },\n  fromArray: function fromArray(array, offset) {\n    if (offset === undefined) offset = 0;\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return this;\n  },\n  toArray: function toArray(array, offset) {\n    if (array === undefined) array = [];\n    if (offset === undefined) offset = 0;\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    return array;\n  },\n  fromAttribute: function fromAttribute(attribute, index, offset) {\n    if (offset === undefined) offset = 0;\n    index = index * attribute.itemSize + offset;\n    this.x = attribute.array[index];\n    this.y = attribute.array[index + 1];\n    this.z = attribute.array[index + 2];\n    return this;\n  }\n}; // File:src/math/Vector4.js\n\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\n\nTHREE.Vector4 = function (x, y, z, w) {\n  this.x = x || 0;\n  this.y = y || 0;\n  this.z = z || 0;\n  this.w = w !== undefined ? w : 1;\n};\n\nTHREE.Vector4.prototype = {\n  constructor: THREE.Vector4,\n  set: function set(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  },\n  setX: function setX(x) {\n    this.x = x;\n    return this;\n  },\n  setY: function setY(y) {\n    this.y = y;\n    return this;\n  },\n  setZ: function setZ(z) {\n    this.z = z;\n    return this;\n  },\n  setW: function setW(w) {\n    this.w = w;\n    return this;\n  },\n  setComponent: function setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n\n      case 1:\n        this.y = value;\n        break;\n\n      case 2:\n        this.z = value;\n        break;\n\n      case 3:\n        this.w = value;\n        break;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  },\n  getComponent: function getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n\n      case 1:\n        return this.y;\n\n      case 2:\n        return this.z;\n\n      case 3:\n        return this.w;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  },\n  clone: function clone() {\n    return new this.constructor(this.x, this.y, this.z, this.w);\n  },\n  copy: function copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    this.w = v.w !== undefined ? v.w : 1;\n    return this;\n  },\n  add: function add(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n      return this.addVectors(v, w);\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    this.w += v.w;\n    return this;\n  },\n  addScalar: function addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    this.w += s;\n    return this;\n  },\n  addVectors: function addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    this.w = a.w + b.w;\n    return this;\n  },\n  addScaledVector: function addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    this.w += v.w * s;\n    return this;\n  },\n  sub: function sub(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n      return this.subVectors(v, w);\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    this.w -= v.w;\n    return this;\n  },\n  subScalar: function subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    this.w -= s;\n    return this;\n  },\n  subVectors: function subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    this.w = a.w - b.w;\n    return this;\n  },\n  multiplyScalar: function multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    this.w *= scalar;\n    return this;\n  },\n  applyMatrix4: function applyMatrix4(m) {\n    var x = this.x;\n    var y = this.y;\n    var z = this.z;\n    var w = this.w;\n    var e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n    return this;\n  },\n  divideScalar: function divideScalar(scalar) {\n    if (scalar !== 0) {\n      var invScalar = 1 / scalar;\n      this.x *= invScalar;\n      this.y *= invScalar;\n      this.z *= invScalar;\n      this.w *= invScalar;\n    } else {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.w = 1;\n    }\n\n    return this;\n  },\n  setAxisAngleFromQuaternion: function setAxisAngleFromQuaternion(q) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n    // q is assumed to be normalized\n    this.w = 2 * Math.acos(q.w);\n    var s = Math.sqrt(1 - q.w * q.w);\n\n    if (s < 0.0001) {\n      this.x = 1;\n      this.y = 0;\n      this.z = 0;\n    } else {\n      this.x = q.x / s;\n      this.y = q.y / s;\n      this.z = q.z / s;\n    }\n\n    return this;\n  },\n  setAxisAngleFromRotationMatrix: function setAxisAngleFromRotationMatrix(m) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n    var angle,\n        x,\n        y,\n        z,\n        // variables for result\n    epsilon = 0.01,\n        // margin to allow for rounding errors\n    epsilon2 = 0.1,\n        // margin to distinguish between 0 and 180 degrees\n    te = m.elements,\n        m11 = te[0],\n        m12 = te[4],\n        m13 = te[8],\n        m21 = te[1],\n        m22 = te[5],\n        m23 = te[9],\n        m31 = te[2],\n        m32 = te[6],\n        m33 = te[10];\n\n    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n      // singularity found\n      // first check for identity matrix which must have +1 for all terms\n      // in leading diagonal and zero in other terms\n      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n        // this singularity is identity matrix so angle = 0\n        this.set(1, 0, 0, 0);\n        return this; // zero angle, arbitrary axis\n      } // otherwise this singularity is angle = 180\n\n\n      angle = Math.PI;\n      var xx = (m11 + 1) / 2;\n      var yy = (m22 + 1) / 2;\n      var zz = (m33 + 1) / 2;\n      var xy = (m12 + m21) / 4;\n      var xz = (m13 + m31) / 4;\n      var yz = (m23 + m32) / 4;\n\n      if (xx > yy && xx > zz) {\n        // m11 is the largest diagonal term\n        if (xx < epsilon) {\n          x = 0;\n          y = 0.707106781;\n          z = 0.707106781;\n        } else {\n          x = Math.sqrt(xx);\n          y = xy / x;\n          z = xz / x;\n        }\n      } else if (yy > zz) {\n        // m22 is the largest diagonal term\n        if (yy < epsilon) {\n          x = 0.707106781;\n          y = 0;\n          z = 0.707106781;\n        } else {\n          y = Math.sqrt(yy);\n          x = xy / y;\n          z = yz / y;\n        }\n      } else {\n        // m33 is the largest diagonal term so base result on this\n        if (zz < epsilon) {\n          x = 0.707106781;\n          y = 0.707106781;\n          z = 0;\n        } else {\n          z = Math.sqrt(zz);\n          x = xz / z;\n          y = yz / z;\n        }\n      }\n\n      this.set(x, y, z, angle);\n      return this; // return 180 deg rotation\n    } // as we have reached here there are no singularities so we can handle normally\n\n\n    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n\n    if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be\n    // caught by singularity test above, but I've left it in just in case\n\n    this.x = (m32 - m23) / s;\n    this.y = (m13 - m31) / s;\n    this.z = (m21 - m12) / s;\n    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n    return this;\n  },\n  min: function min(v) {\n    if (this.x > v.x) {\n      this.x = v.x;\n    }\n\n    if (this.y > v.y) {\n      this.y = v.y;\n    }\n\n    if (this.z > v.z) {\n      this.z = v.z;\n    }\n\n    if (this.w > v.w) {\n      this.w = v.w;\n    }\n\n    return this;\n  },\n  max: function max(v) {\n    if (this.x < v.x) {\n      this.x = v.x;\n    }\n\n    if (this.y < v.y) {\n      this.y = v.y;\n    }\n\n    if (this.z < v.z) {\n      this.z = v.z;\n    }\n\n    if (this.w < v.w) {\n      this.w = v.w;\n    }\n\n    return this;\n  },\n  clamp: function clamp(min, max) {\n    // This function assumes min < max, if this assumption isn't true it will not operate correctly\n    if (this.x < min.x) {\n      this.x = min.x;\n    } else if (this.x > max.x) {\n      this.x = max.x;\n    }\n\n    if (this.y < min.y) {\n      this.y = min.y;\n    } else if (this.y > max.y) {\n      this.y = max.y;\n    }\n\n    if (this.z < min.z) {\n      this.z = min.z;\n    } else if (this.z > max.z) {\n      this.z = max.z;\n    }\n\n    if (this.w < min.w) {\n      this.w = min.w;\n    } else if (this.w > max.w) {\n      this.w = max.w;\n    }\n\n    return this;\n  },\n  clampScalar: function () {\n    var min, max;\n    return function clampScalar(minVal, maxVal) {\n      if (min === undefined) {\n        min = new THREE.Vector4();\n        max = new THREE.Vector4();\n      }\n\n      min.set(minVal, minVal, minVal, minVal);\n      max.set(maxVal, maxVal, maxVal, maxVal);\n      return this.clamp(min, max);\n    };\n  }(),\n  floor: function floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    this.w = Math.floor(this.w);\n    return this;\n  },\n  ceil: function ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    this.w = Math.ceil(this.w);\n    return this;\n  },\n  round: function round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    this.w = Math.round(this.w);\n    return this;\n  },\n  roundToZero: function roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\n    return this;\n  },\n  negate: function negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    this.w = -this.w;\n    return this;\n  },\n  dot: function dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n  },\n  lengthSq: function lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  },\n  length: function length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  },\n  lengthManhattan: function lengthManhattan() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n  },\n  normalize: function normalize() {\n    return this.divideScalar(this.length());\n  },\n  setLength: function setLength(l) {\n    var oldLength = this.length();\n\n    if (oldLength !== 0 && l !== oldLength) {\n      this.multiplyScalar(l / oldLength);\n    }\n\n    return this;\n  },\n  lerp: function lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    this.w += (v.w - this.w) * alpha;\n    return this;\n  },\n  lerpVectors: function lerpVectors(v1, v2, alpha) {\n    this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\n    return this;\n  },\n  equals: function equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n  },\n  fromArray: function fromArray(array, offset) {\n    if (offset === undefined) offset = 0;\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  },\n  toArray: function toArray(array, offset) {\n    if (array === undefined) array = [];\n    if (offset === undefined) offset = 0;\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    array[offset + 3] = this.w;\n    return array;\n  },\n  fromAttribute: function fromAttribute(attribute, index, offset) {\n    if (offset === undefined) offset = 0;\n    index = index * attribute.itemSize + offset;\n    this.x = attribute.array[index];\n    this.y = attribute.array[index + 1];\n    this.z = attribute.array[index + 2];\n    this.w = attribute.array[index + 3];\n    return this;\n  }\n}; // File:src/math/Euler.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\n\nTHREE.Euler = function (x, y, z, order) {\n  this._x = x || 0;\n  this._y = y || 0;\n  this._z = z || 0;\n  this._order = order || THREE.Euler.DefaultOrder;\n};\n\nTHREE.Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];\nTHREE.Euler.DefaultOrder = 'XYZ';\nTHREE.Euler.prototype = {\n  constructor: THREE.Euler,\n\n  get x() {\n    return this._x;\n  },\n\n  set x(value) {\n    this._x = value;\n    this.onChangeCallback();\n  },\n\n  get y() {\n    return this._y;\n  },\n\n  set y(value) {\n    this._y = value;\n    this.onChangeCallback();\n  },\n\n  get z() {\n    return this._z;\n  },\n\n  set z(value) {\n    this._z = value;\n    this.onChangeCallback();\n  },\n\n  get order() {\n    return this._order;\n  },\n\n  set order(value) {\n    this._order = value;\n    this.onChangeCallback();\n  },\n\n  set: function set(x, y, z, order) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order || this._order;\n    this.onChangeCallback();\n    return this;\n  },\n  clone: function clone() {\n    return new this.constructor(this._x, this._y, this._z, this._order);\n  },\n  copy: function copy(euler) {\n    this._x = euler._x;\n    this._y = euler._y;\n    this._z = euler._z;\n    this._order = euler._order;\n    this.onChangeCallback();\n    return this;\n  },\n  setFromRotationMatrix: function setFromRotationMatrix(m, order, update) {\n    var clamp = THREE.Math.clamp; // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    var te = m.elements;\n    var m11 = te[0],\n        m12 = te[4],\n        m13 = te[8];\n    var m21 = te[1],\n        m22 = te[5],\n        m23 = te[9];\n    var m31 = te[2],\n        m32 = te[6],\n        m33 = te[10];\n    order = order || this._order;\n\n    if (order === 'XYZ') {\n      this._y = Math.asin(clamp(m13, -1, 1));\n\n      if (Math.abs(m13) < 0.99999) {\n        this._x = Math.atan2(-m23, m33);\n        this._z = Math.atan2(-m12, m11);\n      } else {\n        this._x = Math.atan2(m32, m22);\n        this._z = 0;\n      }\n    } else if (order === 'YXZ') {\n      this._x = Math.asin(-clamp(m23, -1, 1));\n\n      if (Math.abs(m23) < 0.99999) {\n        this._y = Math.atan2(m13, m33);\n        this._z = Math.atan2(m21, m22);\n      } else {\n        this._y = Math.atan2(-m31, m11);\n        this._z = 0;\n      }\n    } else if (order === 'ZXY') {\n      this._x = Math.asin(clamp(m32, -1, 1));\n\n      if (Math.abs(m32) < 0.99999) {\n        this._y = Math.atan2(-m31, m33);\n        this._z = Math.atan2(-m12, m22);\n      } else {\n        this._y = 0;\n        this._z = Math.atan2(m21, m11);\n      }\n    } else if (order === 'ZYX') {\n      this._y = Math.asin(-clamp(m31, -1, 1));\n\n      if (Math.abs(m31) < 0.99999) {\n        this._x = Math.atan2(m32, m33);\n        this._z = Math.atan2(m21, m11);\n      } else {\n        this._x = 0;\n        this._z = Math.atan2(-m12, m22);\n      }\n    } else if (order === 'YZX') {\n      this._z = Math.asin(clamp(m21, -1, 1));\n\n      if (Math.abs(m21) < 0.99999) {\n        this._x = Math.atan2(-m23, m22);\n        this._y = Math.atan2(-m31, m11);\n      } else {\n        this._x = 0;\n        this._y = Math.atan2(m13, m33);\n      }\n    } else if (order === 'XZY') {\n      this._z = Math.asin(-clamp(m12, -1, 1));\n\n      if (Math.abs(m12) < 0.99999) {\n        this._x = Math.atan2(m32, m22);\n        this._y = Math.atan2(m13, m11);\n      } else {\n        this._x = Math.atan2(-m23, m33);\n        this._y = 0;\n      }\n    } else {\n      console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);\n    }\n\n    this._order = order;\n    if (update !== false) this.onChangeCallback();\n    return this;\n  },\n  setFromQuaternion: function () {\n    var matrix;\n    return function (q, order, update) {\n      if (matrix === undefined) matrix = new THREE.Matrix4();\n      matrix.makeRotationFromQuaternion(q);\n      this.setFromRotationMatrix(matrix, order, update);\n      return this;\n    };\n  }(),\n  setFromVector3: function setFromVector3(v, order) {\n    return this.set(v.x, v.y, v.z, order || this._order);\n  },\n  reorder: function () {\n    // WARNING: this discards revolution information -bhouston\n    var q = new THREE.Quaternion();\n    return function (newOrder) {\n      q.setFromEuler(this);\n      this.setFromQuaternion(q, newOrder);\n    };\n  }(),\n  equals: function equals(euler) {\n    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n  },\n  fromArray: function fromArray(array) {\n    this._x = array[0];\n    this._y = array[1];\n    this._z = array[2];\n    if (array[3] !== undefined) this._order = array[3];\n    this.onChangeCallback();\n    return this;\n  },\n  toArray: function toArray(array, offset) {\n    if (array === undefined) array = [];\n    if (offset === undefined) offset = 0;\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._order;\n    return array;\n  },\n  toVector3: function toVector3(optionalResult) {\n    if (optionalResult) {\n      return optionalResult.set(this._x, this._y, this._z);\n    } else {\n      return new THREE.Vector3(this._x, this._y, this._z);\n    }\n  },\n  onChange: function onChange(callback) {\n    this.onChangeCallback = callback;\n    return this;\n  },\n  onChangeCallback: function onChangeCallback() {}\n}; // File:src/math/Line3.js\n\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\n\nTHREE.Line3 = function (start, end) {\n  this.start = start !== undefined ? start : new THREE.Vector3();\n  this.end = end !== undefined ? end : new THREE.Vector3();\n};\n\nTHREE.Line3.prototype = {\n  constructor: THREE.Line3,\n  set: function set(start, end) {\n    this.start.copy(start);\n    this.end.copy(end);\n    return this;\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(line) {\n    this.start.copy(line.start);\n    this.end.copy(line.end);\n    return this;\n  },\n  center: function center(optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    return result.addVectors(this.start, this.end).multiplyScalar(0.5);\n  },\n  delta: function delta(optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    return result.subVectors(this.end, this.start);\n  },\n  distanceSq: function distanceSq() {\n    return this.start.distanceToSquared(this.end);\n  },\n  distance: function distance() {\n    return this.start.distanceTo(this.end);\n  },\n  at: function at(t, optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    return this.delta(result).multiplyScalar(t).add(this.start);\n  },\n  closestPointToPointParameter: function () {\n    var startP = new THREE.Vector3();\n    var startEnd = new THREE.Vector3();\n    return function (point, clampToLine) {\n      startP.subVectors(point, this.start);\n      startEnd.subVectors(this.end, this.start);\n      var startEnd2 = startEnd.dot(startEnd);\n      var startEnd_startP = startEnd.dot(startP);\n      var t = startEnd_startP / startEnd2;\n\n      if (clampToLine) {\n        t = THREE.Math.clamp(t, 0, 1);\n      }\n\n      return t;\n    };\n  }(),\n  closestPointToPoint: function closestPointToPoint(point, clampToLine, optionalTarget) {\n    var t = this.closestPointToPointParameter(point, clampToLine);\n    var result = optionalTarget || new THREE.Vector3();\n    return this.delta(result).multiplyScalar(t).add(this.start);\n  },\n  applyMatrix4: function applyMatrix4(matrix) {\n    this.start.applyMatrix4(matrix);\n    this.end.applyMatrix4(matrix);\n    return this;\n  },\n  equals: function equals(line) {\n    return line.start.equals(this.start) && line.end.equals(this.end);\n  }\n}; // File:src/math/Box2.js\n\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\n\nTHREE.Box2 = function (min, max) {\n  this.min = min !== undefined ? min : new THREE.Vector2(Infinity, Infinity);\n  this.max = max !== undefined ? max : new THREE.Vector2(-Infinity, -Infinity);\n};\n\nTHREE.Box2.prototype = {\n  constructor: THREE.Box2,\n  set: function set(min, max) {\n    this.min.copy(min);\n    this.max.copy(max);\n    return this;\n  },\n  setFromPoints: function setFromPoints(points) {\n    this.makeEmpty();\n\n    for (var i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n\n    return this;\n  },\n  setFromCenterAndSize: function () {\n    var v1 = new THREE.Vector2();\n    return function (center, size) {\n      var halfSize = v1.copy(size).multiplyScalar(0.5);\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    };\n  }(),\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(box) {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  },\n  makeEmpty: function makeEmpty() {\n    this.min.x = this.min.y = Infinity;\n    this.max.x = this.max.y = -Infinity;\n    return this;\n  },\n  empty: function empty() {\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n    return this.max.x < this.min.x || this.max.y < this.min.y;\n  },\n  center: function center(optionalTarget) {\n    var result = optionalTarget || new THREE.Vector2();\n    return result.addVectors(this.min, this.max).multiplyScalar(0.5);\n  },\n  size: function size(optionalTarget) {\n    var result = optionalTarget || new THREE.Vector2();\n    return result.subVectors(this.max, this.min);\n  },\n  expandByPoint: function expandByPoint(point) {\n    this.min.min(point);\n    this.max.max(point);\n    return this;\n  },\n  expandByVector: function expandByVector(vector) {\n    this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  },\n  expandByScalar: function expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n    return this;\n  },\n  containsPoint: function containsPoint(point) {\n    if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {\n      return false;\n    }\n\n    return true;\n  },\n  containsBox: function containsBox(box) {\n    if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y) {\n      return true;\n    }\n\n    return false;\n  },\n  getParameter: function getParameter(point, optionalTarget) {\n    // This can potentially have a divide by zero if the box\n    // has a size dimension of 0.\n    var result = optionalTarget || new THREE.Vector2();\n    return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));\n  },\n  isIntersectionBox: function isIntersectionBox(box) {\n    // using 6 splitting planes to rule out intersections.\n    if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {\n      return false;\n    }\n\n    return true;\n  },\n  clampPoint: function clampPoint(point, optionalTarget) {\n    var result = optionalTarget || new THREE.Vector2();\n    return result.copy(point).clamp(this.min, this.max);\n  },\n  distanceToPoint: function () {\n    var v1 = new THREE.Vector2();\n    return function (point) {\n      var clampedPoint = v1.copy(point).clamp(this.min, this.max);\n      return clampedPoint.sub(point).length();\n    };\n  }(),\n  intersect: function intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max);\n    return this;\n  },\n  union: function union(box) {\n    this.min.min(box.min);\n    this.max.max(box.max);\n    return this;\n  },\n  translate: function translate(offset) {\n    this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  },\n  equals: function equals(box) {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n}; // File:src/math/Box3.js\n\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\n\nTHREE.Box3 = function (min, max) {\n  this.min = min !== undefined ? min : new THREE.Vector3(Infinity, Infinity, Infinity);\n  this.max = max !== undefined ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);\n};\n\nTHREE.Box3.prototype = {\n  constructor: THREE.Box3,\n  set: function set(min, max) {\n    this.min.copy(min);\n    this.max.copy(max);\n    return this;\n  },\n  setFromPoints: function setFromPoints(points) {\n    this.makeEmpty();\n\n    for (var i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n\n    return this;\n  },\n  setFromCenterAndSize: function () {\n    var v1 = new THREE.Vector3();\n    return function (center, size) {\n      var halfSize = v1.copy(size).multiplyScalar(0.5);\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    };\n  }(),\n  setFromObject: function () {\n    // Computes the world-axis-aligned bounding box of an object (including its children),\n    // accounting for both the object's, and children's, world transforms\n    var v1 = new THREE.Vector3();\n    return function (object) {\n      var scope = this;\n      object.updateMatrixWorld(true);\n      this.makeEmpty();\n      object.traverse(function (node) {\n        var geometry = node.geometry;\n\n        if (geometry !== undefined) {\n          if (geometry instanceof THREE.Geometry) {\n            var vertices = geometry.vertices;\n\n            for (var i = 0, il = vertices.length; i < il; i++) {\n              v1.copy(vertices[i]);\n              v1.applyMatrix4(node.matrixWorld);\n              scope.expandByPoint(v1);\n            }\n          } else if (geometry instanceof THREE.BufferGeometry && geometry.attributes['position'] !== undefined) {\n            var positions = geometry.attributes['position'].array;\n\n            for (var i = 0, il = positions.length; i < il; i += 3) {\n              v1.set(positions[i], positions[i + 1], positions[i + 2]);\n              v1.applyMatrix4(node.matrixWorld);\n              scope.expandByPoint(v1);\n            }\n          }\n        }\n      });\n      return this;\n    };\n  }(),\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(box) {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  },\n  makeEmpty: function makeEmpty() {\n    this.min.x = this.min.y = this.min.z = Infinity;\n    this.max.x = this.max.y = this.max.z = -Infinity;\n    return this;\n  },\n  empty: function empty() {\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n  },\n  center: function center(optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    return result.addVectors(this.min, this.max).multiplyScalar(0.5);\n  },\n  size: function size(optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    return result.subVectors(this.max, this.min);\n  },\n  expandByPoint: function expandByPoint(point) {\n    this.min.min(point);\n    this.max.max(point);\n    return this;\n  },\n  expandByVector: function expandByVector(vector) {\n    this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  },\n  expandByScalar: function expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n    return this;\n  },\n  containsPoint: function containsPoint(point) {\n    if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {\n      return false;\n    }\n\n    return true;\n  },\n  containsBox: function containsBox(box) {\n    if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z) {\n      return true;\n    }\n\n    return false;\n  },\n  getParameter: function getParameter(point, optionalTarget) {\n    // This can potentially have a divide by zero if the box\n    // has a size dimension of 0.\n    var result = optionalTarget || new THREE.Vector3();\n    return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n  },\n  isIntersectionBox: function isIntersectionBox(box) {\n    // using 6 splitting planes to rule out intersections.\n    if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {\n      return false;\n    }\n\n    return true;\n  },\n  clampPoint: function clampPoint(point, optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    return result.copy(point).clamp(this.min, this.max);\n  },\n  distanceToPoint: function () {\n    var v1 = new THREE.Vector3();\n    return function (point) {\n      var clampedPoint = v1.copy(point).clamp(this.min, this.max);\n      return clampedPoint.sub(point).length();\n    };\n  }(),\n  getBoundingSphere: function () {\n    var v1 = new THREE.Vector3();\n    return function (optionalTarget) {\n      var result = optionalTarget || new THREE.Sphere();\n      result.center = this.center();\n      result.radius = this.size(v1).length() * 0.5;\n      return result;\n    };\n  }(),\n  intersect: function intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max);\n    return this;\n  },\n  union: function union(box) {\n    this.min.min(box.min);\n    this.max.max(box.max);\n    return this;\n  },\n  applyMatrix4: function () {\n    var points = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n    return function (matrix) {\n      // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n\n      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n\n      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n\n      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n\n      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n\n      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n\n      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n\n      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n      this.makeEmpty();\n      this.setFromPoints(points);\n      return this;\n    };\n  }(),\n  translate: function translate(offset) {\n    this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  },\n  equals: function equals(box) {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n}; // File:src/math/Matrix3.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\n\nTHREE.Matrix3 = function () {\n  this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n\n  if (arguments.length > 0) {\n    console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');\n  }\n};\n\nTHREE.Matrix3.prototype = {\n  constructor: THREE.Matrix3,\n  set: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    var te = this.elements;\n    te[0] = n11;\n    te[3] = n12;\n    te[6] = n13;\n    te[1] = n21;\n    te[4] = n22;\n    te[7] = n23;\n    te[2] = n31;\n    te[5] = n32;\n    te[8] = n33;\n    return this;\n  },\n  identity: function identity() {\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    return this;\n  },\n  clone: function clone() {\n    return new this.constructor().fromArray(this.elements);\n  },\n  copy: function copy(m) {\n    var me = m.elements;\n    this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);\n    return this;\n  },\n  multiplyVector3: function multiplyVector3(vector) {\n    console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');\n    return vector.applyMatrix3(this);\n  },\n  multiplyVector3Array: function multiplyVector3Array(a) {\n    console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');\n    return this.applyToVector3Array(a);\n  },\n  applyToVector3Array: function () {\n    var v1;\n    return function (array, offset, length) {\n      if (v1 === undefined) v1 = new THREE.Vector3();\n      if (offset === undefined) offset = 0;\n      if (length === undefined) length = array.length;\n\n      for (var i = 0, j = offset; i < length; i += 3, j += 3) {\n        v1.fromArray(array, j);\n        v1.applyMatrix3(this);\n        v1.toArray(array, j);\n      }\n\n      return array;\n    };\n  }(),\n  applyToBuffer: function () {\n    var v1;\n    return function applyToBuffer(buffer, offset, length) {\n      if (v1 === undefined) v1 = new THREE.Vector3();\n      if (offset === undefined) offset = 0;\n      if (length === undefined) length = buffer.length / buffer.itemSize;\n\n      for (var i = 0, j = offset; i < length; i++, j++) {\n        v1.x = buffer.getX(j);\n        v1.y = buffer.getY(j);\n        v1.z = buffer.getZ(j);\n        v1.applyMatrix3(this);\n        buffer.setXYZ(v1.x, v1.y, v1.z);\n      }\n\n      return buffer;\n    };\n  }(),\n  multiplyScalar: function multiplyScalar(s) {\n    var te = this.elements;\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] *= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n    te[8] *= s;\n    return this;\n  },\n  determinant: function determinant() {\n    var te = this.elements;\n    var a = te[0],\n        b = te[1],\n        c = te[2],\n        d = te[3],\n        e = te[4],\n        f = te[5],\n        g = te[6],\n        h = te[7],\n        i = te[8];\n    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n  },\n  getInverse: function getInverse(matrix, throwOnInvertible) {\n    // input: THREE.Matrix4\n    // ( based on http://code.google.com/p/webgl-mjs/ )\n    var me = matrix.elements;\n    var te = this.elements;\n    te[0] = me[10] * me[5] - me[6] * me[9];\n    te[1] = -me[10] * me[1] + me[2] * me[9];\n    te[2] = me[6] * me[1] - me[2] * me[5];\n    te[3] = -me[10] * me[4] + me[6] * me[8];\n    te[4] = me[10] * me[0] - me[2] * me[8];\n    te[5] = -me[6] * me[0] + me[2] * me[4];\n    te[6] = me[9] * me[4] - me[5] * me[8];\n    te[7] = -me[9] * me[0] + me[1] * me[8];\n    te[8] = me[5] * me[0] - me[1] * me[4];\n    var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6]; // no inverse\n\n    if (det === 0) {\n      var msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n      if (throwOnInvertible || false) {\n        throw new Error(msg);\n      } else {\n        console.warn(msg);\n      }\n\n      this.identity();\n      return this;\n    }\n\n    this.multiplyScalar(1.0 / det);\n    return this;\n  },\n  transpose: function transpose() {\n    var tmp,\n        m = this.elements;\n    tmp = m[1];\n    m[1] = m[3];\n    m[3] = tmp;\n    tmp = m[2];\n    m[2] = m[6];\n    m[6] = tmp;\n    tmp = m[5];\n    m[5] = m[7];\n    m[7] = tmp;\n    return this;\n  },\n  flattenToArrayOffset: function flattenToArrayOffset(array, offset) {\n    var te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    return array;\n  },\n  getNormalMatrix: function getNormalMatrix(m) {\n    // input: THREE.Matrix4\n    this.getInverse(m).transpose();\n    return this;\n  },\n  transposeIntoArray: function transposeIntoArray(r) {\n    var m = this.elements;\n    r[0] = m[0];\n    r[1] = m[3];\n    r[2] = m[6];\n    r[3] = m[1];\n    r[4] = m[4];\n    r[5] = m[7];\n    r[6] = m[2];\n    r[7] = m[5];\n    r[8] = m[8];\n    return this;\n  },\n  fromArray: function fromArray(array) {\n    this.elements.set(array);\n    return this;\n  },\n  toArray: function toArray() {\n    var te = this.elements;\n    return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8]];\n  }\n}; // File:src/math/Matrix4.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\n\nTHREE.Matrix4 = function () {\n  this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n\n  if (arguments.length > 0) {\n    console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');\n  }\n};\n\nTHREE.Matrix4.prototype = {\n  constructor: THREE.Matrix4,\n  set: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n    var te = this.elements;\n    te[0] = n11;\n    te[4] = n12;\n    te[8] = n13;\n    te[12] = n14;\n    te[1] = n21;\n    te[5] = n22;\n    te[9] = n23;\n    te[13] = n24;\n    te[2] = n31;\n    te[6] = n32;\n    te[10] = n33;\n    te[14] = n34;\n    te[3] = n41;\n    te[7] = n42;\n    te[11] = n43;\n    te[15] = n44;\n    return this;\n  },\n  identity: function identity() {\n    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  },\n  clone: function clone() {\n    return new THREE.Matrix4().fromArray(this.elements);\n  },\n  copy: function copy(m) {\n    this.elements.set(m.elements);\n    return this;\n  },\n  extractPosition: function extractPosition(m) {\n    console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');\n    return this.copyPosition(m);\n  },\n  copyPosition: function copyPosition(m) {\n    var te = this.elements;\n    var me = m.elements;\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    return this;\n  },\n  extractBasis: function extractBasis(xAxis, yAxis, zAxis) {\n    var te = this.elements;\n    xAxis.set(te[0], te[1], te[2]);\n    yAxis.set(te[4], te[5], te[6]);\n    zAxis.set(te[8], te[9], te[10]);\n    return this;\n  },\n  makeBasis: function makeBasis(xAxis, yAxis, zAxis) {\n    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n    return this;\n  },\n  extractRotation: function () {\n    var v1;\n    return function (m) {\n      if (v1 === undefined) v1 = new THREE.Vector3();\n      var te = this.elements;\n      var me = m.elements;\n      var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();\n      var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();\n      var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();\n      te[0] = me[0] * scaleX;\n      te[1] = me[1] * scaleX;\n      te[2] = me[2] * scaleX;\n      te[4] = me[4] * scaleY;\n      te[5] = me[5] * scaleY;\n      te[6] = me[6] * scaleY;\n      te[8] = me[8] * scaleZ;\n      te[9] = me[9] * scaleZ;\n      te[10] = me[10] * scaleZ;\n      return this;\n    };\n  }(),\n  makeRotationFromEuler: function makeRotationFromEuler(euler) {\n    if (euler instanceof THREE.Euler === false) {\n      console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\n    }\n\n    var te = this.elements;\n    var x = euler.x,\n        y = euler.y,\n        z = euler.z;\n    var a = Math.cos(x),\n        b = Math.sin(x);\n    var c = Math.cos(y),\n        d = Math.sin(y);\n    var e = Math.cos(z),\n        f = Math.sin(z);\n\n    if (euler.order === 'XYZ') {\n      var ae = a * e,\n          af = a * f,\n          be = b * e,\n          bf = b * f;\n      te[0] = c * e;\n      te[4] = -c * f;\n      te[8] = d;\n      te[1] = af + be * d;\n      te[5] = ae - bf * d;\n      te[9] = -b * c;\n      te[2] = bf - ae * d;\n      te[6] = be + af * d;\n      te[10] = a * c;\n    } else if (euler.order === 'YXZ') {\n      var ce = c * e,\n          cf = c * f,\n          de = d * e,\n          df = d * f;\n      te[0] = ce + df * b;\n      te[4] = de * b - cf;\n      te[8] = a * d;\n      te[1] = a * f;\n      te[5] = a * e;\n      te[9] = -b;\n      te[2] = cf * b - de;\n      te[6] = df + ce * b;\n      te[10] = a * c;\n    } else if (euler.order === 'ZXY') {\n      var ce = c * e,\n          cf = c * f,\n          de = d * e,\n          df = d * f;\n      te[0] = ce - df * b;\n      te[4] = -a * f;\n      te[8] = de + cf * b;\n      te[1] = cf + de * b;\n      te[5] = a * e;\n      te[9] = df - ce * b;\n      te[2] = -a * d;\n      te[6] = b;\n      te[10] = a * c;\n    } else if (euler.order === 'ZYX') {\n      var ae = a * e,\n          af = a * f,\n          be = b * e,\n          bf = b * f;\n      te[0] = c * e;\n      te[4] = be * d - af;\n      te[8] = ae * d + bf;\n      te[1] = c * f;\n      te[5] = bf * d + ae;\n      te[9] = af * d - be;\n      te[2] = -d;\n      te[6] = b * c;\n      te[10] = a * c;\n    } else if (euler.order === 'YZX') {\n      var ac = a * c,\n          ad = a * d,\n          bc = b * c,\n          bd = b * d;\n      te[0] = c * e;\n      te[4] = bd - ac * f;\n      te[8] = bc * f + ad;\n      te[1] = f;\n      te[5] = a * e;\n      te[9] = -b * e;\n      te[2] = -d * e;\n      te[6] = ad * f + bc;\n      te[10] = ac - bd * f;\n    } else if (euler.order === 'XZY') {\n      var ac = a * c,\n          ad = a * d,\n          bc = b * c,\n          bd = b * d;\n      te[0] = c * e;\n      te[4] = -f;\n      te[8] = d * e;\n      te[1] = ac * f + bd;\n      te[5] = a * e;\n      te[9] = ad * f - bc;\n      te[2] = bc * f - ad;\n      te[6] = b * e;\n      te[10] = bd * f + ac;\n    } // last column\n\n\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0; // bottom row\n\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  },\n  setRotationFromQuaternion: function setRotationFromQuaternion(q) {\n    console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');\n    return this.makeRotationFromQuaternion(q);\n  },\n  makeRotationFromQuaternion: function makeRotationFromQuaternion(q) {\n    var te = this.elements;\n    var x = q.x,\n        y = q.y,\n        z = q.z,\n        w = q.w;\n    var x2 = x + x,\n        y2 = y + y,\n        z2 = z + z;\n    var xx = x * x2,\n        xy = x * y2,\n        xz = x * z2;\n    var yy = y * y2,\n        yz = y * z2,\n        zz = z * z2;\n    var wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n    te[0] = 1 - (yy + zz);\n    te[4] = xy - wz;\n    te[8] = xz + wy;\n    te[1] = xy + wz;\n    te[5] = 1 - (xx + zz);\n    te[9] = yz - wx;\n    te[2] = xz - wy;\n    te[6] = yz + wx;\n    te[10] = 1 - (xx + yy); // last column\n\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0; // bottom row\n\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  },\n  lookAt: function () {\n    var x, y, z;\n    return function (eye, target, up) {\n      if (x === undefined) x = new THREE.Vector3();\n      if (y === undefined) y = new THREE.Vector3();\n      if (z === undefined) z = new THREE.Vector3();\n      var te = this.elements;\n      z.subVectors(eye, target).normalize();\n\n      if (z.length() === 0) {\n        z.z = 1;\n      }\n\n      x.crossVectors(up, z).normalize();\n\n      if (x.length() === 0) {\n        z.x += 0.0001;\n        x.crossVectors(up, z).normalize();\n      }\n\n      y.crossVectors(z, x);\n      te[0] = x.x;\n      te[4] = y.x;\n      te[8] = z.x;\n      te[1] = x.y;\n      te[5] = y.y;\n      te[9] = z.y;\n      te[2] = x.z;\n      te[6] = y.z;\n      te[10] = z.z;\n      return this;\n    };\n  }(),\n  multiply: function multiply(m, n) {\n    if (n !== undefined) {\n      console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');\n      return this.multiplyMatrices(m, n);\n    }\n\n    return this.multiplyMatrices(this, m);\n  },\n  multiplyMatrices: function multiplyMatrices(a, b) {\n    var ae = a.elements;\n    var be = b.elements;\n    var te = this.elements;\n    var a11 = ae[0],\n        a12 = ae[4],\n        a13 = ae[8],\n        a14 = ae[12];\n    var a21 = ae[1],\n        a22 = ae[5],\n        a23 = ae[9],\n        a24 = ae[13];\n    var a31 = ae[2],\n        a32 = ae[6],\n        a33 = ae[10],\n        a34 = ae[14];\n    var a41 = ae[3],\n        a42 = ae[7],\n        a43 = ae[11],\n        a44 = ae[15];\n    var b11 = be[0],\n        b12 = be[4],\n        b13 = be[8],\n        b14 = be[12];\n    var b21 = be[1],\n        b22 = be[5],\n        b23 = be[9],\n        b24 = be[13];\n    var b31 = be[2],\n        b32 = be[6],\n        b33 = be[10],\n        b34 = be[14];\n    var b41 = be[3],\n        b42 = be[7],\n        b43 = be[11],\n        b44 = be[15];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n    return this;\n  },\n  multiplyToArray: function multiplyToArray(a, b, r) {\n    var te = this.elements;\n    this.multiplyMatrices(a, b);\n    r[0] = te[0];\n    r[1] = te[1];\n    r[2] = te[2];\n    r[3] = te[3];\n    r[4] = te[4];\n    r[5] = te[5];\n    r[6] = te[6];\n    r[7] = te[7];\n    r[8] = te[8];\n    r[9] = te[9];\n    r[10] = te[10];\n    r[11] = te[11];\n    r[12] = te[12];\n    r[13] = te[13];\n    r[14] = te[14];\n    r[15] = te[15];\n    return this;\n  },\n  multiplyScalar: function multiplyScalar(s) {\n    var te = this.elements;\n    te[0] *= s;\n    te[4] *= s;\n    te[8] *= s;\n    te[12] *= s;\n    te[1] *= s;\n    te[5] *= s;\n    te[9] *= s;\n    te[13] *= s;\n    te[2] *= s;\n    te[6] *= s;\n    te[10] *= s;\n    te[14] *= s;\n    te[3] *= s;\n    te[7] *= s;\n    te[11] *= s;\n    te[15] *= s;\n    return this;\n  },\n  multiplyVector3: function multiplyVector3(vector) {\n    console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');\n    return vector.applyProjection(this);\n  },\n  multiplyVector4: function multiplyVector4(vector) {\n    console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n    return vector.applyMatrix4(this);\n  },\n  multiplyVector3Array: function multiplyVector3Array(a) {\n    console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');\n    return this.applyToVector3Array(a);\n  },\n  applyToVector3Array: function () {\n    var v1;\n    return function (array, offset, length) {\n      if (v1 === undefined) v1 = new THREE.Vector3();\n      if (offset === undefined) offset = 0;\n      if (length === undefined) length = array.length;\n\n      for (var i = 0, j = offset; i < length; i += 3, j += 3) {\n        v1.fromArray(array, j);\n        v1.applyMatrix4(this);\n        v1.toArray(array, j);\n      }\n\n      return array;\n    };\n  }(),\n  applyToBuffer: function () {\n    var v1;\n    return function applyToBuffer(buffer, offset, length) {\n      if (v1 === undefined) v1 = new THREE.Vector3();\n      if (offset === undefined) offset = 0;\n      if (length === undefined) length = buffer.length / buffer.itemSize;\n\n      for (var i = 0, j = offset; i < length; i++, j++) {\n        v1.x = buffer.getX(j);\n        v1.y = buffer.getY(j);\n        v1.z = buffer.getZ(j);\n        v1.applyMatrix4(this);\n        buffer.setXYZ(v1.x, v1.y, v1.z);\n      }\n\n      return buffer;\n    };\n  }(),\n  rotateAxis: function rotateAxis(v) {\n    console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');\n    v.transformDirection(this);\n  },\n  crossVector: function crossVector(vector) {\n    console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n    return vector.applyMatrix4(this);\n  },\n  determinant: function determinant() {\n    var te = this.elements;\n    var n11 = te[0],\n        n12 = te[4],\n        n13 = te[8],\n        n14 = te[12];\n    var n21 = te[1],\n        n22 = te[5],\n        n23 = te[9],\n        n24 = te[13];\n    var n31 = te[2],\n        n32 = te[6],\n        n33 = te[10],\n        n34 = te[14];\n    var n41 = te[3],\n        n42 = te[7],\n        n43 = te[11],\n        n44 = te[15]; //TODO: make this more efficient\n    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n  },\n  transpose: function transpose() {\n    var te = this.elements;\n    var tmp;\n    tmp = te[1];\n    te[1] = te[4];\n    te[4] = tmp;\n    tmp = te[2];\n    te[2] = te[8];\n    te[8] = tmp;\n    tmp = te[6];\n    te[6] = te[9];\n    te[9] = tmp;\n    tmp = te[3];\n    te[3] = te[12];\n    te[12] = tmp;\n    tmp = te[7];\n    te[7] = te[13];\n    te[13] = tmp;\n    tmp = te[11];\n    te[11] = te[14];\n    te[14] = tmp;\n    return this;\n  },\n  flattenToArrayOffset: function flattenToArrayOffset(array, offset) {\n    var te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    array[offset + 9] = te[9];\n    array[offset + 10] = te[10];\n    array[offset + 11] = te[11];\n    array[offset + 12] = te[12];\n    array[offset + 13] = te[13];\n    array[offset + 14] = te[14];\n    array[offset + 15] = te[15];\n    return array;\n  },\n  getPosition: function () {\n    var v1;\n    return function () {\n      if (v1 === undefined) v1 = new THREE.Vector3();\n      console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');\n      var te = this.elements;\n      return v1.set(te[12], te[13], te[14]);\n    };\n  }(),\n  setPosition: function setPosition(v) {\n    var te = this.elements;\n    te[12] = v.x;\n    te[13] = v.y;\n    te[14] = v.z;\n    return this;\n  },\n  getInverse: function getInverse(m, throwOnInvertible) {\n    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n    var te = this.elements;\n    var me = m.elements;\n    var n11 = me[0],\n        n12 = me[4],\n        n13 = me[8],\n        n14 = me[12];\n    var n21 = me[1],\n        n22 = me[5],\n        n23 = me[9],\n        n24 = me[13];\n    var n31 = me[2],\n        n32 = me[6],\n        n33 = me[10],\n        n34 = me[14];\n    var n41 = me[3],\n        n42 = me[7],\n        n43 = me[11],\n        n44 = me[15];\n    te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\n    te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\n    te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\n    te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n    te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\n    te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\n    te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\n    te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\n    te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\n    te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\n    te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\n    te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\n    te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\n    te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\n    te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\n    te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\n    var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];\n\n    if (det === 0) {\n      var msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n      if (throwOnInvertible || false) {\n        throw new Error(msg);\n      } else {\n        console.warn(msg);\n      }\n\n      this.identity();\n      return this;\n    }\n\n    this.multiplyScalar(1 / det);\n    return this;\n  },\n  translate: function translate(v) {\n    console.error('THREE.Matrix4: .translate() has been removed.');\n  },\n  rotateX: function rotateX(angle) {\n    console.error('THREE.Matrix4: .rotateX() has been removed.');\n  },\n  rotateY: function rotateY(angle) {\n    console.error('THREE.Matrix4: .rotateY() has been removed.');\n  },\n  rotateZ: function rotateZ(angle) {\n    console.error('THREE.Matrix4: .rotateZ() has been removed.');\n  },\n  rotateByAxis: function rotateByAxis(axis, angle) {\n    console.error('THREE.Matrix4: .rotateByAxis() has been removed.');\n  },\n  scale: function scale(v) {\n    var te = this.elements;\n    var x = v.x,\n        y = v.y,\n        z = v.z;\n    te[0] *= x;\n    te[4] *= y;\n    te[8] *= z;\n    te[1] *= x;\n    te[5] *= y;\n    te[9] *= z;\n    te[2] *= x;\n    te[6] *= y;\n    te[10] *= z;\n    te[3] *= x;\n    te[7] *= y;\n    te[11] *= z;\n    return this;\n  },\n  getMaxScaleOnAxis: function getMaxScaleOnAxis() {\n    var te = this.elements;\n    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n    return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));\n  },\n  makeTranslation: function makeTranslation(x, y, z) {\n    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n    return this;\n  },\n  makeRotationX: function makeRotationX(theta) {\n    var c = Math.cos(theta),\n        s = Math.sin(theta);\n    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n    return this;\n  },\n  makeRotationY: function makeRotationY(theta) {\n    var c = Math.cos(theta),\n        s = Math.sin(theta);\n    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n    return this;\n  },\n  makeRotationZ: function makeRotationZ(theta) {\n    var c = Math.cos(theta),\n        s = Math.sin(theta);\n    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  },\n  makeRotationAxis: function makeRotationAxis(axis, angle) {\n    // Based on http://www.gamedev.net/reference/articles/article1199.asp\n    var c = Math.cos(angle);\n    var s = Math.sin(angle);\n    var t = 1 - c;\n    var x = axis.x,\n        y = axis.y,\n        z = axis.z;\n    var tx = t * x,\n        ty = t * y;\n    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\n    return this;\n  },\n  makeScale: function makeScale(x, y, z) {\n    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n    return this;\n  },\n  compose: function compose(position, quaternion, scale) {\n    this.makeRotationFromQuaternion(quaternion);\n    this.scale(scale);\n    this.setPosition(position);\n    return this;\n  },\n  decompose: function () {\n    var vector, matrix;\n    return function (position, quaternion, scale) {\n      if (vector === undefined) vector = new THREE.Vector3();\n      if (matrix === undefined) matrix = new THREE.Matrix4();\n      var te = this.elements;\n      var sx = vector.set(te[0], te[1], te[2]).length();\n      var sy = vector.set(te[4], te[5], te[6]).length();\n      var sz = vector.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale\n\n      var det = this.determinant();\n\n      if (det < 0) {\n        sx = -sx;\n      }\n\n      position.x = te[12];\n      position.y = te[13];\n      position.z = te[14]; // scale the rotation part\n\n      matrix.elements.set(this.elements); // at this point matrix is incomplete so we can't use .copy()\n\n      var invSX = 1 / sx;\n      var invSY = 1 / sy;\n      var invSZ = 1 / sz;\n      matrix.elements[0] *= invSX;\n      matrix.elements[1] *= invSX;\n      matrix.elements[2] *= invSX;\n      matrix.elements[4] *= invSY;\n      matrix.elements[5] *= invSY;\n      matrix.elements[6] *= invSY;\n      matrix.elements[8] *= invSZ;\n      matrix.elements[9] *= invSZ;\n      matrix.elements[10] *= invSZ;\n      quaternion.setFromRotationMatrix(matrix);\n      scale.x = sx;\n      scale.y = sy;\n      scale.z = sz;\n      return this;\n    };\n  }(),\n  makeFrustum: function makeFrustum(left, right, bottom, top, near, far) {\n    var te = this.elements;\n    var x = 2 * near / (right - left);\n    var y = 2 * near / (top - bottom);\n    var a = (right + left) / (right - left);\n    var b = (top + bottom) / (top - bottom);\n    var c = -(far + near) / (far - near);\n    var d = -2 * far * near / (far - near);\n    te[0] = x;\n    te[4] = 0;\n    te[8] = a;\n    te[12] = 0;\n    te[1] = 0;\n    te[5] = y;\n    te[9] = b;\n    te[13] = 0;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = c;\n    te[14] = d;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = -1;\n    te[15] = 0;\n    return this;\n  },\n  makePerspective: function makePerspective(fov, aspect, near, far) {\n    var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));\n    var ymin = -ymax;\n    var xmin = ymin * aspect;\n    var xmax = ymax * aspect;\n    return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);\n  },\n  makeOrthographic: function makeOrthographic(left, right, top, bottom, near, far) {\n    var te = this.elements;\n    var w = right - left;\n    var h = top - bottom;\n    var p = far - near;\n    var x = (right + left) / w;\n    var y = (top + bottom) / h;\n    var z = (far + near) / p;\n    te[0] = 2 / w;\n    te[4] = 0;\n    te[8] = 0;\n    te[12] = -x;\n    te[1] = 0;\n    te[5] = 2 / h;\n    te[9] = 0;\n    te[13] = -y;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = -2 / p;\n    te[14] = -z;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[15] = 1;\n    return this;\n  },\n  equals: function equals(matrix) {\n    var te = this.elements;\n    var me = matrix.elements;\n\n    for (var i = 0; i < 16; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n\n    return true;\n  },\n  fromArray: function fromArray(array) {\n    this.elements.set(array);\n    return this;\n  },\n  toArray: function toArray() {\n    var te = this.elements;\n    return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8], te[9], te[10], te[11], te[12], te[13], te[14], te[15]];\n  }\n}; // File:src/math/Ray.js\n\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\n\nTHREE.Ray = function (origin, direction) {\n  this.origin = origin !== undefined ? origin : new THREE.Vector3();\n  this.direction = direction !== undefined ? direction : new THREE.Vector3();\n};\n\nTHREE.Ray.prototype = {\n  constructor: THREE.Ray,\n  set: function set(origin, direction) {\n    this.origin.copy(origin);\n    this.direction.copy(direction);\n    return this;\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(ray) {\n    this.origin.copy(ray.origin);\n    this.direction.copy(ray.direction);\n    return this;\n  },\n  at: function at(t, optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    return result.copy(this.direction).multiplyScalar(t).add(this.origin);\n  },\n  recast: function () {\n    var v1 = new THREE.Vector3();\n    return function (t) {\n      this.origin.copy(this.at(t, v1));\n      return this;\n    };\n  }(),\n  closestPointToPoint: function closestPointToPoint(point, optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    result.subVectors(point, this.origin);\n    var directionDistance = result.dot(this.direction);\n\n    if (directionDistance < 0) {\n      return result.copy(this.origin);\n    }\n\n    return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n  },\n  distanceToPoint: function distanceToPoint(point) {\n    return Math.sqrt(this.distanceSqToPoint(point));\n  },\n  distanceSqToPoint: function () {\n    var v1 = new THREE.Vector3();\n    return function (point) {\n      var directionDistance = v1.subVectors(point, this.origin).dot(this.direction); // point behind the ray\n\n      if (directionDistance < 0) {\n        return this.origin.distanceToSquared(point);\n      }\n\n      v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n      return v1.distanceToSquared(point);\n    };\n  }(),\n  distanceSqToSegment: function () {\n    var segCenter = new THREE.Vector3();\n    var segDir = new THREE.Vector3();\n    var diff = new THREE.Vector3();\n    return function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n      // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\n      // It returns the min distance between the ray and the segment\n      // defined by v0 and v1\n      // It can also set two optional targets :\n      // - The closest point on the ray\n      // - The closest point on the segment\n      segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n      segDir.copy(v1).sub(v0).normalize();\n      diff.copy(this.origin).sub(segCenter);\n      var segExtent = v0.distanceTo(v1) * 0.5;\n      var a01 = -this.direction.dot(segDir);\n      var b0 = diff.dot(this.direction);\n      var b1 = -diff.dot(segDir);\n      var c = diff.lengthSq();\n      var det = Math.abs(1 - a01 * a01);\n      var s0, s1, sqrDist, extDet;\n\n      if (det > 0) {\n        // The ray and segment are not parallel.\n        s0 = a01 * b1 - b0;\n        s1 = a01 * b0 - b1;\n        extDet = segExtent * det;\n\n        if (s0 >= 0) {\n          if (s1 >= -extDet) {\n            if (s1 <= extDet) {\n              // region 0\n              // Minimum at interior points of ray and segment.\n              var invDet = 1 / det;\n              s0 *= invDet;\n              s1 *= invDet;\n              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n            } else {\n              // region 1\n              s1 = segExtent;\n              s0 = Math.max(0, -(a01 * s1 + b0));\n              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n            }\n          } else {\n            // region 5\n            s1 = -segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          if (s1 <= -extDet) {\n            // region 4\n            s0 = Math.max(0, -(-a01 * segExtent + b0));\n            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          } else if (s1 <= extDet) {\n            // region 3\n            s0 = 0;\n            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = s1 * (s1 + 2 * b1) + c;\n          } else {\n            // region 2\n            s0 = Math.max(0, -(a01 * segExtent + b0));\n            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        }\n      } else {\n        // Ray and segment are parallel.\n        s1 = a01 > 0 ? -segExtent : segExtent;\n        s0 = Math.max(0, -(a01 * s1 + b0));\n        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n      }\n\n      if (optionalPointOnRay) {\n        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\n      }\n\n      if (optionalPointOnSegment) {\n        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);\n      }\n\n      return sqrDist;\n    };\n  }(),\n  isIntersectionSphere: function isIntersectionSphere(sphere) {\n    return this.distanceToPoint(sphere.center) <= sphere.radius;\n  },\n  intersectSphere: function () {\n    // from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\n    var v1 = new THREE.Vector3();\n    return function (sphere, optionalTarget) {\n      v1.subVectors(sphere.center, this.origin);\n      var tca = v1.dot(this.direction);\n      var d2 = v1.dot(v1) - tca * tca;\n      var radius2 = sphere.radius * sphere.radius;\n      if (d2 > radius2) return null;\n      var thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere\n\n      var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere\n\n      var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null\n\n      if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:\n      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n      // in order to always return an intersect point that is in front of the ray.\n\n      if (t0 < 0) return this.at(t1, optionalTarget); // else t0 is in front of the ray, so return the first collision point scaled by t0\n\n      return this.at(t0, optionalTarget);\n    };\n  }(),\n  isIntersectionPlane: function isIntersectionPlane(plane) {\n    // check if the ray lies on the plane first\n    var distToPoint = plane.distanceToPoint(this.origin);\n\n    if (distToPoint === 0) {\n      return true;\n    }\n\n    var denominator = plane.normal.dot(this.direction);\n\n    if (denominator * distToPoint < 0) {\n      return true;\n    } // ray origin is behind the plane (and is pointing behind it)\n\n\n    return false;\n  },\n  distanceToPlane: function distanceToPlane(plane) {\n    var denominator = plane.normal.dot(this.direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (plane.distanceToPoint(this.origin) === 0) {\n        return 0;\n      } // Null is preferable to undefined since undefined means.... it is undefined\n\n\n      return null;\n    }\n\n    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane\n\n    return t >= 0 ? t : null;\n  },\n  intersectPlane: function intersectPlane(plane, optionalTarget) {\n    var t = this.distanceToPlane(plane);\n\n    if (t === null) {\n      return null;\n    }\n\n    return this.at(t, optionalTarget);\n  },\n  isIntersectionBox: function () {\n    var v = new THREE.Vector3();\n    return function (box) {\n      return this.intersectBox(box, v) !== null;\n    };\n  }(),\n  intersectBox: function intersectBox(box, optionalTarget) {\n    // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\n    var tmin, tmax, tymin, tymax, tzmin, tzmax;\n    var invdirx = 1 / this.direction.x,\n        invdiry = 1 / this.direction.y,\n        invdirz = 1 / this.direction.z;\n    var origin = this.origin;\n\n    if (invdirx >= 0) {\n      tmin = (box.min.x - origin.x) * invdirx;\n      tmax = (box.max.x - origin.x) * invdirx;\n    } else {\n      tmin = (box.max.x - origin.x) * invdirx;\n      tmax = (box.min.x - origin.x) * invdirx;\n    }\n\n    if (invdiry >= 0) {\n      tymin = (box.min.y - origin.y) * invdiry;\n      tymax = (box.max.y - origin.y) * invdiry;\n    } else {\n      tymin = (box.max.y - origin.y) * invdiry;\n      tymax = (box.min.y - origin.y) * invdiry;\n    }\n\n    if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN\n    // (result of 0 * Infinity). x !== x returns true if x is NaN\n\n    if (tymin > tmin || tmin !== tmin) tmin = tymin;\n    if (tymax < tmax || tmax !== tmax) tmax = tymax;\n\n    if (invdirz >= 0) {\n      tzmin = (box.min.z - origin.z) * invdirz;\n      tzmax = (box.max.z - origin.z) * invdirz;\n    } else {\n      tzmin = (box.max.z - origin.z) * invdirz;\n      tzmax = (box.min.z - origin.z) * invdirz;\n    }\n\n    if (tmin > tzmax || tzmin > tmax) return null;\n    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n    if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)\n\n    if (tmax < 0) return null;\n    return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);\n  },\n  intersectTriangle: function () {\n    // Compute the offset origin, edges, and normal.\n    var diff = new THREE.Vector3();\n    var edge1 = new THREE.Vector3();\n    var edge2 = new THREE.Vector3();\n    var normal = new THREE.Vector3();\n    return function (a, b, c, backfaceCulling, optionalTarget) {\n      // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\n      edge1.subVectors(b, a);\n      edge2.subVectors(c, a);\n      normal.crossVectors(edge1, edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\n      var DdN = this.direction.dot(normal);\n      var sign;\n\n      if (DdN > 0) {\n        if (backfaceCulling) return null;\n        sign = 1;\n      } else if (DdN < 0) {\n        sign = -1;\n        DdN = -DdN;\n      } else {\n        return null;\n      }\n\n      diff.subVectors(this.origin, a);\n      var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2)); // b1 < 0, no intersection\n\n      if (DdQxE2 < 0) {\n        return null;\n      }\n\n      var DdE1xQ = sign * this.direction.dot(edge1.cross(diff)); // b2 < 0, no intersection\n\n      if (DdE1xQ < 0) {\n        return null;\n      } // b1+b2 > 1, no intersection\n\n\n      if (DdQxE2 + DdE1xQ > DdN) {\n        return null;\n      } // Line intersects triangle, check if ray does.\n\n\n      var QdN = -sign * diff.dot(normal); // t < 0, no intersection\n\n      if (QdN < 0) {\n        return null;\n      } // Ray intersects triangle.\n\n\n      return this.at(QdN / DdN, optionalTarget);\n    };\n  }(),\n  applyMatrix4: function applyMatrix4(matrix4) {\n    this.direction.add(this.origin).applyMatrix4(matrix4);\n    this.origin.applyMatrix4(matrix4);\n    this.direction.sub(this.origin);\n    this.direction.normalize();\n    return this;\n  },\n  equals: function equals(ray) {\n    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n  }\n}; // File:src/math/Sphere.js\n\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.Sphere = function (center, radius) {\n  this.center = center !== undefined ? center : new THREE.Vector3();\n  this.radius = radius !== undefined ? radius : 0;\n};\n\nTHREE.Sphere.prototype = {\n  constructor: THREE.Sphere,\n  set: function set(center, radius) {\n    this.center.copy(center);\n    this.radius = radius;\n    return this;\n  },\n  setFromPoints: function () {\n    var box = new THREE.Box3();\n    return function (points, optionalCenter) {\n      var center = this.center;\n\n      if (optionalCenter !== undefined) {\n        center.copy(optionalCenter);\n      } else {\n        box.setFromPoints(points).center(center);\n      }\n\n      var maxRadiusSq = 0;\n\n      for (var i = 0, il = points.length; i < il; i++) {\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n      }\n\n      this.radius = Math.sqrt(maxRadiusSq);\n      return this;\n    };\n  }(),\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(sphere) {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n    return this;\n  },\n  empty: function empty() {\n    return this.radius <= 0;\n  },\n  containsPoint: function containsPoint(point) {\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n  },\n  distanceToPoint: function distanceToPoint(point) {\n    return point.distanceTo(this.center) - this.radius;\n  },\n  intersectsSphere: function intersectsSphere(sphere) {\n    var radiusSum = this.radius + sphere.radius;\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  },\n  clampPoint: function clampPoint(point, optionalTarget) {\n    var deltaLengthSq = this.center.distanceToSquared(point);\n    var result = optionalTarget || new THREE.Vector3();\n    result.copy(point);\n\n    if (deltaLengthSq > this.radius * this.radius) {\n      result.sub(this.center).normalize();\n      result.multiplyScalar(this.radius).add(this.center);\n    }\n\n    return result;\n  },\n  getBoundingBox: function getBoundingBox(optionalTarget) {\n    var box = optionalTarget || new THREE.Box3();\n    box.set(this.center, this.center);\n    box.expandByScalar(this.radius);\n    return box;\n  },\n  applyMatrix4: function applyMatrix4(matrix) {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  },\n  translate: function translate(offset) {\n    this.center.add(offset);\n    return this;\n  },\n  equals: function equals(sphere) {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n}; // File:src/math/Frustum.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://exocortex.com\r\n */\n\nTHREE.Frustum = function (p0, p1, p2, p3, p4, p5) {\n  this.planes = [p0 !== undefined ? p0 : new THREE.Plane(), p1 !== undefined ? p1 : new THREE.Plane(), p2 !== undefined ? p2 : new THREE.Plane(), p3 !== undefined ? p3 : new THREE.Plane(), p4 !== undefined ? p4 : new THREE.Plane(), p5 !== undefined ? p5 : new THREE.Plane()];\n};\n\nTHREE.Frustum.prototype = {\n  constructor: THREE.Frustum,\n  set: function set(p0, p1, p2, p3, p4, p5) {\n    var planes = this.planes;\n    planes[0].copy(p0);\n    planes[1].copy(p1);\n    planes[2].copy(p2);\n    planes[3].copy(p3);\n    planes[4].copy(p4);\n    planes[5].copy(p5);\n    return this;\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(frustum) {\n    var planes = this.planes;\n\n    for (var i = 0; i < 6; i++) {\n      planes[i].copy(frustum.planes[i]);\n    }\n\n    return this;\n  },\n  setFromMatrix: function setFromMatrix(m) {\n    var planes = this.planes;\n    var me = m.elements;\n    var me0 = me[0],\n        me1 = me[1],\n        me2 = me[2],\n        me3 = me[3];\n    var me4 = me[4],\n        me5 = me[5],\n        me6 = me[6],\n        me7 = me[7];\n    var me8 = me[8],\n        me9 = me[9],\n        me10 = me[10],\n        me11 = me[11];\n    var me12 = me[12],\n        me13 = me[13],\n        me14 = me[14],\n        me15 = me[15];\n    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n    return this;\n  },\n  intersectsObject: function () {\n    var sphere = new THREE.Sphere();\n    return function (object) {\n      var geometry = object.geometry;\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n      sphere.copy(geometry.boundingSphere);\n      sphere.applyMatrix4(object.matrixWorld);\n      return this.intersectsSphere(sphere);\n    };\n  }(),\n  intersectsSphere: function intersectsSphere(sphere) {\n    var planes = this.planes;\n    var center = sphere.center;\n    var negRadius = -sphere.radius;\n\n    for (var i = 0; i < 6; i++) {\n      var distance = planes[i].distanceToPoint(center);\n\n      if (distance < negRadius) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  intersectsBox: function () {\n    var p1 = new THREE.Vector3(),\n        p2 = new THREE.Vector3();\n    return function (box) {\n      var planes = this.planes;\n\n      for (var i = 0; i < 6; i++) {\n        var plane = planes[i];\n        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n        var d1 = plane.distanceToPoint(p1);\n        var d2 = plane.distanceToPoint(p2); // if both outside plane, no intersection\n\n        if (d1 < 0 && d2 < 0) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  }(),\n  containsPoint: function containsPoint(point) {\n    var planes = this.planes;\n\n    for (var i = 0; i < 6; i++) {\n      if (planes[i].distanceToPoint(point) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}; // File:src/math/Plane.js\n\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\n\nTHREE.Plane = function (normal, constant) {\n  this.normal = normal !== undefined ? normal : new THREE.Vector3(1, 0, 0);\n  this.constant = constant !== undefined ? constant : 0;\n};\n\nTHREE.Plane.prototype = {\n  constructor: THREE.Plane,\n  set: function set(normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n    return this;\n  },\n  setComponents: function setComponents(x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n    return this;\n  },\n  setFromNormalAndCoplanarPoint: function setFromNormalAndCoplanarPoint(normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal); // must be this.normal, not normal, as this.normal is normalized\n\n    return this;\n  },\n  setFromCoplanarPoints: function () {\n    var v1 = new THREE.Vector3();\n    var v2 = new THREE.Vector3();\n    return function (a, b, c) {\n      var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n      this.setFromNormalAndCoplanarPoint(normal, a);\n      return this;\n    };\n  }(),\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n    return this;\n  },\n  normalize: function normalize() {\n    // Note: will lead to a divide by zero if the plane is invalid.\n    var inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n    return this;\n  },\n  negate: function negate() {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  },\n  distanceToPoint: function distanceToPoint(point) {\n    return this.normal.dot(point) + this.constant;\n  },\n  distanceToSphere: function distanceToSphere(sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  },\n  projectPoint: function projectPoint(point, optionalTarget) {\n    return this.orthoPoint(point, optionalTarget).sub(point).negate();\n  },\n  orthoPoint: function orthoPoint(point, optionalTarget) {\n    var perpendicularMagnitude = this.distanceToPoint(point);\n    var result = optionalTarget || new THREE.Vector3();\n    return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);\n  },\n  isIntersectionLine: function isIntersectionLine(line) {\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n    var startSign = this.distanceToPoint(line.start);\n    var endSign = this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n  },\n  intersectLine: function () {\n    var v1 = new THREE.Vector3();\n    return function (line, optionalTarget) {\n      var result = optionalTarget || new THREE.Vector3();\n      var direction = line.delta(v1);\n      var denominator = this.normal.dot(direction);\n\n      if (denominator === 0) {\n        // line is coplanar, return origin\n        if (this.distanceToPoint(line.start) === 0) {\n          return result.copy(line.start);\n        } // Unsure if this is the correct method to handle this case.\n\n\n        return undefined;\n      }\n\n      var t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n      if (t < 0 || t > 1) {\n        return undefined;\n      }\n\n      return result.copy(direction).multiplyScalar(t).add(line.start);\n    };\n  }(),\n  coplanarPoint: function coplanarPoint(optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    return result.copy(this.normal).multiplyScalar(-this.constant);\n  },\n  applyMatrix4: function () {\n    var v1 = new THREE.Vector3();\n    var v2 = new THREE.Vector3();\n    var m1 = new THREE.Matrix3();\n    return function (matrix, optionalNormalMatrix) {\n      // compute new normal based on theory here:\n      // http://www.songho.ca/opengl/gl_normaltransform.html\n      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);\n      var newNormal = v1.copy(this.normal).applyMatrix3(normalMatrix);\n      var newCoplanarPoint = this.coplanarPoint(v2);\n      newCoplanarPoint.applyMatrix4(matrix);\n      this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);\n      return this;\n    };\n  }(),\n  translate: function translate(offset) {\n    this.constant = this.constant - offset.dot(this.normal);\n    return this;\n  },\n  equals: function equals(plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n}; // File:src/math/Math.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.Math = {\n  generateUUID: function () {\n    // http://www.broofa.com/Tools/Math.uuid.htm\n    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n    var uuid = new Array(36);\n    var rnd = 0,\n        r;\n    return function () {\n      for (var i = 0; i < 36; i++) {\n        if (i === 8 || i === 13 || i === 18 || i === 23) {\n          uuid[i] = '-';\n        } else if (i === 14) {\n          uuid[i] = '4';\n        } else {\n          if (rnd <= 0x02) rnd = 0x2000000 + Math.random() * 0x1000000 | 0;\n          r = rnd & 0xf;\n          rnd = rnd >> 4;\n          uuid[i] = chars[i === 19 ? r & 0x3 | 0x8 : r];\n        }\n      }\n\n      return uuid.join('');\n    };\n  }(),\n  // Clamp value to range <a, b>\n  clamp: function clamp(x, a, b) {\n    return x < a ? a : x > b ? b : x;\n  },\n  // Clamp value to range <a, inf)\n  clampBottom: function clampBottom(x, a) {\n    return x < a ? a : x;\n  },\n  // compute euclidian modulo of m % n\n  // https://en.wikipedia.org/wiki/Modulo_operation\n  euclideanModulo: function euclideanModulo(n, m) {\n    return (n % m + m) % m;\n  },\n  // Linear mapping from range <a1, a2> to range <b1, b2>\n  mapLinear: function mapLinear(x, a1, a2, b1, b2) {\n    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n  },\n  // http://en.wikipedia.org/wiki/Smoothstep\n  smoothstep: function smoothstep(x, min, max) {\n    if (x <= min) return 0;\n    if (x >= max) return 1;\n    x = (x - min) / (max - min);\n    return x * x * (3 - 2 * x);\n  },\n  smootherstep: function smootherstep(x, min, max) {\n    if (x <= min) return 0;\n    if (x >= max) return 1;\n    x = (x - min) / (max - min);\n    return x * x * x * (x * (x * 6 - 15) + 10);\n  },\n  // Random float from <0, 1> with 16 bits of randomness\n  // (standard Math.random() creates repetitive patterns when applied over larger space)\n  random16: function random16() {\n    return (65280 * Math.random() + 255 * Math.random()) / 65535;\n  },\n  // Random integer from <low, high> interval\n  randInt: function randInt(low, high) {\n    return low + Math.floor(Math.random() * (high - low + 1));\n  },\n  // Random float from <low, high> interval\n  randFloat: function randFloat(low, high) {\n    return low + Math.random() * (high - low);\n  },\n  // Random float from <-range/2, range/2> interval\n  randFloatSpread: function randFloatSpread(range) {\n    return range * (0.5 - Math.random());\n  },\n  degToRad: function () {\n    var degreeToRadiansFactor = Math.PI / 180;\n    return function (degrees) {\n      return degrees * degreeToRadiansFactor;\n    };\n  }(),\n  radToDeg: function () {\n    var radianToDegreesFactor = 180 / Math.PI;\n    return function (radians) {\n      return radians * radianToDegreesFactor;\n    };\n  }(),\n  isPowerOfTwo: function isPowerOfTwo(value) {\n    return (value & value - 1) === 0 && value !== 0;\n  },\n  nextPowerOfTwo: function nextPowerOfTwo(value) {\n    value--;\n    value |= value >> 1;\n    value |= value >> 2;\n    value |= value >> 4;\n    value |= value >> 8;\n    value |= value >> 16;\n    value++;\n    return value;\n  }\n}; // File:src/math/Spline.js\n\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.Spline = function (points) {\n  this.points = points;\n  var c = [],\n      v3 = {\n    x: 0,\n    y: 0,\n    z: 0\n  },\n      point,\n      intPoint,\n      weight,\n      w2,\n      w3,\n      pa,\n      pb,\n      pc,\n      pd;\n\n  this.initFromArray = function (a) {\n    this.points = [];\n\n    for (var i = 0; i < a.length; i++) {\n      this.points[i] = {\n        x: a[i][0],\n        y: a[i][1],\n        z: a[i][2]\n      };\n    }\n  };\n\n  this.getPoint = function (k) {\n    point = (this.points.length - 1) * k;\n    intPoint = Math.floor(point);\n    weight = point - intPoint;\n    c[0] = intPoint === 0 ? intPoint : intPoint - 1;\n    c[1] = intPoint;\n    c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n    c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n    pa = this.points[c[0]];\n    pb = this.points[c[1]];\n    pc = this.points[c[2]];\n    pd = this.points[c[3]];\n    w2 = weight * weight;\n    w3 = weight * w2;\n    v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);\n    v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);\n    v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);\n    return v3;\n  };\n\n  this.getControlPointsArray = function () {\n    var i,\n        p,\n        l = this.points.length,\n        coords = [];\n\n    for (i = 0; i < l; i++) {\n      p = this.points[i];\n      coords[i] = [p.x, p.y, p.z];\n    }\n\n    return coords;\n  }; // approximate length by summing linear segments\n\n\n  this.getLength = function (nSubDivisions) {\n    var i,\n        index,\n        nSamples,\n        position,\n        point = 0,\n        intPoint = 0,\n        oldIntPoint = 0,\n        oldPosition = new THREE.Vector3(),\n        tmpVec = new THREE.Vector3(),\n        chunkLengths = [],\n        totalLength = 0; // first point has 0 length\n\n    chunkLengths[0] = 0;\n    if (!nSubDivisions) nSubDivisions = 100;\n    nSamples = this.points.length * nSubDivisions;\n    oldPosition.copy(this.points[0]);\n\n    for (i = 1; i < nSamples; i++) {\n      index = i / nSamples;\n      position = this.getPoint(index);\n      tmpVec.copy(position);\n      totalLength += tmpVec.distanceTo(oldPosition);\n      oldPosition.copy(position);\n      point = (this.points.length - 1) * index;\n      intPoint = Math.floor(point);\n\n      if (intPoint !== oldIntPoint) {\n        chunkLengths[intPoint] = totalLength;\n        oldIntPoint = intPoint;\n      }\n    } // last point ends with total length\n\n\n    chunkLengths[chunkLengths.length] = totalLength;\n    return {\n      chunks: chunkLengths,\n      total: totalLength\n    };\n  };\n\n  this.reparametrizeByArcLength = function (samplingCoef) {\n    var i,\n        j,\n        index,\n        indexCurrent,\n        indexNext,\n        realDistance,\n        sampling,\n        position,\n        newpoints = [],\n        tmpVec = new THREE.Vector3(),\n        sl = this.getLength();\n    newpoints.push(tmpVec.copy(this.points[0]).clone());\n\n    for (i = 1; i < this.points.length; i++) {\n      //tmpVec.copy( this.points[ i - 1 ] );\n      //linearDistance = tmpVec.distanceTo( this.points[ i ] );\n      realDistance = sl.chunks[i] - sl.chunks[i - 1];\n      sampling = Math.ceil(samplingCoef * realDistance / sl.total);\n      indexCurrent = (i - 1) / (this.points.length - 1);\n      indexNext = i / (this.points.length - 1);\n\n      for (j = 1; j < sampling - 1; j++) {\n        index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);\n        position = this.getPoint(index);\n        newpoints.push(tmpVec.copy(position).clone());\n      }\n\n      newpoints.push(tmpVec.copy(this.points[i]).clone());\n    }\n\n    this.points = newpoints;\n  }; // Catmull-Rom\n\n\n  function interpolate(p0, p1, p2, p3, t, t2, t3) {\n    var v0 = (p2 - p0) * 0.5,\n        v1 = (p3 - p1) * 0.5;\n    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n  }\n}; // File:src/math/Triangle.js\n\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.Triangle = function (a, b, c) {\n  this.a = a !== undefined ? a : new THREE.Vector3();\n  this.b = b !== undefined ? b : new THREE.Vector3();\n  this.c = c !== undefined ? c : new THREE.Vector3();\n};\n\nTHREE.Triangle.normal = function () {\n  var v0 = new THREE.Vector3();\n  return function (a, b, c, optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    result.subVectors(c, b);\n    v0.subVectors(a, b);\n    result.cross(v0);\n    var resultLengthSq = result.lengthSq();\n\n    if (resultLengthSq > 0) {\n      return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));\n    }\n\n    return result.set(0, 0, 0);\n  };\n}(); // static/instance method to calculate barycentric coordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\n\nTHREE.Triangle.barycoordFromPoint = function () {\n  var v0 = new THREE.Vector3();\n  var v1 = new THREE.Vector3();\n  var v2 = new THREE.Vector3();\n  return function (point, a, b, c, optionalTarget) {\n    v0.subVectors(c, a);\n    v1.subVectors(b, a);\n    v2.subVectors(point, a);\n    var dot00 = v0.dot(v0);\n    var dot01 = v0.dot(v1);\n    var dot02 = v0.dot(v2);\n    var dot11 = v1.dot(v1);\n    var dot12 = v1.dot(v2);\n    var denom = dot00 * dot11 - dot01 * dot01;\n    var result = optionalTarget || new THREE.Vector3(); // collinear or singular triangle\n\n    if (denom === 0) {\n      // arbitrary location outside of triangle?\n      // not sure if this is the best idea, maybe should be returning undefined\n      return result.set(-2, -1, -1);\n    }\n\n    var invDenom = 1 / denom;\n    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    var v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1\n\n    return result.set(1 - u - v, v, u);\n  };\n}();\n\nTHREE.Triangle.containsPoint = function () {\n  var v1 = new THREE.Vector3();\n  return function (point, a, b, c) {\n    var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);\n    return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;\n  };\n}();\n\nTHREE.Triangle.prototype = {\n  constructor: THREE.Triangle,\n  set: function set(a, b, c) {\n    this.a.copy(a);\n    this.b.copy(b);\n    this.c.copy(c);\n    return this;\n  },\n  setFromPointsAndIndices: function setFromPointsAndIndices(points, i0, i1, i2) {\n    this.a.copy(points[i0]);\n    this.b.copy(points[i1]);\n    this.c.copy(points[i2]);\n    return this;\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(triangle) {\n    this.a.copy(triangle.a);\n    this.b.copy(triangle.b);\n    this.c.copy(triangle.c);\n    return this;\n  },\n  area: function () {\n    var v0 = new THREE.Vector3();\n    var v1 = new THREE.Vector3();\n    return function () {\n      v0.subVectors(this.c, this.b);\n      v1.subVectors(this.a, this.b);\n      return v0.cross(v1).length() * 0.5;\n    };\n  }(),\n  midpoint: function midpoint(optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n  },\n  normal: function normal(optionalTarget) {\n    return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);\n  },\n  plane: function plane(optionalTarget) {\n    var result = optionalTarget || new THREE.Plane();\n    return result.setFromCoplanarPoints(this.a, this.b, this.c);\n  },\n  barycoordFromPoint: function barycoordFromPoint(point, optionalTarget) {\n    return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);\n  },\n  containsPoint: function containsPoint(point) {\n    return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);\n  },\n  equals: function equals(triangle) {\n    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n  }\n}; // File:src/core/Clock.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.Clock = function (autoStart) {\n  this.autoStart = autoStart !== undefined ? autoStart : true;\n  this.startTime = 0;\n  this.oldTime = 0;\n  this.elapsedTime = 0;\n  this.running = false;\n};\n\nTHREE.Clock.prototype = {\n  constructor: THREE.Clock,\n  start: function start() {\n    this.startTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();\n    this.oldTime = this.startTime;\n    this.running = true;\n  },\n  stop: function stop() {\n    this.getElapsedTime();\n    this.running = false;\n  },\n  getElapsedTime: function getElapsedTime() {\n    this.getDelta();\n    return this.elapsedTime;\n  },\n  getDelta: function getDelta() {\n    var diff = 0;\n\n    if (this.autoStart && !this.running) {\n      this.start();\n    }\n\n    if (this.running) {\n      var newTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();\n      diff = 0.001 * (newTime - this.oldTime);\n      this.oldTime = newTime;\n      this.elapsedTime += diff;\n    }\n\n    return diff;\n  }\n}; // File:src/core/EventDispatcher.js\n\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\n\nTHREE.EventDispatcher = function () {};\n\nTHREE.EventDispatcher.prototype = {\n  constructor: THREE.EventDispatcher,\n  apply: function apply(object) {\n    object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\n    object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\n    object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\n    object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\n  },\n  addEventListener: function addEventListener(type, listener) {\n    if (this._listeners === undefined) this._listeners = {};\n    var listeners = this._listeners;\n\n    if (listeners[type] === undefined) {\n      listeners[type] = [];\n    }\n\n    if (listeners[type].indexOf(listener) === -1) {\n      listeners[type].push(listener);\n    }\n  },\n  hasEventListener: function hasEventListener(type, listener) {\n    if (this._listeners === undefined) return false;\n    var listeners = this._listeners;\n\n    if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {\n      return true;\n    }\n\n    return false;\n  },\n  removeEventListener: function removeEventListener(type, listener) {\n    if (this._listeners === undefined) return;\n    var listeners = this._listeners;\n    var listenerArray = listeners[type];\n\n    if (listenerArray !== undefined) {\n      var index = listenerArray.indexOf(listener);\n\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n  },\n  dispatchEvent: function dispatchEvent(event) {\n    if (this._listeners === undefined) return;\n    var listeners = this._listeners;\n    var listenerArray = listeners[event.type];\n\n    if (listenerArray !== undefined) {\n      event.target = this;\n      var array = [];\n      var length = listenerArray.length;\n\n      for (var i = 0; i < length; i++) {\n        array[i] = listenerArray[i];\n      }\n\n      for (var i = 0; i < length; i++) {\n        array[i].call(this, event);\n      }\n    }\n  }\n}; // File:src/core/Raycaster.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://exocortex.com/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\n\n(function (THREE) {\n  THREE.Raycaster = function (origin, direction, near, far) {\n    this.ray = new THREE.Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)\n\n    this.near = near || 0;\n    this.far = far || Infinity;\n    this.params = {\n      Mesh: {},\n      Line: {},\n      LOD: {},\n      Points: {\n        threshold: 1\n      },\n      Sprite: {}\n    };\n    Object.defineProperties(this.params, {\n      PointCloud: {\n        get: function get() {\n          console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');\n          return this.Points;\n        }\n      }\n    });\n  };\n\n  function descSort(a, b) {\n    return a.distance - b.distance;\n  }\n\n  var _intersectObject = function intersectObject(object, raycaster, intersects, recursive) {\n    if (object.visible === false) return;\n    object.raycast(raycaster, intersects);\n\n    if (recursive === true) {\n      var children = object.children;\n\n      for (var i = 0, l = children.length; i < l; i++) {\n        _intersectObject(children[i], raycaster, intersects, true);\n      }\n    }\n  }; //\n\n\n  THREE.Raycaster.prototype = {\n    constructor: THREE.Raycaster,\n    linePrecision: 1,\n    set: function set(origin, direction) {\n      // direction is assumed to be normalized (for accurate distance calculations)\n      this.ray.set(origin, direction);\n    },\n    setFromCamera: function setFromCamera(coords, camera) {\n      if (camera instanceof THREE.PerspectiveCamera) {\n        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n      } else if (camera instanceof THREE.OrthographicCamera) {\n        this.ray.origin.set(coords.x, coords.y, -1).unproject(camera);\n        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n      } else {\n        console.error('THREE.Raycaster: Unsupported camera type.');\n      }\n    },\n    intersectObject: function intersectObject(object, recursive) {\n      var intersects = [];\n\n      _intersectObject(object, this, intersects, recursive);\n\n      intersects.sort(descSort);\n      return intersects;\n    },\n    intersectObjects: function intersectObjects(objects, recursive) {\n      var intersects = [];\n\n      if (Array.isArray(objects) === false) {\n        console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');\n        return intersects;\n      }\n\n      for (var i = 0, l = objects.length; i < l; i++) {\n        _intersectObject(objects[i], this, intersects, recursive);\n      }\n\n      intersects.sort(descSort);\n      return intersects;\n    }\n  };\n})(THREE); // File:src/core/Object3D.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author elephantatwork / www.elephantatwork.ch\r\n */\n\n\nTHREE.Object3D = function () {\n  Object.defineProperty(this, 'id', {\n    value: THREE.Object3DIdCount++\n  });\n  this.uuid = THREE.Math.generateUUID();\n  this.name = '';\n  this.type = 'Object3D';\n  this.parent = null;\n  this.children = [];\n  this.up = THREE.Object3D.DefaultUp.clone();\n  var position = new THREE.Vector3();\n  var rotation = new THREE.Euler();\n  var quaternion = new THREE.Quaternion();\n  var scale = new THREE.Vector3(1, 1, 1);\n\n  var onRotationChange = function onRotationChange() {\n    quaternion.setFromEuler(rotation, false);\n  };\n\n  var onQuaternionChange = function onQuaternionChange() {\n    rotation.setFromQuaternion(quaternion, undefined, false);\n  };\n\n  rotation.onChange(onRotationChange);\n  quaternion.onChange(onQuaternionChange);\n  Object.defineProperties(this, {\n    position: {\n      enumerable: true,\n      value: position\n    },\n    rotation: {\n      enumerable: true,\n      value: rotation\n    },\n    quaternion: {\n      enumerable: true,\n      value: quaternion\n    },\n    scale: {\n      enumerable: true,\n      value: scale\n    },\n    modelViewMatrix: {\n      value: new THREE.Matrix4()\n    },\n    normalMatrix: {\n      value: new THREE.Matrix3()\n    }\n  });\n  this.rotationAutoUpdate = true;\n  this.matrix = new THREE.Matrix4();\n  this.matrixWorld = new THREE.Matrix4();\n  this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\n  this.matrixWorldNeedsUpdate = false;\n  this.visible = true;\n  this.castShadow = false;\n  this.receiveShadow = false;\n  this.frustumCulled = true;\n  this.renderOrder = 0;\n  this.userData = {};\n};\n\nTHREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\nTHREE.Object3D.prototype = {\n  constructor: THREE.Object3D,\n\n  get eulerOrder() {\n    console.warn('THREE.Object3D: .eulerOrder has been moved to .rotation.order.');\n    return this.rotation.order;\n  },\n\n  set eulerOrder(value) {\n    console.warn('THREE.Object3D: .eulerOrder has been moved to .rotation.order.');\n    this.rotation.order = value;\n  },\n\n  get useQuaternion() {\n    console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n  },\n\n  set useQuaternion(value) {\n    console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n  },\n\n  set renderDepth(value) {\n    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');\n  },\n\n  applyMatrix: function applyMatrix(matrix) {\n    this.matrix.multiplyMatrices(matrix, this.matrix);\n    this.matrix.decompose(this.position, this.quaternion, this.scale);\n  },\n  setRotationFromAxisAngle: function setRotationFromAxisAngle(axis, angle) {\n    // assumes axis is normalized\n    this.quaternion.setFromAxisAngle(axis, angle);\n  },\n  setRotationFromEuler: function setRotationFromEuler(euler) {\n    this.quaternion.setFromEuler(euler, true);\n  },\n  setRotationFromMatrix: function setRotationFromMatrix(m) {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n    this.quaternion.setFromRotationMatrix(m);\n  },\n  setRotationFromQuaternion: function setRotationFromQuaternion(q) {\n    // assumes q is normalized\n    this.quaternion.copy(q);\n  },\n  rotateOnAxis: function () {\n    // rotate object on axis in object space\n    // axis is assumed to be normalized\n    var q1 = new THREE.Quaternion();\n    return function (axis, angle) {\n      q1.setFromAxisAngle(axis, angle);\n      this.quaternion.multiply(q1);\n      return this;\n    };\n  }(),\n  rotateX: function () {\n    var v1 = new THREE.Vector3(1, 0, 0);\n    return function (angle) {\n      return this.rotateOnAxis(v1, angle);\n    };\n  }(),\n  rotateY: function () {\n    var v1 = new THREE.Vector3(0, 1, 0);\n    return function (angle) {\n      return this.rotateOnAxis(v1, angle);\n    };\n  }(),\n  rotateZ: function () {\n    var v1 = new THREE.Vector3(0, 0, 1);\n    return function (angle) {\n      return this.rotateOnAxis(v1, angle);\n    };\n  }(),\n  translateOnAxis: function () {\n    // translate object by distance along axis in object space\n    // axis is assumed to be normalized\n    var v1 = new THREE.Vector3();\n    return function (axis, distance) {\n      v1.copy(axis).applyQuaternion(this.quaternion);\n      this.position.add(v1.multiplyScalar(distance));\n      return this;\n    };\n  }(),\n  translate: function translate(distance, axis) {\n    console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');\n    return this.translateOnAxis(axis, distance);\n  },\n  translateX: function () {\n    var v1 = new THREE.Vector3(1, 0, 0);\n    return function (distance) {\n      return this.translateOnAxis(v1, distance);\n    };\n  }(),\n  translateY: function () {\n    var v1 = new THREE.Vector3(0, 1, 0);\n    return function (distance) {\n      return this.translateOnAxis(v1, distance);\n    };\n  }(),\n  translateZ: function () {\n    var v1 = new THREE.Vector3(0, 0, 1);\n    return function (distance) {\n      return this.translateOnAxis(v1, distance);\n    };\n  }(),\n  localToWorld: function localToWorld(vector) {\n    return vector.applyMatrix4(this.matrixWorld);\n  },\n  worldToLocal: function () {\n    var m1 = new THREE.Matrix4();\n    return function (vector) {\n      return vector.applyMatrix4(m1.getInverse(this.matrixWorld));\n    };\n  }(),\n  lookAt: function () {\n    // This routine does not support objects with rotated and/or translated parent(s)\n    var m1 = new THREE.Matrix4();\n    return function (vector) {\n      m1.lookAt(vector, this.position, this.up);\n      this.quaternion.setFromRotationMatrix(m1);\n    };\n  }(),\n  add: function add(object) {\n    if (arguments.length > 1) {\n      for (var i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n\n      return this;\n    }\n\n    if (object === this) {\n      console.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", object);\n      return this;\n    }\n\n    if (object instanceof THREE.Object3D) {\n      if (object.parent !== null) {\n        object.parent.remove(object);\n      }\n\n      object.parent = this;\n      object.dispatchEvent({\n        type: 'added'\n      });\n      this.children.push(object);\n    } else {\n      console.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object);\n    }\n\n    return this;\n  },\n  remove: function remove(object) {\n    if (arguments.length > 1) {\n      for (var i = 0; i < arguments.length; i++) {\n        this.remove(arguments[i]);\n      }\n    }\n\n    var index = this.children.indexOf(object);\n\n    if (index !== -1) {\n      object.parent = null;\n      object.dispatchEvent({\n        type: 'removed'\n      });\n      this.children.splice(index, 1);\n    }\n  },\n  getChildByName: function getChildByName(name) {\n    console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');\n    return this.getObjectByName(name);\n  },\n  getObjectById: function getObjectById(id) {\n    return this.getObjectByProperty('id', id);\n  },\n  getObjectByName: function getObjectByName(name) {\n    return this.getObjectByProperty('name', name);\n  },\n  getObjectByProperty: function getObjectByProperty(name, value) {\n    if (this[name] === value) return this;\n\n    for (var i = 0, l = this.children.length; i < l; i++) {\n      var child = this.children[i];\n      var object = child.getObjectByProperty(name, value);\n\n      if (object !== undefined) {\n        return object;\n      }\n    }\n\n    return undefined;\n  },\n  getWorldPosition: function getWorldPosition(optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    this.updateMatrixWorld(true);\n    return result.setFromMatrixPosition(this.matrixWorld);\n  },\n  getWorldQuaternion: function () {\n    var position = new THREE.Vector3();\n    var scale = new THREE.Vector3();\n    return function (optionalTarget) {\n      var result = optionalTarget || new THREE.Quaternion();\n      this.updateMatrixWorld(true);\n      this.matrixWorld.decompose(position, result, scale);\n      return result;\n    };\n  }(),\n  getWorldRotation: function () {\n    var quaternion = new THREE.Quaternion();\n    return function (optionalTarget) {\n      var result = optionalTarget || new THREE.Euler();\n      this.getWorldQuaternion(quaternion);\n      return result.setFromQuaternion(quaternion, this.rotation.order, false);\n    };\n  }(),\n  getWorldScale: function () {\n    var position = new THREE.Vector3();\n    var quaternion = new THREE.Quaternion();\n    return function (optionalTarget) {\n      var result = optionalTarget || new THREE.Vector3();\n      this.updateMatrixWorld(true);\n      this.matrixWorld.decompose(position, quaternion, result);\n      return result;\n    };\n  }(),\n  getWorldDirection: function () {\n    var quaternion = new THREE.Quaternion();\n    return function (optionalTarget) {\n      var result = optionalTarget || new THREE.Vector3();\n      this.getWorldQuaternion(quaternion);\n      return result.set(0, 0, 1).applyQuaternion(quaternion);\n    };\n  }(),\n  raycast: function raycast() {},\n  traverse: function traverse(callback) {\n    callback(this);\n    var children = this.children;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      children[i].traverse(callback);\n    }\n  },\n  traverseVisible: function traverseVisible(callback) {\n    if (this.visible === false) return;\n    callback(this);\n    var children = this.children;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      children[i].traverseVisible(callback);\n    }\n  },\n  traverseAncestors: function traverseAncestors(callback) {\n    var parent = this.parent;\n\n    if (parent !== null) {\n      callback(parent);\n      parent.traverseAncestors(callback);\n    }\n  },\n  updateMatrix: function updateMatrix() {\n    this.matrix.compose(this.position, this.quaternion, this.scale);\n    this.matrixWorldNeedsUpdate = true;\n  },\n  updateMatrixWorld: function updateMatrixWorld(force) {\n    if (this.matrixAutoUpdate === true) this.updateMatrix();\n\n    if (this.matrixWorldNeedsUpdate === true || force === true) {\n      if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      }\n\n      this.matrixWorldNeedsUpdate = false;\n      force = true;\n    } // update children\n\n\n    for (var i = 0, l = this.children.length; i < l; i++) {\n      this.children[i].updateMatrixWorld(force);\n    }\n  },\n  toJSON: function toJSON(meta) {\n    var isRootObject = meta === undefined;\n    var data = {}; // meta is a hash used to collect geometries, materials.\n    // not providing it implies that this is the root object\n    // being serialized.\n\n    if (isRootObject) {\n      // initialize meta obj\n      meta = {\n        geometries: {},\n        materials: {},\n        textures: {},\n        images: {}\n      };\n      data.metadata = {\n        version: 4.4,\n        type: 'Object',\n        generator: 'Object3D.toJSON'\n      };\n    } // standard Object3D serialization\n\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;\n    if (this.visible !== true) data.visible = this.visible;\n    data.matrix = this.matrix.toArray();\n\n    if (this.children.length > 0) {\n      data.children = [];\n\n      for (var i = 0; i < this.children.length; i++) {\n        data.children.push(this.children[i].toJSON(meta).object);\n      }\n    }\n\n    var output = {};\n\n    if (isRootObject) {\n      var geometries = extractFromCache(meta.geometries);\n      var materials = extractFromCache(meta.materials);\n      var textures = extractFromCache(meta.textures);\n      var images = extractFromCache(meta.images);\n      if (geometries.length > 0) output.geometries = geometries;\n      if (materials.length > 0) output.materials = materials;\n      if (textures.length > 0) output.textures = textures;\n      if (images.length > 0) output.images = images;\n    }\n\n    output.object = data;\n    return output; // extract data from the cache hash\n    // remove metadata on each item\n    // and return as array\n\n    function extractFromCache(cache) {\n      var values = [];\n\n      for (var key in cache) {\n        var data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n  },\n  clone: function clone(recursive) {\n    return new this.constructor().copy(this, recursive);\n  },\n  copy: function copy(source, recursive) {\n    if (recursive === undefined) recursive = true;\n    this.name = source.name;\n    this.up.copy(source.up);\n    this.position.copy(source.position);\n    this.quaternion.copy(source.quaternion);\n    this.scale.copy(source.scale);\n    this.rotationAutoUpdate = source.rotationAutoUpdate;\n    this.matrix.copy(source.matrix);\n    this.matrixWorld.copy(source.matrixWorld);\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n    this.visible = source.visible;\n    this.castShadow = source.castShadow;\n    this.receiveShadow = source.receiveShadow;\n    this.frustumCulled = source.frustumCulled;\n    this.renderOrder = source.renderOrder;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n\n    if (recursive === true) {\n      for (var i = 0; i < source.children.length; i++) {\n        var child = source.children[i];\n        this.add(child.clone());\n      }\n    }\n\n    return this;\n  }\n};\nTHREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);\nTHREE.Object3DIdCount = 0; // File:src/core/Face3.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.Face3 = function (a, b, c, normal, color, materialIndex) {\n  this.a = a;\n  this.b = b;\n  this.c = c;\n  this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n  this.vertexNormals = Array.isArray(normal) ? normal : [];\n  this.color = color instanceof THREE.Color ? color : new THREE.Color();\n  this.vertexColors = Array.isArray(color) ? color : [];\n  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n};\n\nTHREE.Face3.prototype = {\n  constructor: THREE.Face3,\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n\n    for (var i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n\n    for (var i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n\n    return this;\n  }\n}; // File:src/core/Face4.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.Face4 = function (a, b, c, d, normal, color, materialIndex) {\n  console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');\n  return new THREE.Face3(a, b, c, normal, color, materialIndex);\n}; // File:src/core/BufferAttribute.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.BufferAttribute = function (array, itemSize) {\n  this.uuid = THREE.Math.generateUUID();\n  this.array = array;\n  this.itemSize = itemSize;\n  this.dynamic = false;\n  this.updateRange = {\n    offset: 0,\n    count: -1\n  };\n  this.version = 0;\n};\n\nTHREE.BufferAttribute.prototype = {\n  constructor: THREE.BufferAttribute,\n\n  get length() {\n    console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');\n    return this.array.length;\n  },\n\n  get count() {\n    return this.array.length / this.itemSize;\n  },\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  },\n\n  setDynamic: function setDynamic(value) {\n    this.dynamic = value;\n    return this;\n  },\n  copy: function copy(source) {\n    this.array = new source.array.constructor(source.array);\n    this.itemSize = source.itemSize;\n    this.dynamic = source.dynamic;\n    return this;\n  },\n  copyAt: function copyAt(index1, attribute, index2) {\n    index1 *= this.itemSize;\n    index2 *= attribute.itemSize;\n\n    for (var i = 0, l = this.itemSize; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n\n    return this;\n  },\n  copyArray: function copyArray(array) {\n    this.array.set(array);\n    return this;\n  },\n  copyColorsArray: function copyColorsArray(colors) {\n    var array = this.array,\n        offset = 0;\n\n    for (var i = 0, l = colors.length; i < l; i++) {\n      var color = colors[i];\n\n      if (color === undefined) {\n        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);\n        color = new THREE.Color();\n      }\n\n      array[offset++] = color.r;\n      array[offset++] = color.g;\n      array[offset++] = color.b;\n    }\n\n    return this;\n  },\n  copyIndicesArray: function copyIndicesArray(indices) {\n    var array = this.array,\n        offset = 0;\n\n    for (var i = 0, l = indices.length; i < l; i++) {\n      var index = indices[i];\n      array[offset++] = index.a;\n      array[offset++] = index.b;\n      array[offset++] = index.c;\n    }\n\n    return this;\n  },\n  copyVector2sArray: function copyVector2sArray(vectors) {\n    var array = this.array,\n        offset = 0;\n\n    for (var i = 0, l = vectors.length; i < l; i++) {\n      var vector = vectors[i];\n\n      if (vector === undefined) {\n        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);\n        vector = new THREE.Vector2();\n      }\n\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n    }\n\n    return this;\n  },\n  copyVector3sArray: function copyVector3sArray(vectors) {\n    var array = this.array,\n        offset = 0;\n\n    for (var i = 0, l = vectors.length; i < l; i++) {\n      var vector = vectors[i];\n\n      if (vector === undefined) {\n        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);\n        vector = new THREE.Vector3();\n      }\n\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n      array[offset++] = vector.z;\n    }\n\n    return this;\n  },\n  copyVector4sArray: function copyVector4sArray(vectors) {\n    var array = this.array,\n        offset = 0;\n\n    for (var i = 0, l = vectors.length; i < l; i++) {\n      var vector = vectors[i];\n\n      if (vector === undefined) {\n        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);\n        vector = new THREE.Vector4();\n      }\n\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n      array[offset++] = vector.z;\n      array[offset++] = vector.w;\n    }\n\n    return this;\n  },\n  set: function set(value, offset) {\n    if (offset === undefined) offset = 0;\n    this.array.set(value, offset);\n    return this;\n  },\n  getX: function getX(index) {\n    return this.array[index * this.itemSize];\n  },\n  setX: function setX(index, x) {\n    this.array[index * this.itemSize] = x;\n    return this;\n  },\n  getY: function getY(index) {\n    return this.array[index * this.itemSize + 1];\n  },\n  setY: function setY(index, y) {\n    this.array[index * this.itemSize + 1] = y;\n    return this;\n  },\n  getZ: function getZ(index) {\n    return this.array[index * this.itemSize + 2];\n  },\n  setZ: function setZ(index, z) {\n    this.array[index * this.itemSize + 2] = z;\n    return this;\n  },\n  getW: function getW(index) {\n    return this.array[index * this.itemSize + 3];\n  },\n  setW: function setW(index, w) {\n    this.array[index * this.itemSize + 3] = w;\n    return this;\n  },\n  setXY: function setXY(index, x, y) {\n    index *= this.itemSize;\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    return this;\n  },\n  setXYZ: function setXYZ(index, x, y, z) {\n    index *= this.itemSize;\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    return this;\n  },\n  setXYZW: function setXYZW(index, x, y, z, w) {\n    index *= this.itemSize;\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    this.array[index + 3] = w;\n    return this;\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  }\n}; //\n\nTHREE.Int8Attribute = function (array, itemSize) {\n  return new THREE.BufferAttribute(new Int8Array(array), itemSize);\n};\n\nTHREE.Uint8Attribute = function (array, itemSize) {\n  return new THREE.BufferAttribute(new Uint8Array(array), itemSize);\n};\n\nTHREE.Uint8ClampedAttribute = function (array, itemSize) {\n  return new THREE.BufferAttribute(new Uint8ClampedArray(array), itemSize);\n};\n\nTHREE.Int16Attribute = function (array, itemSize) {\n  return new THREE.BufferAttribute(new Int16Array(array), itemSize);\n};\n\nTHREE.Uint16Attribute = function (array, itemSize) {\n  return new THREE.BufferAttribute(new Uint16Array(array), itemSize);\n};\n\nTHREE.Int32Attribute = function (array, itemSize) {\n  return new THREE.BufferAttribute(new Int32Array(array), itemSize);\n};\n\nTHREE.Uint32Attribute = function (array, itemSize) {\n  return new THREE.BufferAttribute(new Uint32Array(array), itemSize);\n};\n\nTHREE.Float32Attribute = function (array, itemSize) {\n  return new THREE.BufferAttribute(new Float32Array(array), itemSize);\n};\n\nTHREE.Float64Attribute = function (array, itemSize) {\n  return new THREE.BufferAttribute(new Float64Array(array), itemSize);\n}; // Deprecated\n\n\nTHREE.DynamicBufferAttribute = function (array, itemSize) {\n  console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');\n  return new THREE.BufferAttribute(array, itemSize).setDynamic(true);\n}; // File:src/core/InstancedBufferAttribute.js\n\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\n\n\nTHREE.InstancedBufferAttribute = function (array, itemSize, meshPerAttribute) {\n  THREE.BufferAttribute.call(this, array, itemSize);\n  this.meshPerAttribute = meshPerAttribute || 1;\n};\n\nTHREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\n\nTHREE.InstancedBufferAttribute.prototype.copy = function (source) {\n  THREE.BufferAttribute.prototype.copy.call(this, source);\n  this.meshPerAttribute = source.meshPerAttribute;\n  return this;\n}; // File:src/core/InterleavedBuffer.js\n\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\n\n\nTHREE.InterleavedBuffer = function (array, stride) {\n  this.uuid = THREE.Math.generateUUID();\n  this.array = array;\n  this.stride = stride;\n  this.dynamic = false;\n  this.updateRange = {\n    offset: 0,\n    count: -1\n  };\n  this.version = 0;\n};\n\nTHREE.InterleavedBuffer.prototype = {\n  constructor: THREE.InterleavedBuffer,\n\n  get length() {\n    return this.array.length;\n  },\n\n  get count() {\n    return this.array.length / this.stride;\n  },\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  },\n\n  setDynamic: function setDynamic(value) {\n    this.dynamic = value;\n    return this;\n  },\n  copy: function copy(source) {\n    this.array = new source.array.constructor(source.array);\n    this.stride = source.stride;\n    this.dynamic = source.dynamic;\n  },\n  copyAt: function copyAt(index1, attribute, index2) {\n    index1 *= this.stride;\n    index2 *= attribute.stride;\n\n    for (var i = 0, l = this.stride; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n\n    return this;\n  },\n  set: function set(value, offset) {\n    if (offset === undefined) offset = 0;\n    this.array.set(value, offset);\n    return this;\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  }\n}; // File:src/core/InstancedInterleavedBuffer.js\n\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\n\nTHREE.InstancedInterleavedBuffer = function (array, stride, meshPerAttribute) {\n  THREE.InterleavedBuffer.call(this, array, stride);\n  this.meshPerAttribute = meshPerAttribute || 1;\n};\n\nTHREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype);\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\n\nTHREE.InstancedInterleavedBuffer.prototype.copy = function (source) {\n  THREE.InterleavedBuffer.prototype.copy.call(this, source);\n  this.meshPerAttribute = source.meshPerAttribute;\n  return this;\n}; // File:src/core/InterleavedBufferAttribute.js\n\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\n\n\nTHREE.InterleavedBufferAttribute = function (interleavedBuffer, itemSize, offset) {\n  this.uuid = THREE.Math.generateUUID();\n  this.data = interleavedBuffer;\n  this.itemSize = itemSize;\n  this.offset = offset;\n};\n\nTHREE.InterleavedBufferAttribute.prototype = {\n  constructor: THREE.InterleavedBufferAttribute,\n\n  get length() {\n    console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');\n    return this.array.length;\n  },\n\n  get count() {\n    return this.data.array.length / this.data.stride;\n  },\n\n  setX: function setX(index, x) {\n    this.data.array[index * this.data.stride + this.offset] = x;\n    return this;\n  },\n  setY: function setY(index, y) {\n    this.data.array[index * this.data.stride + this.offset + 1] = y;\n    return this;\n  },\n  setZ: function setZ(index, z) {\n    this.data.array[index * this.data.stride + this.offset + 2] = z;\n    return this;\n  },\n  setW: function setW(index, w) {\n    this.data.array[index * this.data.stride + this.offset + 3] = w;\n    return this;\n  },\n  getX: function getX(index) {\n    return this.data.array[index * this.data.stride + this.offset];\n  },\n  getY: function getY(index) {\n    return this.data.array[index * this.data.stride + this.offset + 1];\n  },\n  getZ: function getZ(index) {\n    return this.data.array[index * this.data.stride + this.offset + 2];\n  },\n  getW: function getW(index) {\n    return this.data.array[index * this.data.stride + this.offset + 3];\n  },\n  setXY: function setXY(index, x, y) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    return this;\n  },\n  setXYZ: function setXYZ(index, x, y, z) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    return this;\n  },\n  setXYZW: function setXYZW(index, x, y, z, w) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    this.data.array[index + 3] = w;\n    return this;\n  }\n}; // File:src/core/Geometry.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://exocortex.com\r\n */\n\nTHREE.Geometry = function () {\n  Object.defineProperty(this, 'id', {\n    value: THREE.GeometryIdCount++\n  });\n  this.uuid = THREE.Math.generateUUID();\n  this.name = '';\n  this.type = 'Geometry';\n  this.vertices = [];\n  this.colors = [];\n  this.faces = [];\n  this.faceVertexUvs = [[]];\n  this.morphTargets = [];\n  this.morphColors = [];\n  this.morphNormals = [];\n  this.skinWeights = [];\n  this.skinIndices = [];\n  this.lineDistances = [];\n  this.boundingBox = null;\n  this.boundingSphere = null; // update flags\n\n  this.verticesNeedUpdate = false;\n  this.elementsNeedUpdate = false;\n  this.uvsNeedUpdate = false;\n  this.normalsNeedUpdate = false;\n  this.colorsNeedUpdate = false;\n  this.lineDistancesNeedUpdate = false;\n  this.groupsNeedUpdate = false;\n};\n\nTHREE.Geometry.prototype = {\n  constructor: THREE.Geometry,\n  applyMatrix: function applyMatrix(matrix) {\n    var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);\n\n    for (var i = 0, il = this.vertices.length; i < il; i++) {\n      var vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n\n    for (var i = 0, il = this.faces.length; i < il; i++) {\n      var face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n\n      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n  },\n  rotateX: function () {\n    // rotate geometry around world x-axis\n    var m1;\n    return function rotateX(angle) {\n      if (m1 === undefined) m1 = new THREE.Matrix4();\n      m1.makeRotationX(angle);\n      this.applyMatrix(m1);\n      return this;\n    };\n  }(),\n  rotateY: function () {\n    // rotate geometry around world y-axis\n    var m1;\n    return function rotateY(angle) {\n      if (m1 === undefined) m1 = new THREE.Matrix4();\n      m1.makeRotationY(angle);\n      this.applyMatrix(m1);\n      return this;\n    };\n  }(),\n  rotateZ: function () {\n    // rotate geometry around world z-axis\n    var m1;\n    return function rotateZ(angle) {\n      if (m1 === undefined) m1 = new THREE.Matrix4();\n      m1.makeRotationZ(angle);\n      this.applyMatrix(m1);\n      return this;\n    };\n  }(),\n  translate: function () {\n    // translate geometry\n    var m1;\n    return function translate(x, y, z) {\n      if (m1 === undefined) m1 = new THREE.Matrix4();\n      m1.makeTranslation(x, y, z);\n      this.applyMatrix(m1);\n      return this;\n    };\n  }(),\n  scale: function () {\n    // scale geometry\n    var m1;\n    return function scale(x, y, z) {\n      if (m1 === undefined) m1 = new THREE.Matrix4();\n      m1.makeScale(x, y, z);\n      this.applyMatrix(m1);\n      return this;\n    };\n  }(),\n  lookAt: function () {\n    var obj;\n    return function lookAt(vector) {\n      if (obj === undefined) obj = new THREE.Object3D();\n      obj.lookAt(vector);\n      obj.updateMatrix();\n      this.applyMatrix(obj.matrix);\n    };\n  }(),\n  fromBufferGeometry: function fromBufferGeometry(geometry) {\n    var scope = this;\n    var indices = geometry.index !== null ? geometry.index.array : undefined;\n    var attributes = geometry.attributes;\n    var vertices = attributes.position.array;\n    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n    var colors = attributes.color !== undefined ? attributes.color.array : undefined;\n    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n    var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n    if (uvs2 !== undefined) this.faceVertexUvs[1] = [];\n    var tempNormals = [];\n    var tempUVs = [];\n    var tempUVs2 = [];\n\n    for (var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4) {\n      scope.vertices.push(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));\n\n      if (normals !== undefined) {\n        tempNormals.push(new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]));\n      }\n\n      if (colors !== undefined) {\n        scope.colors.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));\n      }\n\n      if (uvs !== undefined) {\n        tempUVs.push(new THREE.Vector2(uvs[j], uvs[j + 1]));\n      }\n\n      if (uvs2 !== undefined) {\n        tempUVs2.push(new THREE.Vector2(uvs2[j], uvs2[j + 1]));\n      }\n    }\n\n    var addFace = function addFace(a, b, c) {\n      var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];\n      var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];\n      var face = new THREE.Face3(a, b, c, vertexNormals, vertexColors);\n      scope.faces.push(face);\n\n      if (uvs !== undefined) {\n        scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);\n      }\n\n      if (uvs2 !== undefined) {\n        scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);\n      }\n    };\n\n    if (indices !== undefined) {\n      var groups = geometry.groups;\n\n      if (groups.length > 0) {\n        for (var i = 0; i < groups.length; i++) {\n          var group = groups[i];\n          var start = group.start;\n          var count = group.count;\n\n          for (var j = start, jl = start + count; j < jl; j += 3) {\n            addFace(indices[j], indices[j + 1], indices[j + 2]);\n          }\n        }\n      } else {\n        for (var i = 0; i < indices.length; i += 3) {\n          addFace(indices[i], indices[i + 1], indices[i + 2]);\n        }\n      }\n    } else {\n      for (var i = 0; i < vertices.length / 3; i += 3) {\n        addFace(i, i + 1, i + 2);\n      }\n    }\n\n    this.computeFaceNormals();\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    return this;\n  },\n  center: function center() {\n    this.computeBoundingBox();\n    var offset = this.boundingBox.center().negate();\n    this.translate(offset.x, offset.y, offset.z);\n    return offset;\n  },\n  normalize: function normalize() {\n    this.computeBoundingSphere();\n    var center = this.boundingSphere.center;\n    var radius = this.boundingSphere.radius;\n    var s = radius === 0 ? 1 : 1.0 / radius;\n    var matrix = new THREE.Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix(matrix);\n    return this;\n  },\n  computeFaceNormals: function computeFaceNormals() {\n    var cb = new THREE.Vector3(),\n        ab = new THREE.Vector3();\n\n    for (var f = 0, fl = this.faces.length; f < fl; f++) {\n      var face = this.faces[f];\n      var vA = this.vertices[face.a];\n      var vB = this.vertices[face.b];\n      var vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  },\n  computeVertexNormals: function computeVertexNormals(areaWeighted) {\n    var v, vl, f, fl, face, vertices;\n    vertices = new Array(this.vertices.length);\n\n    for (v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new THREE.Vector3();\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n      var vA, vB, vC;\n      var cb = new THREE.Vector3(),\n          ab = new THREE.Vector3();\n\n      for (f = 0, fl = this.faces.length; f < fl; f++) {\n        face = this.faces[f];\n        vA = this.vertices[face.a];\n        vB = this.vertices[face.b];\n        vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      for (f = 0, fl = this.faces.length; f < fl; f++) {\n        face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n\n    for (v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n\n    for (f = 0, fl = this.faces.length; f < fl; f++) {\n      face = this.faces[f];\n      var vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n  },\n  computeMorphNormals: function computeMorphNormals() {\n    var i, il, f, fl, face; // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n\n    for (f = 0, fl = this.faces.length; f < fl; f++) {\n      face = this.faces[f];\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n      for (i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    } // use temp geometry to compute face and vertex normals for each morph\n\n\n    var tmpGeo = new THREE.Geometry();\n    tmpGeo.faces = this.faces;\n\n    for (i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        var dstNormalsFace = this.morphNormals[i].faceNormals;\n        var dstNormalsVertex = this.morphNormals[i].vertexNormals;\n        var faceNormal, vertexNormals;\n\n        for (f = 0, fl = this.faces.length; f < fl; f++) {\n          faceNormal = new THREE.Vector3();\n          vertexNormals = {\n            a: new THREE.Vector3(),\n            b: new THREE.Vector3(),\n            c: new THREE.Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n\n      var morphNormals = this.morphNormals[i]; // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\n\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals(); // store morph normals\n\n      var faceNormal, vertexNormals;\n\n      for (f = 0, fl = this.faces.length; f < fl; f++) {\n        face = this.faces[f];\n        faceNormal = morphNormals.faceNormals[f];\n        vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    } // restore original normals\n\n\n    for (f = 0, fl = this.faces.length; f < fl; f++) {\n      face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  },\n  computeTangents: function computeTangents() {\n    console.warn('THREE.Geometry: .computeTangents() has been removed.');\n  },\n  computeLineDistances: function computeLineDistances() {\n    var d = 0;\n    var vertices = this.vertices;\n\n    for (var i = 0, il = vertices.length; i < il; i++) {\n      if (i > 0) {\n        d += vertices[i].distanceTo(vertices[i - 1]);\n      }\n\n      this.lineDistances[i] = d;\n    }\n  },\n  computeBoundingBox: function computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new THREE.Box3();\n    }\n\n    this.boundingBox.setFromPoints(this.vertices);\n  },\n  computeBoundingSphere: function computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new THREE.Sphere();\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices);\n  },\n  merge: function merge(geometry, matrix, materialIndexOffset) {\n    if (geometry instanceof THREE.Geometry === false) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n      return;\n    }\n\n    var normalMatrix,\n        vertexOffset = this.vertices.length,\n        vertices1 = this.vertices,\n        vertices2 = geometry.vertices,\n        faces1 = this.faces,\n        faces2 = geometry.faces,\n        uvs1 = this.faceVertexUvs[0],\n        uvs2 = geometry.faceVertexUvs[0];\n    if (materialIndexOffset === undefined) materialIndexOffset = 0;\n\n    if (matrix !== undefined) {\n      normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);\n    } // vertices\n\n\n    for (var i = 0, il = vertices2.length; i < il; i++) {\n      var vertex = vertices2[i];\n      var vertexCopy = vertex.clone();\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    } // faces\n\n\n    for (i = 0, il = faces2.length; i < il; i++) {\n      var face = faces2[i],\n          faceCopy,\n          normal,\n          color,\n          faceVertexNormals = face.vertexNormals,\n          faceVertexColors = face.vertexColors;\n      faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        faceCopy.vertexNormals.push(normal);\n      }\n\n      faceCopy.color.copy(face.color);\n\n      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    } // uvs\n\n\n    for (i = 0, il = uvs2.length; i < il; i++) {\n      var uv = uvs2[i],\n          uvCopy = [];\n\n      if (uv === undefined) {\n        continue;\n      }\n\n      for (var j = 0, jl = uv.length; j < jl; j++) {\n        uvCopy.push(uv[j].clone());\n      }\n\n      uvs1.push(uvCopy);\n    }\n  },\n  mergeMesh: function mergeMesh(mesh) {\n    if (mesh instanceof THREE.Mesh === false) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n      return;\n    }\n\n    mesh.matrixAutoUpdate && mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  },\n\n  /*\r\n   * Checks for duplicate vertices with hashmap.\r\n   * Duplicated vertices are removed\r\n   * and faces' vertices are updated.\r\n   */\n  mergeVertices: function mergeVertices() {\n    var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n    var unique = [],\n        changes = [];\n    var v, key;\n    var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\n    var precision = Math.pow(10, precisionPoints);\n    var i, il, face;\n    var indices, j, jl;\n\n    for (i = 0, il = this.vertices.length; i < il; i++) {\n      v = this.vertices[i];\n      key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]];\n      }\n    } // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n\n\n    var faceIndicesToRemove = [];\n\n    for (i = 0, il = this.faces.length; i < il; i++) {\n      face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      indices = [face.a, face.b, face.c];\n      var dupIndex = -1; // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n\n      for (var n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          dupIndex = n;\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n\n    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      var idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n\n      for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    } // Use unique set of vertices\n\n\n    var diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  },\n  toJSON: function toJSON() {\n    var data = {\n      metadata: {\n        version: 4.4,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON'\n      }\n    }; // standard Geometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n\n    if (this.parameters !== undefined) {\n      var parameters = this.parameters;\n\n      for (var key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    var vertices = [];\n\n    for (var i = 0; i < this.vertices.length; i++) {\n      var vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    var faces = [];\n    var normals = [];\n    var normalsHash = {};\n    var colors = [];\n    var colorsHash = {};\n    var uvs = [];\n    var uvsHash = {};\n\n    for (var i = 0; i < this.faces.length; i++) {\n      var face = this.faces[i];\n      var hasMaterial = false; // face.materialIndex !== undefined;\n\n      var hasFaceUv = false; // deprecated\n\n      var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n      var hasFaceNormal = face.normal.length() > 0;\n      var hasFaceVertexNormal = face.vertexNormals.length > 0;\n      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      var hasFaceVertexColor = face.vertexColors.length > 0;\n      var faceType = 0;\n      faceType = setBit(faceType, 0, 0);\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n\n      if (hasFaceVertexUv) {\n        var faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n\n      if (hasFaceVertexNormal) {\n        var vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n\n      if (hasFaceVertexColor) {\n        var vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n\n    function getNormalIndex(normal) {\n      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash];\n      }\n\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n\n    function getColorIndex(color) {\n      var hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash];\n      }\n\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n\n    function getUvIndex(uv) {\n      var hash = uv.x.toString() + uv.y.toString();\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash];\n      }\n\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n    data.data.faces = faces;\n    return data;\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(source) {\n    this.vertices = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    var vertices = source.vertices;\n\n    for (var i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    }\n\n    var faces = source.faces;\n\n    for (var i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    }\n\n    for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      var faceVertexUvs = source.faceVertexUvs[i];\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = [];\n      }\n\n      for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        var uvs = faceVertexUvs[j],\n            uvsCopy = [];\n\n        for (var k = 0, kl = uvs.length; k < kl; k++) {\n          var uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n\n    return this;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n};\nTHREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);\nTHREE.GeometryIdCount = 0; // File:src/core/DirectGeometry.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.DirectGeometry = function () {\n  Object.defineProperty(this, 'id', {\n    value: THREE.GeometryIdCount++\n  });\n  this.uuid = THREE.Math.generateUUID();\n  this.name = '';\n  this.type = 'DirectGeometry';\n  this.indices = [];\n  this.vertices = [];\n  this.normals = [];\n  this.colors = [];\n  this.uvs = [];\n  this.uvs2 = [];\n  this.groups = [];\n  this.morphTargets = {};\n  this.skinWeights = [];\n  this.skinIndices = []; // this.lineDistances = [];\n\n  this.boundingBox = null;\n  this.boundingSphere = null; // update flags\n\n  this.verticesNeedUpdate = false;\n  this.normalsNeedUpdate = false;\n  this.colorsNeedUpdate = false;\n  this.uvsNeedUpdate = false;\n  this.groupsNeedUpdate = false;\n};\n\nTHREE.DirectGeometry.prototype = {\n  constructor: THREE.DirectGeometry,\n  computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\n  computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\n  computeFaceNormals: function computeFaceNormals() {\n    console.warn('THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.');\n  },\n  computeVertexNormals: function computeVertexNormals() {\n    console.warn('THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.');\n  },\n  computeGroups: function computeGroups(geometry) {\n    var group;\n    var groups = [];\n    var materialIndex;\n    var faces = geometry.faces;\n\n    for (var i = 0; i < faces.length; i++) {\n      var face = faces[i]; // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex: materialIndex\n        };\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n\n    this.groups = groups;\n  },\n  fromGeometry: function fromGeometry(geometry) {\n    var faces = geometry.faces;\n    var vertices = geometry.vertices;\n    var faceVertexUvs = geometry.faceVertexUvs;\n    var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n    var morphTargets = geometry.morphTargets;\n    var morphTargetsLength = morphTargets.length;\n\n    if (morphTargetsLength > 0) {\n      var morphTargetsPosition = [];\n\n      for (var i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = [];\n      }\n\n      this.morphTargets.position = morphTargetsPosition;\n    }\n\n    var morphNormals = geometry.morphNormals;\n    var morphNormalsLength = morphNormals.length;\n\n    if (morphNormalsLength > 0) {\n      var morphTargetsNormal = [];\n\n      for (var i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = [];\n      }\n\n      this.morphTargets.normal = morphTargetsNormal;\n    } // skins\n\n\n    var skinIndices = geometry.skinIndices;\n    var skinWeights = geometry.skinWeights;\n    var hasSkinIndices = skinIndices.length === vertices.length;\n    var hasSkinWeights = skinWeights.length === vertices.length; //\n\n    for (var i = 0; i < faces.length; i++) {\n      var face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      var vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        var normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n\n      var vertexColors = face.vertexColors;\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        var color = face.color;\n        this.colors.push(color, color, color);\n      }\n\n      if (hasFaceVertexUv === true) {\n        var vertexUvs = faceVertexUvs[0][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n          this.uvs.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        var vertexUvs = faceVertexUvs[1][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n          this.uvs2.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());\n        }\n      } // morphs\n\n\n      for (var j = 0; j < morphTargetsLength; j++) {\n        var morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n\n      for (var j = 0; j < morphNormalsLength; j++) {\n        var morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);\n      } // skins\n\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n    return this;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n};\nTHREE.EventDispatcher.prototype.apply(THREE.DirectGeometry.prototype); // File:src/core/BufferGeometry.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.BufferGeometry = function () {\n  Object.defineProperty(this, 'id', {\n    value: THREE.GeometryIdCount++\n  });\n  this.uuid = THREE.Math.generateUUID();\n  this.name = '';\n  this.type = 'BufferGeometry';\n  this.index = null;\n  this.attributes = {};\n  this.morphAttributes = {};\n  this.groups = [];\n  this.boundingBox = null;\n  this.boundingSphere = null;\n  this.drawRange = {\n    start: 0,\n    count: Infinity\n  };\n};\n\nTHREE.BufferGeometry.prototype = {\n  constructor: THREE.BufferGeometry,\n  addIndex: function addIndex(index) {\n    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');\n    this.setIndex(index);\n  },\n  getIndex: function getIndex() {\n    return this.index;\n  },\n  setIndex: function setIndex(index) {\n    this.index = index;\n  },\n  addAttribute: function addAttribute(name, attribute) {\n    if (attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false) {\n      console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');\n      this.addAttribute(name, new THREE.BufferAttribute(arguments[1], arguments[2]));\n      return;\n    }\n\n    if (name === 'index') {\n      console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');\n      this.setIndex(attribute);\n    }\n\n    this.attributes[name] = attribute;\n  },\n  getAttribute: function getAttribute(name) {\n    return this.attributes[name];\n  },\n  removeAttribute: function removeAttribute(name) {\n    delete this.attributes[name];\n  },\n\n  get drawcalls() {\n    console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');\n    return this.groups;\n  },\n\n  get offsets() {\n    console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');\n    return this.groups;\n  },\n\n  addDrawCall: function addDrawCall(start, count, indexOffset) {\n    if (indexOffset !== undefined) {\n      console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');\n    }\n\n    console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');\n    this.addGroup(start, count);\n  },\n  clearDrawCalls: function clearDrawCalls() {\n    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');\n    this.clearGroups();\n  },\n  addGroup: function addGroup(start, count, materialIndex) {\n    this.groups.push({\n      start: start,\n      count: count,\n      materialIndex: materialIndex !== undefined ? materialIndex : 0\n    });\n  },\n  clearGroups: function clearGroups() {\n    this.groups = [];\n  },\n  setDrawRange: function setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  },\n  applyMatrix: function applyMatrix(matrix) {\n    var position = this.attributes.position;\n\n    if (position !== undefined) {\n      matrix.applyToVector3Array(position.array);\n      position.needsUpdate = true;\n    }\n\n    var normal = this.attributes.normal;\n\n    if (normal !== undefined) {\n      var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);\n      normalMatrix.applyToVector3Array(normal.array);\n      normal.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n  },\n  rotateX: function () {\n    // rotate geometry around world x-axis\n    var m1;\n    return function rotateX(angle) {\n      if (m1 === undefined) m1 = new THREE.Matrix4();\n      m1.makeRotationX(angle);\n      this.applyMatrix(m1);\n      return this;\n    };\n  }(),\n  rotateY: function () {\n    // rotate geometry around world y-axis\n    var m1;\n    return function rotateY(angle) {\n      if (m1 === undefined) m1 = new THREE.Matrix4();\n      m1.makeRotationY(angle);\n      this.applyMatrix(m1);\n      return this;\n    };\n  }(),\n  rotateZ: function () {\n    // rotate geometry around world z-axis\n    var m1;\n    return function rotateZ(angle) {\n      if (m1 === undefined) m1 = new THREE.Matrix4();\n      m1.makeRotationZ(angle);\n      this.applyMatrix(m1);\n      return this;\n    };\n  }(),\n  translate: function () {\n    // translate geometry\n    var m1;\n    return function translate(x, y, z) {\n      if (m1 === undefined) m1 = new THREE.Matrix4();\n      m1.makeTranslation(x, y, z);\n      this.applyMatrix(m1);\n      return this;\n    };\n  }(),\n  scale: function () {\n    // scale geometry\n    var m1;\n    return function scale(x, y, z) {\n      if (m1 === undefined) m1 = new THREE.Matrix4();\n      m1.makeScale(x, y, z);\n      this.applyMatrix(m1);\n      return this;\n    };\n  }(),\n  lookAt: function () {\n    var obj;\n    return function lookAt(vector) {\n      if (obj === undefined) obj = new THREE.Object3D();\n      obj.lookAt(vector);\n      obj.updateMatrix();\n      this.applyMatrix(obj.matrix);\n    };\n  }(),\n  center: function center() {\n    this.computeBoundingBox();\n    var offset = this.boundingBox.center().negate();\n    this.translate(offset.x, offset.y, offset.z);\n    return offset;\n  },\n  setFromObject: function setFromObject(object) {\n    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n    var geometry = object.geometry;\n\n    if (object instanceof THREE.Points || object instanceof THREE.Line) {\n      var positions = new THREE.Float32Attribute(geometry.vertices.length * 3, 3);\n      var colors = new THREE.Float32Attribute(geometry.colors.length * 3, 3);\n      this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));\n      this.addAttribute('color', colors.copyColorsArray(geometry.colors));\n\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        var lineDistances = new THREE.Float32Attribute(geometry.lineDistances.length, 1);\n        this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n      }\n\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n    } else if (object instanceof THREE.Mesh) {\n      if (geometry instanceof THREE.Geometry) {\n        this.fromGeometry(geometry);\n      }\n    }\n\n    return this;\n  },\n  updateFromObject: function updateFromObject(object) {\n    var geometry = object.geometry;\n\n    if (object instanceof THREE.Mesh) {\n      var direct = geometry.__directGeometry;\n\n      if (direct === undefined) {\n        return this.fromGeometry(geometry);\n      }\n\n      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;\n      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;\n      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;\n      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;\n      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;\n      geometry.verticesNeedUpdate = false;\n      geometry.normalsNeedUpdate = false;\n      geometry.colorsNeedUpdate = false;\n      geometry.uvsNeedUpdate = false;\n      geometry.groupsNeedUpdate = false;\n      geometry = direct;\n    }\n\n    if (geometry.verticesNeedUpdate === true) {\n      var attribute = this.attributes.position;\n\n      if (attribute !== undefined) {\n        attribute.copyVector3sArray(geometry.vertices);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.verticesNeedUpdate = false;\n    }\n\n    if (geometry.normalsNeedUpdate === true) {\n      var attribute = this.attributes.normal;\n\n      if (attribute !== undefined) {\n        attribute.copyVector3sArray(geometry.normals);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.normalsNeedUpdate = false;\n    }\n\n    if (geometry.colorsNeedUpdate === true) {\n      var attribute = this.attributes.color;\n\n      if (attribute !== undefined) {\n        attribute.copyColorsArray(geometry.colors);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.colorsNeedUpdate = false;\n    }\n\n    if (geometry.lineDistancesNeedUpdate) {\n      var attribute = this.attributes.lineDistance;\n\n      if (attribute !== undefined) {\n        attribute.copyArray(geometry.lineDistances);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.lineDistancesNeedUpdate = false;\n    }\n\n    if (geometry.groupsNeedUpdate) {\n      geometry.computeGroups(object.geometry);\n      this.groups = geometry.groups;\n      geometry.groupsNeedUpdate = false;\n    }\n\n    return this;\n  },\n  fromGeometry: function fromGeometry(geometry) {\n    geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry(geometry);\n    return this.fromDirectGeometry(geometry.__directGeometry);\n  },\n  fromDirectGeometry: function fromDirectGeometry(geometry) {\n    var positions = new Float32Array(geometry.vertices.length * 3);\n    this.addAttribute('position', new THREE.BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      var normals = new Float32Array(geometry.normals.length * 3);\n      this.addAttribute('normal', new THREE.BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      var colors = new Float32Array(geometry.colors.length * 3);\n      this.addAttribute('color', new THREE.BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      var uvs = new Float32Array(geometry.uvs.length * 2);\n      this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      this.addAttribute('uv2', new THREE.BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    }\n\n    if (geometry.indices.length > 0) {\n      var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n      var indices = new TypeArray(geometry.indices.length * 3);\n      this.setIndex(new THREE.BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));\n    } // groups\n\n\n    this.groups = geometry.groups; // morphs\n\n    for (var name in geometry.morphTargets) {\n      var array = [];\n      var morphTargets = geometry.morphTargets[name];\n\n      for (var i = 0, l = morphTargets.length; i < l; i++) {\n        var morphTarget = morphTargets[i];\n        var attribute = new THREE.Float32Attribute(morphTarget.length * 3, 3);\n        array.push(attribute.copyVector3sArray(morphTarget));\n      }\n\n      this.morphAttributes[name] = array;\n    } // skinning\n\n\n    if (geometry.skinIndices.length > 0) {\n      var skinIndices = new THREE.Float32Attribute(geometry.skinIndices.length * 4, 4);\n      this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      var skinWeights = new THREE.Float32Attribute(geometry.skinWeights.length * 4, 4);\n      this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  },\n  computeBoundingBox: function () {\n    var vector = new THREE.Vector3();\n    return function () {\n      if (this.boundingBox === null) {\n        this.boundingBox = new THREE.Box3();\n      }\n\n      var positions = this.attributes.position.array;\n\n      if (positions) {\n        var bb = this.boundingBox;\n        bb.makeEmpty();\n\n        for (var i = 0, il = positions.length; i < il; i += 3) {\n          vector.fromArray(positions, i);\n          bb.expandByPoint(vector);\n        }\n      }\n\n      if (positions === undefined || positions.length === 0) {\n        this.boundingBox.min.set(0, 0, 0);\n        this.boundingBox.max.set(0, 0, 0);\n      }\n\n      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n        console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    };\n  }(),\n  computeBoundingSphere: function () {\n    var box = new THREE.Box3();\n    var vector = new THREE.Vector3();\n    return function () {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new THREE.Sphere();\n      }\n\n      var positions = this.attributes.position.array;\n\n      if (positions) {\n        box.makeEmpty();\n        var center = this.boundingSphere.center;\n\n        for (var i = 0, il = positions.length; i < il; i += 3) {\n          vector.fromArray(positions, i);\n          box.expandByPoint(vector);\n        }\n\n        box.center(center); // hoping to find a boundingSphere with a radius smaller than the\n        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n        var maxRadiusSq = 0;\n\n        for (var i = 0, il = positions.length; i < il; i += 3) {\n          vector.fromArray(positions, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n        }\n\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n        }\n      }\n    };\n  }(),\n  computeFaceNormals: function computeFaceNormals() {// backwards compatibility\n  },\n  computeVertexNormals: function computeVertexNormals() {\n    var index = this.index;\n    var attributes = this.attributes;\n    var groups = this.groups;\n\n    if (attributes.position) {\n      var positions = attributes.position.array;\n\n      if (attributes.normal === undefined) {\n        this.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(positions.length), 3));\n      } else {\n        // reset existing normals to zero\n        var normals = attributes.normal.array;\n\n        for (var i = 0, il = normals.length; i < il; i++) {\n          normals[i] = 0;\n        }\n      }\n\n      var normals = attributes.normal.array;\n      var vA,\n          vB,\n          vC,\n          pA = new THREE.Vector3(),\n          pB = new THREE.Vector3(),\n          pC = new THREE.Vector3(),\n          cb = new THREE.Vector3(),\n          ab = new THREE.Vector3(); // indexed elements\n\n      if (index) {\n        var indices = index.array;\n\n        if (groups.length === 0) {\n          this.addGroup(0, indices.length);\n        }\n\n        for (var j = 0, jl = groups.length; j < jl; ++j) {\n          var group = groups[j];\n          var start = group.start;\n          var count = group.count;\n\n          for (var i = start, il = start + count; i < il; i += 3) {\n            vA = indices[i + 0] * 3;\n            vB = indices[i + 1] * 3;\n            vC = indices[i + 2] * 3;\n            pA.fromArray(positions, vA);\n            pB.fromArray(positions, vB);\n            pC.fromArray(positions, vC);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            normals[vA] += cb.x;\n            normals[vA + 1] += cb.y;\n            normals[vA + 2] += cb.z;\n            normals[vB] += cb.x;\n            normals[vB + 1] += cb.y;\n            normals[vB + 2] += cb.z;\n            normals[vC] += cb.x;\n            normals[vC + 1] += cb.y;\n            normals[vC + 2] += cb.z;\n          }\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n        for (var i = 0, il = positions.length; i < il; i += 9) {\n          pA.fromArray(positions, i);\n          pB.fromArray(positions, i + 3);\n          pC.fromArray(positions, i + 6);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normals[i] = cb.x;\n          normals[i + 1] = cb.y;\n          normals[i + 2] = cb.z;\n          normals[i + 3] = cb.x;\n          normals[i + 4] = cb.y;\n          normals[i + 5] = cb.z;\n          normals[i + 6] = cb.x;\n          normals[i + 7] = cb.y;\n          normals[i + 8] = cb.z;\n        }\n      }\n\n      this.normalizeNormals();\n      attributes.normal.needsUpdate = true;\n    }\n  },\n  computeTangents: function computeTangents() {\n    console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');\n  },\n  computeOffsets: function computeOffsets(size) {\n    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');\n  },\n  merge: function merge(geometry, offset) {\n    if (geometry instanceof THREE.BufferGeometry === false) {\n      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\n      return;\n    }\n\n    if (offset === undefined) offset = 0;\n    var attributes = this.attributes;\n\n    for (var key in attributes) {\n      if (geometry.attributes[key] === undefined) continue;\n      var attribute1 = attributes[key];\n      var attributeArray1 = attribute1.array;\n      var attribute2 = geometry.attributes[key];\n      var attributeArray2 = attribute2.array;\n      var attributeSize = attribute2.itemSize;\n\n      for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {\n        attributeArray1[j] = attributeArray2[i];\n      }\n    }\n\n    return this;\n  },\n  normalizeNormals: function normalizeNormals() {\n    var normals = this.attributes.normal.array;\n    var x, y, z, n;\n\n    for (var i = 0, il = normals.length; i < il; i += 3) {\n      x = normals[i];\n      y = normals[i + 1];\n      z = normals[i + 2];\n      n = 1.0 / Math.sqrt(x * x + y * y + z * z);\n      normals[i] *= n;\n      normals[i + 1] *= n;\n      normals[i + 2] *= n;\n    }\n  },\n  toJSON: function toJSON() {\n    var data = {\n      metadata: {\n        version: 4.4,\n        type: 'BufferGeometry',\n        generator: 'BufferGeometry.toJSON'\n      }\n    }; // standard BufferGeometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n\n    if (this.parameters !== undefined) {\n      var parameters = this.parameters;\n\n      for (var key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    data.data = {\n      attributes: {}\n    };\n    var index = this.index;\n\n    if (index !== null) {\n      var array = Array.prototype.slice.call(index.array);\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: array\n      };\n    }\n\n    var attributes = this.attributes;\n\n    for (var key in attributes) {\n      var attribute = attributes[key];\n      var array = Array.prototype.slice.call(attribute.array);\n      data.data.attributes[key] = {\n        itemSize: attribute.itemSize,\n        type: attribute.array.constructor.name,\n        array: array\n      };\n    }\n\n    var groups = this.groups;\n\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n\n    var boundingSphere = this.boundingSphere;\n\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n\n    return data;\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(source) {\n    var index = source.index;\n\n    if (index !== null) {\n      this.setIndex(index.clone());\n    }\n\n    var attributes = source.attributes;\n\n    for (var name in attributes) {\n      var attribute = attributes[name];\n      this.addAttribute(name, attribute.clone());\n    }\n\n    var groups = source.groups;\n\n    for (var i = 0, l = groups.length; i < l; i++) {\n      var group = groups[i];\n      this.addGroup(group.start, group.count);\n    }\n\n    return this;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n};\nTHREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);\nTHREE.BufferGeometry.MaxIndex = 65535; // File:src/core/InstancedBufferGeometry.js\n\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\n\nTHREE.InstancedBufferGeometry = function () {\n  THREE.BufferGeometry.call(this);\n  this.type = 'InstancedBufferGeometry';\n  this.maxInstancedCount = undefined;\n};\n\nTHREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\n\nTHREE.InstancedBufferGeometry.prototype.addGroup = function (start, count, instances) {\n  this.groups.push({\n    start: start,\n    count: count,\n    instances: instances\n  });\n};\n\nTHREE.InstancedBufferGeometry.prototype.copy = function (source) {\n  var index = source.index;\n\n  if (index !== null) {\n    this.setIndex(index.clone());\n  }\n\n  var attributes = source.attributes;\n\n  for (var name in attributes) {\n    var attribute = attributes[name];\n    this.addAttribute(name, attribute.clone());\n  }\n\n  var groups = source.groups;\n\n  for (var i = 0, l = groups.length; i < l; i++) {\n    var group = groups[i];\n    this.addGroup(group.start, group.count, group.instances);\n  }\n\n  return this;\n};\n\nTHREE.EventDispatcher.prototype.apply(THREE.InstancedBufferGeometry.prototype); // File:src/cameras/Camera.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\n\nTHREE.Camera = function () {\n  THREE.Object3D.call(this);\n  this.type = 'Camera';\n  this.matrixWorldInverse = new THREE.Matrix4();\n  this.projectionMatrix = new THREE.Matrix4();\n};\n\nTHREE.Camera.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Camera.prototype.constructor = THREE.Camera;\n\nTHREE.Camera.prototype.getWorldDirection = function () {\n  var quaternion = new THREE.Quaternion();\n  return function (optionalTarget) {\n    var result = optionalTarget || new THREE.Vector3();\n    this.getWorldQuaternion(quaternion);\n    return result.set(0, 0, -1).applyQuaternion(quaternion);\n  };\n}();\n\nTHREE.Camera.prototype.lookAt = function () {\n  // This routine does not support cameras with rotated and/or translated parent(s)\n  var m1 = new THREE.Matrix4();\n  return function (vector) {\n    m1.lookAt(this.position, vector, this.up);\n    this.quaternion.setFromRotationMatrix(m1);\n  };\n}();\n\nTHREE.Camera.prototype.clone = function () {\n  return new this.constructor().copy(this);\n};\n\nTHREE.Camera.prototype.copy = function (source) {\n  THREE.Object3D.prototype.copy.call(this, source);\n  this.matrixWorldInverse.copy(source.matrixWorldInverse);\n  this.projectionMatrix.copy(source.projectionMatrix);\n  return this;\n}; // File:src/cameras/CubeCamera.js\n\n/**\r\n * Camera for rendering cube maps\r\n *\t- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.CubeCamera = function (near, far, cubeResolution) {\n  THREE.Object3D.call(this);\n  this.type = 'CubeCamera';\n  var fov = 90,\n      aspect = 1;\n  var cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  cameraPX.up.set(0, -1, 0);\n  cameraPX.lookAt(new THREE.Vector3(1, 0, 0));\n  this.add(cameraPX);\n  var cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  cameraNX.up.set(0, -1, 0);\n  cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));\n  this.add(cameraNX);\n  var cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  cameraPY.up.set(0, 0, 1);\n  cameraPY.lookAt(new THREE.Vector3(0, 1, 0));\n  this.add(cameraPY);\n  var cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  cameraNY.up.set(0, 0, -1);\n  cameraNY.lookAt(new THREE.Vector3(0, -1, 0));\n  this.add(cameraNY);\n  var cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  cameraPZ.up.set(0, -1, 0);\n  cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));\n  this.add(cameraPZ);\n  var cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  cameraNZ.up.set(0, -1, 0);\n  cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));\n  this.add(cameraNZ);\n  this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, {\n    format: THREE.RGBFormat,\n    magFilter: THREE.LinearFilter,\n    minFilter: THREE.LinearFilter\n  });\n\n  this.updateCubeMap = function (renderer, scene) {\n    if (this.parent === null) this.updateMatrixWorld();\n    var renderTarget = this.renderTarget;\n    var generateMipmaps = renderTarget.generateMipmaps;\n    renderTarget.generateMipmaps = false;\n    renderTarget.activeCubeFace = 0;\n    renderer.render(scene, cameraPX, renderTarget);\n    renderTarget.activeCubeFace = 1;\n    renderer.render(scene, cameraNX, renderTarget);\n    renderTarget.activeCubeFace = 2;\n    renderer.render(scene, cameraPY, renderTarget);\n    renderTarget.activeCubeFace = 3;\n    renderer.render(scene, cameraNY, renderTarget);\n    renderTarget.activeCubeFace = 4;\n    renderer.render(scene, cameraPZ, renderTarget);\n    renderTarget.generateMipmaps = generateMipmaps;\n    renderTarget.activeCubeFace = 5;\n    renderer.render(scene, cameraNZ, renderTarget);\n    renderer.setRenderTarget(null);\n  };\n};\n\nTHREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera; // File:src/cameras/OrthographicCamera.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.OrthographicCamera = function (left, right, top, bottom, near, far) {\n  THREE.Camera.call(this);\n  this.type = 'OrthographicCamera';\n  this.zoom = 1;\n  this.left = left;\n  this.right = right;\n  this.top = top;\n  this.bottom = bottom;\n  this.near = near !== undefined ? near : 0.1;\n  this.far = far !== undefined ? far : 2000;\n  this.updateProjectionMatrix();\n};\n\nTHREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);\nTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\n\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\n  var dx = (this.right - this.left) / (2 * this.zoom);\n  var dy = (this.top - this.bottom) / (2 * this.zoom);\n  var cx = (this.right + this.left) / 2;\n  var cy = (this.top + this.bottom) / 2;\n  this.projectionMatrix.makeOrthographic(cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far);\n};\n\nTHREE.OrthographicCamera.prototype.copy = function (source) {\n  THREE.Camera.prototype.copy.call(this, source);\n  this.left = source.left;\n  this.right = source.right;\n  this.top = source.top;\n  this.bottom = source.bottom;\n  this.near = source.near;\n  this.far = source.far;\n  this.zoom = source.zoom;\n  return this;\n};\n\nTHREE.OrthographicCamera.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta);\n  data.object.zoom = this.zoom;\n  data.object.left = this.left;\n  data.object.right = this.right;\n  data.object.top = this.top;\n  data.object.bottom = this.bottom;\n  data.object.near = this.near;\n  data.object.far = this.far;\n  return data;\n}; // File:src/cameras/PerspectiveCamera.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\n\n\nTHREE.PerspectiveCamera = function (fov, aspect, near, far) {\n  THREE.Camera.call(this);\n  this.type = 'PerspectiveCamera';\n  this.zoom = 1;\n  this.fov = fov !== undefined ? fov : 50;\n  this.aspect = aspect !== undefined ? aspect : 1;\n  this.near = near !== undefined ? near : 0.1;\n  this.far = far !== undefined ? far : 2000;\n  this.updateProjectionMatrix();\n};\n\nTHREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);\nTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\n/**\r\n * Uses Focal Length (in mm) to estimate and set FOV\r\n * 35mm (full-frame) camera is used if frame size is not specified;\r\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n */\n\nTHREE.PerspectiveCamera.prototype.setLens = function (focalLength, frameHeight) {\n  if (frameHeight === undefined) frameHeight = 24;\n  this.fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));\n  this.updateProjectionMatrix();\n};\n/**\r\n * Sets an offset in a larger frustum. This is useful for multi-window or\r\n * multi-monitor/multi-machine setups.\r\n *\r\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n * the monitors are in grid like this\r\n *\r\n *   +---+---+---+\r\n *   | A | B | C |\r\n *   +---+---+---+\r\n *   | D | E | F |\r\n *   +---+---+---+\r\n *\r\n * then for each monitor you would call it like this\r\n *\r\n *   var w = 1920;\r\n *   var h = 1080;\r\n *   var fullWidth = w * 3;\r\n *   var fullHeight = h * 2;\r\n *\r\n *   --A--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n *   --B--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n *   --C--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n *   --D--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n *   --E--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n *   --F--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n *\r\n *   Note there is no reason monitors have to be the same size or in a grid.\r\n */\n\n\nTHREE.PerspectiveCamera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {\n  this.fullWidth = fullWidth;\n  this.fullHeight = fullHeight;\n  this.x = x;\n  this.y = y;\n  this.width = width;\n  this.height = height;\n  this.updateProjectionMatrix();\n};\n\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\n  var fov = THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(this.fov) * 0.5) / this.zoom));\n\n  if (this.fullWidth) {\n    var aspect = this.fullWidth / this.fullHeight;\n    var top = Math.tan(THREE.Math.degToRad(fov * 0.5)) * this.near;\n    var bottom = -top;\n    var left = aspect * bottom;\n    var right = aspect * top;\n    var width = Math.abs(right - left);\n    var height = Math.abs(top - bottom);\n    this.projectionMatrix.makeFrustum(left + this.x * width / this.fullWidth, left + (this.x + this.width) * width / this.fullWidth, top - (this.y + this.height) * height / this.fullHeight, top - this.y * height / this.fullHeight, this.near, this.far);\n  } else {\n    this.projectionMatrix.makePerspective(fov, this.aspect, this.near, this.far);\n  }\n};\n\nTHREE.PerspectiveCamera.prototype.copy = function (source) {\n  THREE.Camera.prototype.copy.call(this, source);\n  this.fov = source.fov;\n  this.aspect = source.aspect;\n  this.near = source.near;\n  this.far = source.far;\n  this.zoom = source.zoom;\n  return this;\n};\n\nTHREE.PerspectiveCamera.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta);\n  data.object.zoom = this.zoom;\n  data.object.fov = this.fov;\n  data.object.aspect = this.aspect;\n  data.object.near = this.near;\n  data.object.far = this.far;\n  return data;\n}; // File:src/lights/Light.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.Light = function (color) {\n  THREE.Object3D.call(this);\n  this.type = 'Light';\n  this.color = new THREE.Color(color);\n};\n\nTHREE.Light.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Light.prototype.constructor = THREE.Light;\n\nTHREE.Light.prototype.copy = function (source) {\n  THREE.Object3D.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  return this;\n}; // File:src/lights/AmbientLight.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.AmbientLight = function (color) {\n  THREE.Light.call(this, color);\n  this.type = 'AmbientLight';\n};\n\nTHREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);\nTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\n\nTHREE.AmbientLight.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta);\n  data.object.color = this.color.getHex();\n  return data;\n}; // File:src/lights/DirectionalLight.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.DirectionalLight = function (color, intensity) {\n  THREE.Light.call(this, color);\n  this.type = 'DirectionalLight';\n  this.position.set(0, 1, 0);\n  this.updateMatrix();\n  this.target = new THREE.Object3D();\n  this.intensity = intensity !== undefined ? intensity : 1;\n  this.castShadow = false;\n  this.onlyShadow = false;\n  this.shadowCameraNear = 50;\n  this.shadowCameraFar = 5000;\n  this.shadowCameraLeft = -500;\n  this.shadowCameraRight = 500;\n  this.shadowCameraTop = 500;\n  this.shadowCameraBottom = -500;\n  this.shadowCameraVisible = false;\n  this.shadowBias = 0;\n  this.shadowDarkness = 0.5;\n  this.shadowMapWidth = 512;\n  this.shadowMapHeight = 512;\n  this.shadowMap = null;\n  this.shadowMapSize = null;\n  this.shadowCamera = null;\n  this.shadowMatrix = null;\n};\n\nTHREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);\nTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\n\nTHREE.DirectionalLight.prototype.copy = function (source) {\n  THREE.Light.prototype.copy.call(this, source);\n  this.intensity = source.intensity;\n  this.target = source.target.clone();\n  this.castShadow = source.castShadow;\n  this.onlyShadow = source.onlyShadow;\n  this.shadowCameraNear = source.shadowCameraNear;\n  this.shadowCameraFar = source.shadowCameraFar;\n  this.shadowCameraLeft = source.shadowCameraLeft;\n  this.shadowCameraRight = source.shadowCameraRight;\n  this.shadowCameraTop = source.shadowCameraTop;\n  this.shadowCameraBottom = source.shadowCameraBottom;\n  this.shadowCameraVisible = source.shadowCameraVisible;\n  this.shadowBias = source.shadowBias;\n  this.shadowDarkness = source.shadowDarkness;\n  this.shadowMapWidth = source.shadowMapWidth;\n  this.shadowMapHeight = source.shadowMapHeight;\n  return this;\n};\n\nTHREE.DirectionalLight.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta);\n  data.object.color = this.color.getHex();\n  data.object.intensity = this.intensity;\n  return data;\n}; // File:src/lights/HemisphereLight.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.HemisphereLight = function (skyColor, groundColor, intensity) {\n  THREE.Light.call(this, skyColor);\n  this.type = 'HemisphereLight';\n  this.position.set(0, 1, 0);\n  this.updateMatrix();\n  this.groundColor = new THREE.Color(groundColor);\n  this.intensity = intensity !== undefined ? intensity : 1;\n};\n\nTHREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);\nTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\n\nTHREE.HemisphereLight.prototype.copy = function (source) {\n  THREE.Light.prototype.copy.call(this, source);\n  this.groundColor.copy(source.groundColor);\n  this.intensity = source.intensity;\n  return this;\n};\n\nTHREE.HemisphereLight.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta);\n  data.object.color = this.color.getHex();\n  data.object.groundColor = this.groundColor.getHex();\n  data.object.intensity = this.intensity;\n  return data;\n}; // File:src/lights/PointLight.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.PointLight = function (color, intensity, distance, decay) {\n  THREE.Light.call(this, color);\n  this.type = 'PointLight';\n  this.intensity = intensity !== undefined ? intensity : 1;\n  this.distance = distance !== undefined ? distance : 0;\n  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.\n};\n\nTHREE.PointLight.prototype = Object.create(THREE.Light.prototype);\nTHREE.PointLight.prototype.constructor = THREE.PointLight;\n\nTHREE.PointLight.prototype.copy = function (source) {\n  THREE.Light.prototype.copy.call(this, source);\n  this.intensity = source.intensity;\n  this.distance = source.distance;\n  this.decay = source.decay;\n  return this;\n};\n\nTHREE.PointLight.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta);\n  data.object.color = this.color.getHex();\n  data.object.intensity = this.intensity;\n  data.object.distance = this.distance;\n  data.object.decay = this.decay;\n  return data;\n}; // File:src/lights/SpotLight.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.SpotLight = function (color, intensity, distance, angle, exponent, decay) {\n  THREE.Light.call(this, color);\n  this.type = 'SpotLight';\n  this.position.set(0, 1, 0);\n  this.updateMatrix();\n  this.target = new THREE.Object3D();\n  this.intensity = intensity !== undefined ? intensity : 1;\n  this.distance = distance !== undefined ? distance : 0;\n  this.angle = angle !== undefined ? angle : Math.PI / 3;\n  this.exponent = exponent !== undefined ? exponent : 10;\n  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.\n\n  this.castShadow = false;\n  this.onlyShadow = false;\n  this.shadowCameraNear = 50;\n  this.shadowCameraFar = 5000;\n  this.shadowCameraFov = 50;\n  this.shadowCameraVisible = false;\n  this.shadowBias = 0;\n  this.shadowDarkness = 0.5;\n  this.shadowMapWidth = 512;\n  this.shadowMapHeight = 512;\n  this.shadowMap = null;\n  this.shadowMapSize = null;\n  this.shadowCamera = null;\n  this.shadowMatrix = null;\n};\n\nTHREE.SpotLight.prototype = Object.create(THREE.Light.prototype);\nTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\n\nTHREE.SpotLight.prototype.copy = function (source) {\n  THREE.Light.prototype.copy.call(this, source);\n  this.intensity = source.intensity;\n  this.distance = source.distance;\n  this.angle = source.angle;\n  this.exponent = source.exponent;\n  this.decay = source.decay;\n  this.target = source.target.clone();\n  this.castShadow = source.castShadow;\n  this.onlyShadow = source.onlyShadow;\n  this.shadowCameraNear = source.shadowCameraNear;\n  this.shadowCameraFar = source.shadowCameraFar;\n  this.shadowCameraFov = source.shadowCameraFov;\n  this.shadowCameraVisible = source.shadowCameraVisible;\n  this.shadowBias = source.shadowBias;\n  this.shadowDarkness = source.shadowDarkness;\n  this.shadowMapWidth = source.shadowMapWidth;\n  this.shadowMapHeight = source.shadowMapHeight;\n  return this;\n};\n\nTHREE.SpotLight.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta);\n  data.object.color = this.color.getHex();\n  data.object.intensity = this.intensity;\n  data.object.distance = this.distance;\n  data.object.angle = this.angle;\n  data.object.exponent = this.exponent;\n  data.object.decay = this.decay;\n  return data;\n}; // File:src/loaders/Cache.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.Cache = {\n  enabled: false,\n  files: {},\n  add: function add(key, file) {\n    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );\n\n    this.files[key] = file;\n  },\n  get: function get(key) {\n    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );\n\n    return this.files[key];\n  },\n  remove: function remove(key) {\n    delete this.files[key];\n  },\n  clear: function clear() {\n    this.files = {};\n  }\n}; // File:src/loaders/Loader.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.Loader = function () {\n  this.onLoadStart = function () {};\n\n  this.onLoadProgress = function () {};\n\n  this.onLoadComplete = function () {};\n};\n\nTHREE.Loader.prototype = {\n  constructor: THREE.Loader,\n  crossOrigin: undefined,\n  extractUrlBase: function extractUrlBase(url) {\n    var parts = url.split('/');\n    if (parts.length === 1) return './';\n    parts.pop();\n    return parts.join('/') + '/';\n  },\n  initMaterials: function initMaterials(materials, texturePath, crossOrigin) {\n    var array = [];\n\n    for (var i = 0; i < materials.length; ++i) {\n      array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);\n    }\n\n    return array;\n  },\n  createMaterial: function () {\n    var imageLoader;\n    return function createMaterial(m, texturePath, crossOrigin) {\n      var scope = this;\n      if (crossOrigin === undefined && scope.crossOrigin !== undefined) crossOrigin = scope.crossOrigin;\n      if (imageLoader === undefined) imageLoader = new THREE.ImageLoader();\n\n      function nearest_pow2(n) {\n        var l = Math.log(n) / Math.LN2;\n        return Math.pow(2, Math.round(l));\n      }\n\n      function create_texture(where, name, sourceFile, repeat, offset, wrap, anisotropy) {\n        var fullPath = texturePath + sourceFile;\n        var texture;\n        var loader = THREE.Loader.Handlers.get(fullPath);\n\n        if (loader !== null) {\n          texture = loader.load(fullPath);\n        } else {\n          texture = new THREE.Texture();\n          loader = imageLoader;\n          loader.setCrossOrigin(crossOrigin);\n          loader.load(fullPath, function (image) {\n            if (THREE.Math.isPowerOfTwo(image.width) === false || THREE.Math.isPowerOfTwo(image.height) === false) {\n              var width = nearest_pow2(image.width);\n              var height = nearest_pow2(image.height);\n              var canvas = document.createElement('canvas');\n              canvas.width = width;\n              canvas.height = height;\n              var context = canvas.getContext('2d');\n              context.drawImage(image, 0, 0, width, height);\n              texture.image = canvas;\n            } else {\n              texture.image = image;\n            }\n\n            texture.needsUpdate = true;\n          });\n        }\n\n        texture.sourceFile = sourceFile;\n\n        if (repeat) {\n          texture.repeat.set(repeat[0], repeat[1]);\n          if (repeat[0] !== 1) texture.wrapS = THREE.RepeatWrapping;\n          if (repeat[1] !== 1) texture.wrapT = THREE.RepeatWrapping;\n        }\n\n        if (offset) {\n          texture.offset.set(offset[0], offset[1]);\n        }\n\n        if (wrap) {\n          var wrapMap = {\n            'repeat': THREE.RepeatWrapping,\n            'mirror': THREE.MirroredRepeatWrapping\n          };\n          if (wrapMap[wrap[0]] !== undefined) texture.wrapS = wrapMap[wrap[0]];\n          if (wrapMap[wrap[1]] !== undefined) texture.wrapT = wrapMap[wrap[1]];\n        }\n\n        if (anisotropy) {\n          texture.anisotropy = anisotropy;\n        }\n\n        where[name] = texture;\n      }\n\n      function rgb2hex(rgb) {\n        return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255;\n      } // defaults\n\n\n      var mtype = 'MeshLambertMaterial';\n      var mpars = {}; // parameters from model file\n\n      if (m.shading) {\n        var shading = m.shading.toLowerCase();\n        if (shading === 'phong') mtype = 'MeshPhongMaterial';else if (shading === 'basic') mtype = 'MeshBasicMaterial';\n      }\n\n      if (m.blending !== undefined && THREE[m.blending] !== undefined) {\n        mpars.blending = THREE[m.blending];\n      }\n\n      if (m.transparent !== undefined) {\n        mpars.transparent = m.transparent;\n      }\n\n      if (m.opacity !== undefined && m.opacity < 1.0) {\n        mpars.transparent = true;\n      }\n\n      if (m.depthTest !== undefined) {\n        mpars.depthTest = m.depthTest;\n      }\n\n      if (m.depthWrite !== undefined) {\n        mpars.depthWrite = m.depthWrite;\n      }\n\n      if (m.visible !== undefined) {\n        mpars.visible = m.visible;\n      }\n\n      if (m.flipSided !== undefined) {\n        mpars.side = THREE.BackSide;\n      }\n\n      if (m.doubleSided !== undefined) {\n        mpars.side = THREE.DoubleSide;\n      }\n\n      if (m.wireframe !== undefined) {\n        mpars.wireframe = m.wireframe;\n      }\n\n      if (m.vertexColors !== undefined) {\n        if (m.vertexColors === 'face') {\n          mpars.vertexColors = THREE.FaceColors;\n        } else if (m.vertexColors) {\n          mpars.vertexColors = THREE.VertexColors;\n        }\n      } // colors\n\n\n      if (m.colorDiffuse) {\n        mpars.color = rgb2hex(m.colorDiffuse);\n      } else if (m.DbgColor) {\n        mpars.color = m.DbgColor;\n      }\n\n      if (m.colorEmissive) {\n        mpars.emissive = rgb2hex(m.colorEmissive);\n      }\n\n      if (mtype === 'MeshPhongMaterial') {\n        if (m.colorSpecular) {\n          mpars.specular = rgb2hex(m.colorSpecular);\n        }\n\n        if (m.specularCoef) {\n          mpars.shininess = m.specularCoef;\n        }\n      } // modifiers\n\n\n      if (m.transparency !== undefined) {\n        console.warn('THREE.Loader: transparency has been renamed to opacity');\n        m.opacity = m.transparency;\n      }\n\n      if (m.opacity !== undefined) {\n        mpars.opacity = m.opacity;\n      } // textures\n\n\n      if (texturePath) {\n        if (m.mapDiffuse) {\n          create_texture(mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);\n        }\n\n        if (m.mapLight) {\n          create_texture(mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);\n        }\n\n        if (m.mapAO) {\n          create_texture(mpars, 'aoMap', m.mapAO, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);\n        }\n\n        if (m.mapBump) {\n          create_texture(mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);\n        }\n\n        if (m.mapNormal) {\n          create_texture(mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);\n        }\n\n        if (m.mapSpecular) {\n          create_texture(mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);\n        }\n\n        if (m.mapAlpha) {\n          create_texture(mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);\n        }\n      } //\n\n\n      if (m.mapBumpScale) {\n        mpars.bumpScale = m.mapBumpScale;\n      }\n\n      if (m.mapNormalFactor) {\n        mpars.normalScale = new THREE.Vector2(m.mapNormalFactor, m.mapNormalFactor);\n      }\n\n      var material = new THREE[mtype](mpars);\n      if (m.DbgName !== undefined) material.name = m.DbgName;\n      return material;\n    };\n  }()\n};\nTHREE.Loader.Handlers = {\n  handlers: [],\n  add: function add(regex, loader) {\n    this.handlers.push(regex, loader);\n  },\n  get: function get(file) {\n    for (var i = 0, l = this.handlers.length; i < l; i += 2) {\n      var regex = this.handlers[i];\n      var loader = this.handlers[i + 1];\n\n      if (regex.test(file)) {\n        return loader;\n      }\n    }\n\n    return null;\n  }\n}; // File:src/loaders/XHRLoader.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.XHRLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTHREE.XHRLoader.prototype = {\n  constructor: THREE.XHRLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var cached = THREE.Cache.get(url);\n\n    if (cached !== undefined) {\n      if (onLoad) {\n        setTimeout(function () {\n          onLoad(cached);\n        }, 0);\n      }\n\n      return cached;\n    }\n\n    var request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.addEventListener('load', function (event) {\n      THREE.Cache.add(url, this.response);\n      if (onLoad) onLoad(this.response);\n      scope.manager.itemEnd(url);\n    }, false);\n\n    if (onProgress !== undefined) {\n      request.addEventListener('progress', function (event) {\n        onProgress(event);\n      }, false);\n    }\n\n    request.addEventListener('error', function (event) {\n      if (onError) onError(event);\n      scope.manager.itemError(url);\n    }, false);\n    if (this.crossOrigin !== undefined) request.crossOrigin = this.crossOrigin;\n    if (this.responseType !== undefined) request.responseType = this.responseType;\n    if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;\n    request.send(null);\n    scope.manager.itemStart(url);\n    return request;\n  },\n  setResponseType: function setResponseType(value) {\n    this.responseType = value;\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n  },\n  setWithCredentials: function setWithCredentials(value) {\n    this.withCredentials = value;\n  }\n}; // File:src/loaders/ImageLoader.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.ImageLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTHREE.ImageLoader.prototype = {\n  constructor: THREE.ImageLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var cached = THREE.Cache.get(url);\n\n    if (cached !== undefined) {\n      if (onLoad) {\n        setTimeout(function () {\n          onLoad(cached);\n        }, 0);\n      }\n\n      return cached;\n    }\n\n    var image = document.createElement('img');\n    image.addEventListener('load', function (event) {\n      THREE.Cache.add(url, this);\n      if (onLoad) onLoad(this);\n      scope.manager.itemEnd(url);\n    }, false);\n\n    if (onProgress !== undefined) {\n      image.addEventListener('progress', function (event) {\n        onProgress(event);\n      }, false);\n    }\n\n    image.addEventListener('error', function (event) {\n      if (onError) onError(event);\n      scope.manager.itemError(url);\n    }, false);\n    if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;\n    scope.manager.itemStart(url);\n    image.src = url;\n    return image;\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n  }\n}; // File:src/loaders/JSONLoader.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.JSONLoader = function (manager) {\n  if (typeof manager === 'boolean') {\n    console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');\n    manager = undefined;\n  }\n\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n  this.withCredentials = false;\n};\n\nTHREE.JSONLoader.prototype = {\n  constructor: THREE.JSONLoader,\n\n  // Deprecated\n  get statusDomElement() {\n    if (this._statusDomElement === undefined) {\n      this._statusDomElement = document.createElement('div');\n    }\n\n    console.warn('THREE.JSONLoader: .statusDomElement has been removed.');\n    return this._statusDomElement;\n  },\n\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texturePath = this.texturePath && typeof this.texturePath === \"string\" ? this.texturePath : THREE.Loader.prototype.extractUrlBase(url);\n    var loader = new THREE.XHRLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      var json = JSON.parse(text);\n      var metadata = json.metadata;\n\n      if (metadata !== undefined) {\n        if (metadata.type === 'object') {\n          console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');\n          return;\n        }\n\n        if (metadata.type === 'scene') {\n          console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');\n          return;\n        }\n      }\n\n      var object = scope.parse(json, texturePath);\n      onLoad(object.geometry, object.materials);\n    });\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n  },\n  setTexturePath: function setTexturePath(value) {\n    this.texturePath = value;\n  },\n  parse: function parse(json, texturePath) {\n    var geometry = new THREE.Geometry(),\n        scale = json.scale !== undefined ? 1.0 / json.scale : 1.0;\n    parseModel(scale);\n    parseSkin();\n    parseMorphing(scale);\n    geometry.computeFaceNormals();\n    geometry.computeBoundingSphere();\n\n    function parseModel(scale) {\n      function isBitSet(value, position) {\n        return value & 1 << position;\n      }\n\n      var i,\n          j,\n          fi,\n          offset,\n          zLength,\n          colorIndex,\n          normalIndex,\n          uvIndex,\n          materialIndex,\n          type,\n          isQuad,\n          hasMaterial,\n          hasFaceVertexUv,\n          hasFaceNormal,\n          hasFaceVertexNormal,\n          hasFaceColor,\n          hasFaceVertexColor,\n          vertex,\n          face,\n          faceA,\n          faceB,\n          hex,\n          normal,\n          uvLayer,\n          uv,\n          u,\n          v,\n          faces = json.faces,\n          vertices = json.vertices,\n          normals = json.normals,\n          colors = json.colors,\n          nUvLayers = 0;\n\n      if (json.uvs !== undefined) {\n        // disregard empty arrays\n        for (i = 0; i < json.uvs.length; i++) {\n          if (json.uvs[i].length) nUvLayers++;\n        }\n\n        for (i = 0; i < nUvLayers; i++) {\n          geometry.faceVertexUvs[i] = [];\n        }\n      }\n\n      offset = 0;\n      zLength = vertices.length;\n\n      while (offset < zLength) {\n        vertex = new THREE.Vector3();\n        vertex.x = vertices[offset++] * scale;\n        vertex.y = vertices[offset++] * scale;\n        vertex.z = vertices[offset++] * scale;\n        geometry.vertices.push(vertex);\n      }\n\n      offset = 0;\n      zLength = faces.length;\n\n      while (offset < zLength) {\n        type = faces[offset++];\n        isQuad = isBitSet(type, 0);\n        hasMaterial = isBitSet(type, 1);\n        hasFaceVertexUv = isBitSet(type, 3);\n        hasFaceNormal = isBitSet(type, 4);\n        hasFaceVertexNormal = isBitSet(type, 5);\n        hasFaceColor = isBitSet(type, 6);\n        hasFaceVertexColor = isBitSet(type, 7); // console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n        if (isQuad) {\n          faceA = new THREE.Face3();\n          faceA.a = faces[offset];\n          faceA.b = faces[offset + 1];\n          faceA.c = faces[offset + 3];\n          faceB = new THREE.Face3();\n          faceB.a = faces[offset + 1];\n          faceB.b = faces[offset + 2];\n          faceB.c = faces[offset + 3];\n          offset += 4;\n\n          if (hasMaterial) {\n            materialIndex = faces[offset++];\n            faceA.materialIndex = materialIndex;\n            faceB.materialIndex = materialIndex;\n          } // to get face <=> uv index correspondence\n\n\n          fi = geometry.faces.length;\n\n          if (hasFaceVertexUv) {\n            for (i = 0; i < nUvLayers; i++) {\n              uvLayer = json.uvs[i];\n              geometry.faceVertexUvs[i][fi] = [];\n              geometry.faceVertexUvs[i][fi + 1] = [];\n\n              for (j = 0; j < 4; j++) {\n                uvIndex = faces[offset++];\n                u = uvLayer[uvIndex * 2];\n                v = uvLayer[uvIndex * 2 + 1];\n                uv = new THREE.Vector2(u, v);\n                if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);\n                if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);\n              }\n            }\n          }\n\n          if (hasFaceNormal) {\n            normalIndex = faces[offset++] * 3;\n            faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n            faceB.normal.copy(faceA.normal);\n          }\n\n          if (hasFaceVertexNormal) {\n            for (i = 0; i < 4; i++) {\n              normalIndex = faces[offset++] * 3;\n              normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n              if (i !== 2) faceA.vertexNormals.push(normal);\n              if (i !== 0) faceB.vertexNormals.push(normal);\n            }\n          }\n\n          if (hasFaceColor) {\n            colorIndex = faces[offset++];\n            hex = colors[colorIndex];\n            faceA.color.setHex(hex);\n            faceB.color.setHex(hex);\n          }\n\n          if (hasFaceVertexColor) {\n            for (i = 0; i < 4; i++) {\n              colorIndex = faces[offset++];\n              hex = colors[colorIndex];\n              if (i !== 2) faceA.vertexColors.push(new THREE.Color(hex));\n              if (i !== 0) faceB.vertexColors.push(new THREE.Color(hex));\n            }\n          }\n\n          geometry.faces.push(faceA);\n          geometry.faces.push(faceB);\n        } else {\n          face = new THREE.Face3();\n          face.a = faces[offset++];\n          face.b = faces[offset++];\n          face.c = faces[offset++];\n\n          if (hasMaterial) {\n            materialIndex = faces[offset++];\n            face.materialIndex = materialIndex;\n          } // to get face <=> uv index correspondence\n\n\n          fi = geometry.faces.length;\n\n          if (hasFaceVertexUv) {\n            for (i = 0; i < nUvLayers; i++) {\n              uvLayer = json.uvs[i];\n              geometry.faceVertexUvs[i][fi] = [];\n\n              for (j = 0; j < 3; j++) {\n                uvIndex = faces[offset++];\n                u = uvLayer[uvIndex * 2];\n                v = uvLayer[uvIndex * 2 + 1];\n                uv = new THREE.Vector2(u, v);\n                geometry.faceVertexUvs[i][fi].push(uv);\n              }\n            }\n          }\n\n          if (hasFaceNormal) {\n            normalIndex = faces[offset++] * 3;\n            face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n          }\n\n          if (hasFaceVertexNormal) {\n            for (i = 0; i < 3; i++) {\n              normalIndex = faces[offset++] * 3;\n              normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n              face.vertexNormals.push(normal);\n            }\n          }\n\n          if (hasFaceColor) {\n            colorIndex = faces[offset++];\n            face.color.setHex(colors[colorIndex]);\n          }\n\n          if (hasFaceVertexColor) {\n            for (i = 0; i < 3; i++) {\n              colorIndex = faces[offset++];\n              face.vertexColors.push(new THREE.Color(colors[colorIndex]));\n            }\n          }\n\n          geometry.faces.push(face);\n        }\n      }\n    }\n\n    ;\n\n    function parseSkin() {\n      var influencesPerVertex = json.influencesPerVertex !== undefined ? json.influencesPerVertex : 2;\n\n      if (json.skinWeights) {\n        for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {\n          var x = json.skinWeights[i];\n          var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;\n          var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;\n          var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;\n          geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));\n        }\n      }\n\n      if (json.skinIndices) {\n        for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {\n          var a = json.skinIndices[i];\n          var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;\n          var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;\n          var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;\n          geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));\n        }\n      }\n\n      geometry.bones = json.bones;\n\n      if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {\n        console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');\n      } // could change this to json.animations[0] or remove completely\n\n\n      geometry.animation = json.animation;\n      geometry.animations = json.animations;\n    }\n\n    ;\n\n    function parseMorphing(scale) {\n      if (json.morphTargets !== undefined) {\n        var i, l, v, vl, dstVertices, srcVertices;\n\n        for (i = 0, l = json.morphTargets.length; i < l; i++) {\n          geometry.morphTargets[i] = {};\n          geometry.morphTargets[i].name = json.morphTargets[i].name;\n          geometry.morphTargets[i].vertices = [];\n          dstVertices = geometry.morphTargets[i].vertices;\n          srcVertices = json.morphTargets[i].vertices;\n\n          for (v = 0, vl = srcVertices.length; v < vl; v += 3) {\n            var vertex = new THREE.Vector3();\n            vertex.x = srcVertices[v] * scale;\n            vertex.y = srcVertices[v + 1] * scale;\n            vertex.z = srcVertices[v + 2] * scale;\n            dstVertices.push(vertex);\n          }\n        }\n      }\n\n      if (json.morphColors !== undefined) {\n        var i, l, c, cl, dstColors, srcColors, color;\n\n        for (i = 0, l = json.morphColors.length; i < l; i++) {\n          geometry.morphColors[i] = {};\n          geometry.morphColors[i].name = json.morphColors[i].name;\n          geometry.morphColors[i].colors = [];\n          dstColors = geometry.morphColors[i].colors;\n          srcColors = json.morphColors[i].colors;\n\n          for (c = 0, cl = srcColors.length; c < cl; c += 3) {\n            color = new THREE.Color(0xffaa00);\n            color.setRGB(srcColors[c], srcColors[c + 1], srcColors[c + 2]);\n            dstColors.push(color);\n          }\n        }\n      }\n    }\n\n    ;\n\n    if (json.materials === undefined || json.materials.length === 0) {\n      return {\n        geometry: geometry\n      };\n    } else {\n      var materials = THREE.Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);\n      return {\n        geometry: geometry,\n        materials: materials\n      };\n    }\n  }\n}; // File:src/loaders/LoadingManager.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.LoadingManager = function (onLoad, onProgress, onError) {\n  var scope = this;\n  var isLoading = false,\n      itemsLoaded = 0,\n      itemsTotal = 0;\n  this.onStart = undefined;\n  this.onLoad = onLoad;\n  this.onProgress = onProgress;\n  this.onError = onError;\n\n  this.itemStart = function (url) {\n    itemsTotal++;\n\n    if (isLoading === false) {\n      if (scope.onStart !== undefined) {\n        scope.onStart(url, itemsLoaded, itemsTotal);\n      }\n    }\n\n    isLoading = true;\n  };\n\n  this.itemEnd = function (url) {\n    itemsLoaded++;\n\n    if (scope.onProgress !== undefined) {\n      scope.onProgress(url, itemsLoaded, itemsTotal);\n    }\n\n    if (itemsLoaded === itemsTotal) {\n      isLoading = false;\n\n      if (scope.onLoad !== undefined) {\n        scope.onLoad();\n      }\n    }\n  };\n\n  this.itemError = function (url) {\n    if (scope.onError !== undefined) {\n      scope.onError(url);\n    }\n  };\n};\n\nTHREE.DefaultLoadingManager = new THREE.LoadingManager(); // File:src/loaders/BufferGeometryLoader.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.BufferGeometryLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTHREE.BufferGeometryLoader.prototype = {\n  constructor: THREE.BufferGeometryLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new THREE.XHRLoader(scope.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.load(url, function (text) {\n      onLoad(scope.parse(JSON.parse(text)));\n    }, onProgress, onError);\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n  },\n  parse: function parse(json) {\n    var geometry = new THREE.BufferGeometry();\n    var index = json.data.index;\n\n    if (index !== undefined) {\n      var typedArray = new self[index.type](index.array);\n      geometry.setIndex(new THREE.BufferAttribute(typedArray, 1));\n    }\n\n    var attributes = json.data.attributes;\n\n    for (var key in attributes) {\n      var attribute = attributes[key];\n      var typedArray = new self[attribute.type](attribute.array);\n      geometry.addAttribute(key, new THREE.BufferAttribute(typedArray, attribute.itemSize));\n    }\n\n    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n    if (groups !== undefined) {\n      for (var i = 0, n = groups.length; i !== n; ++i) {\n        var group = groups[i];\n        geometry.addGroup(group.start, group.count);\n      }\n    }\n\n    var boundingSphere = json.data.boundingSphere;\n\n    if (boundingSphere !== undefined) {\n      var center = new THREE.Vector3();\n\n      if (boundingSphere.center !== undefined) {\n        center.fromArray(boundingSphere.center);\n      }\n\n      geometry.boundingSphere = new THREE.Sphere(center, boundingSphere.radius);\n    }\n\n    return geometry;\n  }\n}; // File:src/loaders/MaterialLoader.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.MaterialLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n  this.textures = {};\n};\n\nTHREE.MaterialLoader.prototype = {\n  constructor: THREE.MaterialLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new THREE.XHRLoader(scope.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.load(url, function (text) {\n      onLoad(scope.parse(JSON.parse(text)));\n    }, onProgress, onError);\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n  },\n  setTextures: function setTextures(value) {\n    this.textures = value;\n  },\n  getTexture: function getTexture(name) {\n    var textures = this.textures;\n\n    if (textures[name] === undefined) {\n      console.warn('THREE.MaterialLoader: Undefined texture', name);\n    }\n\n    return textures[name];\n  },\n  parse: function parse(json) {\n    var material = new THREE[json.type]();\n    material.uuid = json.uuid;\n    if (json.name !== undefined) material.name = json.name;\n    if (json.color !== undefined) material.color.setHex(json.color);\n    if (json.emissive !== undefined) material.emissive.setHex(json.emissive);\n    if (json.specular !== undefined) material.specular.setHex(json.specular);\n    if (json.shininess !== undefined) material.shininess = json.shininess;\n    if (json.uniforms !== undefined) material.uniforms = json.uniforms;\n    if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;\n    if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;\n    if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;\n    if (json.shading !== undefined) material.shading = json.shading;\n    if (json.blending !== undefined) material.blending = json.blending;\n    if (json.side !== undefined) material.side = json.side;\n    if (json.opacity !== undefined) material.opacity = json.opacity;\n    if (json.transparent !== undefined) material.transparent = json.transparent;\n    if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;\n    if (json.depthTest !== undefined) material.depthTest = json.depthTest;\n    if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;\n    if (json.wireframe !== undefined) material.wireframe = json.wireframe;\n    if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth; // for PointsMaterial\n\n    if (json.size !== undefined) material.size = json.size;\n    if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps\n\n    if (json.map !== undefined) material.map = this.getTexture(json.map);\n\n    if (json.alphaMap !== undefined) {\n      material.alphaMap = this.getTexture(json.alphaMap);\n      material.transparent = true;\n    }\n\n    if (json.bumpMap !== undefined) material.bumpMap = this.getTexture(json.bumpMap);\n    if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;\n    if (json.normalMap !== undefined) material.normalMap = this.getTexture(json.normalMap);\n    if (json.normalScale) material.normalScale = new THREE.Vector2(json.normalScale, json.normalScale);\n    if (json.displacementMap !== undefined) material.displacementMap = this.getTexture(json.displacementMap);\n    if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;\n    if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;\n    if (json.specularMap !== undefined) material.specularMap = this.getTexture(json.specularMap);\n\n    if (json.envMap !== undefined) {\n      material.envMap = this.getTexture(json.envMap);\n      material.combine = THREE.MultiplyOperation;\n    }\n\n    if (json.reflectivity) material.reflectivity = json.reflectivity;\n    if (json.lightMap !== undefined) material.lightMap = this.getTexture(json.lightMap);\n    if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;\n    if (json.aoMap !== undefined) material.aoMap = this.getTexture(json.aoMap);\n    if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity; // MeshFaceMaterial\n\n    if (json.materials !== undefined) {\n      for (var i = 0, l = json.materials.length; i < l; i++) {\n        material.materials.push(this.parse(json.materials[i]));\n      }\n    }\n\n    return material;\n  }\n}; // File:src/loaders/ObjectLoader.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.ObjectLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n  this.texturePath = '';\n};\n\nTHREE.ObjectLoader.prototype = {\n  constructor: THREE.ObjectLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    if (this.texturePath === '') {\n      this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);\n    }\n\n    var scope = this;\n    var loader = new THREE.XHRLoader(scope.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.load(url, function (text) {\n      scope.parse(JSON.parse(text), onLoad);\n    }, onProgress, onError);\n  },\n  setTexturePath: function setTexturePath(value) {\n    this.texturePath = value;\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n  },\n  parse: function parse(json, onLoad) {\n    var geometries = this.parseGeometries(json.geometries);\n    var images = this.parseImages(json.images, function () {\n      if (onLoad !== undefined) onLoad(object);\n    });\n    var textures = this.parseTextures(json.textures, images);\n    var materials = this.parseMaterials(json.materials, textures);\n    var object = this.parseObject(json.object, geometries, materials);\n\n    if (json.images === undefined || json.images.length === 0) {\n      if (onLoad !== undefined) onLoad(object);\n    }\n\n    return object;\n  },\n  parseGeometries: function parseGeometries(json) {\n    var geometries = {};\n\n    if (json !== undefined) {\n      var geometryLoader = new THREE.JSONLoader();\n      var bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\n      for (var i = 0, l = json.length; i < l; i++) {\n        var geometry;\n        var data = json[i];\n\n        switch (data.type) {\n          case 'PlaneGeometry':\n          case 'PlaneBufferGeometry':\n            geometry = new THREE[data.type](data.width, data.height, data.widthSegments, data.heightSegments);\n            break;\n\n          case 'BoxGeometry':\n          case 'CubeGeometry':\n            // backwards compatible\n            geometry = new THREE.BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n            break;\n\n          case 'CircleBufferGeometry':\n            geometry = new THREE.CircleBufferGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);\n            break;\n\n          case 'CircleGeometry':\n            geometry = new THREE.CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);\n            break;\n\n          case 'CylinderGeometry':\n            geometry = new THREE.CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n            break;\n\n          case 'SphereGeometry':\n            geometry = new THREE.SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n            break;\n\n          case 'SphereBufferGeometry':\n            geometry = new THREE.SphereBufferGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n            break;\n\n          case 'DodecahedronGeometry':\n            geometry = new THREE.DodecahedronGeometry(data.radius, data.detail);\n            break;\n\n          case 'IcosahedronGeometry':\n            geometry = new THREE.IcosahedronGeometry(data.radius, data.detail);\n            break;\n\n          case 'OctahedronGeometry':\n            geometry = new THREE.OctahedronGeometry(data.radius, data.detail);\n            break;\n\n          case 'TetrahedronGeometry':\n            geometry = new THREE.TetrahedronGeometry(data.radius, data.detail);\n            break;\n\n          case 'RingGeometry':\n            geometry = new THREE.RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);\n            break;\n\n          case 'TorusGeometry':\n            geometry = new THREE.TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);\n            break;\n\n          case 'TorusKnotGeometry':\n            geometry = new THREE.TorusKnotGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.p, data.q, data.heightScale);\n            break;\n\n          case 'TextGeometry':\n            geometry = new THREE.TextGeometry(data.text, data.data);\n            break;\n\n          case 'BufferGeometry':\n            geometry = bufferGeometryLoader.parse(data);\n            break;\n\n          case 'Geometry':\n            geometry = geometryLoader.parse(data.data, this.texturePath).geometry;\n            break;\n\n          default:\n            console.warn('THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"');\n            continue;\n        }\n\n        geometry.uuid = data.uuid;\n        if (data.name !== undefined) geometry.name = data.name;\n        geometries[data.uuid] = geometry;\n      }\n    }\n\n    return geometries;\n  },\n  parseMaterials: function parseMaterials(json, textures) {\n    var materials = {};\n\n    if (json !== undefined) {\n      var loader = new THREE.MaterialLoader();\n      loader.setTextures(textures);\n\n      for (var i = 0, l = json.length; i < l; i++) {\n        var material = loader.parse(json[i]);\n        materials[material.uuid] = material;\n      }\n    }\n\n    return materials;\n  },\n  parseImages: function parseImages(json, onLoad) {\n    var scope = this;\n    var images = {};\n\n    function loadImage(url) {\n      scope.manager.itemStart(url);\n      return loader.load(url, function () {\n        scope.manager.itemEnd(url);\n      });\n    }\n\n    if (json !== undefined && json.length > 0) {\n      var manager = new THREE.LoadingManager(onLoad);\n      var loader = new THREE.ImageLoader(manager);\n      loader.setCrossOrigin(this.crossOrigin);\n\n      for (var i = 0, l = json.length; i < l; i++) {\n        var image = json[i];\n        var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;\n        images[image.uuid] = loadImage(path);\n      }\n    }\n\n    return images;\n  },\n  parseTextures: function parseTextures(json, images) {\n    function parseConstant(value) {\n      if (typeof value === 'number') return value;\n      console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);\n      return THREE[value];\n    }\n\n    var textures = {};\n\n    if (json !== undefined) {\n      for (var i = 0, l = json.length; i < l; i++) {\n        var data = json[i];\n\n        if (data.image === undefined) {\n          console.warn('THREE.ObjectLoader: No \"image\" specified for', data.uuid);\n        }\n\n        if (images[data.image] === undefined) {\n          console.warn('THREE.ObjectLoader: Undefined image', data.image);\n        }\n\n        var texture = new THREE.Texture(images[data.image]);\n        texture.needsUpdate = true;\n        texture.uuid = data.uuid;\n        if (data.name !== undefined) texture.name = data.name;\n        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping);\n        if (data.offset !== undefined) texture.offset = new THREE.Vector2(data.offset[0], data.offset[1]);\n        if (data.repeat !== undefined) texture.repeat = new THREE.Vector2(data.repeat[0], data.repeat[1]);\n        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter);\n        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter);\n        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;\n\n        if (Array.isArray(data.wrap)) {\n          texture.wrapS = parseConstant(data.wrap[0]);\n          texture.wrapT = parseConstant(data.wrap[1]);\n        }\n\n        textures[data.uuid] = texture;\n      }\n    }\n\n    return textures;\n  },\n  parseObject: function () {\n    var matrix = new THREE.Matrix4();\n    return function (data, geometries, materials) {\n      var object;\n\n      var getGeometry = function getGeometry(name) {\n        if (geometries[name] === undefined) {\n          console.warn('THREE.ObjectLoader: Undefined geometry', name);\n        }\n\n        return geometries[name];\n      };\n\n      var getMaterial = function getMaterial(name) {\n        if (materials[name] === undefined) {\n          console.warn('THREE.ObjectLoader: Undefined material', name);\n        }\n\n        return materials[name];\n      };\n\n      switch (data.type) {\n        case 'Scene':\n          object = new THREE.Scene();\n          break;\n\n        case 'PerspectiveCamera':\n          object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);\n          break;\n\n        case 'OrthographicCamera':\n          object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);\n          break;\n\n        case 'AmbientLight':\n          object = new THREE.AmbientLight(data.color);\n          break;\n\n        case 'DirectionalLight':\n          object = new THREE.DirectionalLight(data.color, data.intensity);\n          break;\n\n        case 'PointLight':\n          object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);\n          break;\n\n        case 'SpotLight':\n          object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay);\n          break;\n\n        case 'HemisphereLight':\n          object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);\n          break;\n\n        case 'Mesh':\n          object = new THREE.Mesh(getGeometry(data.geometry), getMaterial(data.material));\n          break;\n\n        case 'LOD':\n          object = new THREE.LOD();\n          break;\n\n        case 'Line':\n          object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);\n          break;\n\n        case 'PointCloud':\n        case 'Points':\n          object = new THREE.Points(getGeometry(data.geometry), getMaterial(data.material));\n          break;\n\n        case 'Sprite':\n          object = new THREE.Sprite(getMaterial(data.material));\n          break;\n\n        case 'Group':\n          object = new THREE.Group();\n          break;\n\n        default:\n          object = new THREE.Object3D();\n      }\n\n      object.uuid = data.uuid;\n      if (data.name !== undefined) object.name = data.name;\n\n      if (data.matrix !== undefined) {\n        matrix.fromArray(data.matrix);\n        matrix.decompose(object.position, object.quaternion, object.scale);\n      } else {\n        if (data.position !== undefined) object.position.fromArray(data.position);\n        if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);\n        if (data.scale !== undefined) object.scale.fromArray(data.scale);\n      }\n\n      if (data.castShadow !== undefined) object.castShadow = data.castShadow;\n      if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;\n      if (data.visible !== undefined) object.visible = data.visible;\n      if (data.userData !== undefined) object.userData = data.userData;\n\n      if (data.children !== undefined) {\n        for (var child in data.children) {\n          object.add(this.parseObject(data.children[child], geometries, materials));\n        }\n      }\n\n      if (data.type === 'LOD') {\n        var levels = data.levels;\n\n        for (var l = 0; l < levels.length; l++) {\n          var level = levels[l];\n          var child = object.getObjectByProperty('uuid', level.object);\n\n          if (child !== undefined) {\n            object.addLevel(child, level.distance);\n          }\n        }\n      }\n\n      return object;\n    };\n  }()\n}; // File:src/loaders/TextureLoader.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.TextureLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTHREE.TextureLoader.prototype = {\n  constructor: THREE.TextureLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new THREE.ImageLoader(scope.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.load(url, function (image) {\n      var texture = new THREE.Texture(image);\n      texture.needsUpdate = true;\n\n      if (onLoad !== undefined) {\n        onLoad(texture);\n      }\n    }, onProgress, onError);\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n  }\n}; // File:src/loaders/BinaryTextureLoader.js\n\n/**\r\n * @author Nikos M. / https://github.com/foo123/\r\n *\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n */\n\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager; // override in sub classes\n\n  this._parser = null;\n};\n\nTHREE.BinaryTextureLoader.prototype = {\n  constructor: THREE.BinaryTextureLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new THREE.DataTexture();\n    var loader = new THREE.XHRLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (buffer) {\n      var texData = scope._parser(buffer);\n\n      if (!texData) return;\n\n      if (undefined !== texData.image) {\n        texture.image = texData.image;\n      } else if (undefined !== texData.data) {\n        texture.image.width = texData.width;\n        texture.image.height = texData.height;\n        texture.image.data = texData.data;\n      }\n\n      texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\n      texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\n      texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\n      texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\n      texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n      if (undefined !== texData.format) {\n        texture.format = texData.format;\n      }\n\n      if (undefined !== texData.type) {\n        texture.type = texData.type;\n      }\n\n      if (undefined !== texData.mipmaps) {\n        texture.mipmaps = texData.mipmaps;\n      }\n\n      if (1 === texData.mipmapCount) {\n        texture.minFilter = THREE.LinearFilter;\n      }\n\n      texture.needsUpdate = true;\n      if (onLoad) onLoad(texture, texData);\n    }, onProgress, onError);\n    return texture;\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n  }\n}; // File:src/loaders/CompressedTextureLoader.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n */\n\nTHREE.CompressedTextureLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager; // override in sub classes\n\n  this._parser = null;\n};\n\nTHREE.CompressedTextureLoader.prototype = {\n  constructor: THREE.CompressedTextureLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var images = [];\n    var texture = new THREE.CompressedTexture();\n    texture.image = images;\n    var loader = new THREE.XHRLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setResponseType('arraybuffer');\n\n    if (Array.isArray(url)) {\n      var loaded = 0;\n\n      var loadTexture = function loadTexture(i) {\n        loader.load(url[i], function (buffer) {\n          var texDatas = scope._parser(buffer, true);\n\n          images[i] = {\n            width: texDatas.width,\n            height: texDatas.height,\n            format: texDatas.format,\n            mipmaps: texDatas.mipmaps\n          };\n          loaded += 1;\n\n          if (loaded === 6) {\n            if (texDatas.mipmapCount === 1) texture.minFilter = THREE.LinearFilter;\n            texture.format = texDatas.format;\n            texture.needsUpdate = true;\n            if (onLoad) onLoad(texture);\n          }\n        }, onProgress, onError);\n      };\n\n      for (var i = 0, il = url.length; i < il; ++i) {\n        loadTexture(i);\n      }\n    } else {\n      // compressed cubemap texture stored in a single DDS file\n      loader.load(url, function (buffer) {\n        var texDatas = scope._parser(buffer, true);\n\n        if (texDatas.isCubemap) {\n          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n          for (var f = 0; f < faces; f++) {\n            images[f] = {\n              mipmaps: []\n            };\n\n            for (var i = 0; i < texDatas.mipmapCount; i++) {\n              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);\n              images[f].format = texDatas.format;\n              images[f].width = texDatas.width;\n              images[f].height = texDatas.height;\n            }\n          }\n        } else {\n          texture.image.width = texDatas.width;\n          texture.image.height = texDatas.height;\n          texture.mipmaps = texDatas.mipmaps;\n        }\n\n        if (texDatas.mipmapCount === 1) {\n          texture.minFilter = THREE.LinearFilter;\n        }\n\n        texture.format = texDatas.format;\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onProgress, onError);\n    }\n\n    return texture;\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n  }\n}; // File:src/materials/Material.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.Material = function () {\n  Object.defineProperty(this, 'id', {\n    value: THREE.MaterialIdCount++\n  });\n  this.uuid = THREE.Math.generateUUID();\n  this.name = '';\n  this.type = 'Material';\n  this.side = THREE.FrontSide;\n  this.opacity = 1;\n  this.transparent = false;\n  this.blending = THREE.NormalBlending;\n  this.blendSrc = THREE.SrcAlphaFactor;\n  this.blendDst = THREE.OneMinusSrcAlphaFactor;\n  this.blendEquation = THREE.AddEquation;\n  this.blendSrcAlpha = null;\n  this.blendDstAlpha = null;\n  this.blendEquationAlpha = null;\n  this.depthFunc = THREE.LessEqualDepth;\n  this.depthTest = true;\n  this.depthWrite = true;\n  this.colorWrite = true;\n  this.precision = null; // override the renderer's default precision for this material\n\n  this.polygonOffset = false;\n  this.polygonOffsetFactor = 0;\n  this.polygonOffsetUnits = 0;\n  this.alphaTest = 0;\n  this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n  this.visible = true;\n  this._needsUpdate = true;\n};\n\nTHREE.Material.prototype = {\n  constructor: THREE.Material,\n\n  get needsUpdate() {\n    return this._needsUpdate;\n  },\n\n  set needsUpdate(value) {\n    if (value === true) this.update();\n    this._needsUpdate = value;\n  },\n\n  setValues: function setValues(values) {\n    if (values === undefined) return;\n\n    for (var key in values) {\n      var newValue = values[key];\n\n      if (newValue === undefined) {\n        console.warn(\"THREE.Material: '\" + key + \"' parameter is undefined.\");\n        continue;\n      }\n\n      var currentValue = this[key];\n\n      if (currentValue === undefined) {\n        console.warn(\"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\");\n        continue;\n      }\n\n      if (currentValue instanceof THREE.Color) {\n        currentValue.set(newValue);\n      } else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {\n        currentValue.copy(newValue);\n      } else if (key === 'overdraw') {\n        // ensure overdraw is backwards-compatible with legacy boolean type\n        this[key] = Number(newValue);\n      } else {\n        this[key] = newValue;\n      }\n    }\n  },\n  toJSON: function toJSON(meta) {\n    var data = {\n      metadata: {\n        version: 4.4,\n        type: 'Material',\n        generator: 'Material.toJSON'\n      }\n    }; // standard Material serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (this.color instanceof THREE.Color) data.color = this.color.getHex();\n    if (this.emissive instanceof THREE.Color) data.emissive = this.emissive.getHex();\n    if (this.specular instanceof THREE.Color) data.specular = this.specular.getHex();\n    if (this.shininess !== undefined) data.shininess = this.shininess;\n    if (this.map instanceof THREE.Texture) data.map = this.map.toJSON(meta).uuid;\n    if (this.alphaMap instanceof THREE.Texture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n    if (this.lightMap instanceof THREE.Texture) data.lightMap = this.lightMap.toJSON(meta).uuid;\n\n    if (this.bumpMap instanceof THREE.Texture) {\n      data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n      data.bumpScale = this.bumpScale;\n    }\n\n    if (this.normalMap instanceof THREE.Texture) {\n      data.normalMap = this.normalMap.toJSON(meta).uuid;\n      data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js\n    }\n\n    if (this.displacementMap instanceof THREE.Texture) {\n      data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n      data.displacementScale = this.displacementScale;\n      data.displacementBias = this.displacementBias;\n    }\n\n    if (this.specularMap instanceof THREE.Texture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n\n    if (this.envMap instanceof THREE.Texture) {\n      data.envMap = this.envMap.toJSON(meta).uuid;\n      data.reflectivity = this.reflectivity; // Scale behind envMap\n    }\n\n    if (this.size !== undefined) data.size = this.size;\n    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;\n    if (this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors) data.vertexColors = this.vertexColors;\n    if (this.shading !== undefined && this.shading !== THREE.SmoothShading) data.shading = this.shading;\n    if (this.blending !== undefined && this.blending !== THREE.NormalBlending) data.blending = this.blending;\n    if (this.side !== undefined && this.side !== THREE.FrontSide) data.side = this.side;\n    if (this.opacity < 1) data.opacity = this.opacity;\n    if (this.transparent === true) data.transparent = this.transparent;\n    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n    if (this.wireframe === true) data.wireframe = this.wireframe;\n    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n    return data;\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(source) {\n    this.name = source.name;\n    this.side = source.side;\n    this.opacity = source.opacity;\n    this.transparent = source.transparent;\n    this.blending = source.blending;\n    this.blendSrc = source.blendSrc;\n    this.blendDst = source.blendDst;\n    this.blendEquation = source.blendEquation;\n    this.blendSrcAlpha = source.blendSrcAlpha;\n    this.blendDstAlpha = source.blendDstAlpha;\n    this.blendEquationAlpha = source.blendEquationAlpha;\n    this.depthFunc = source.depthFunc;\n    this.depthTest = source.depthTest;\n    this.depthWrite = source.depthWrite;\n    this.precision = source.precision;\n    this.polygonOffset = source.polygonOffset;\n    this.polygonOffsetFactor = source.polygonOffsetFactor;\n    this.polygonOffsetUnits = source.polygonOffsetUnits;\n    this.alphaTest = source.alphaTest;\n    this.overdraw = source.overdraw;\n    this.visible = source.visible;\n    return this;\n  },\n  update: function update() {\n    this.dispatchEvent({\n      type: 'update'\n    });\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  },\n\n  // Deprecated\n  get wrapAround() {\n    console.warn('THREE.' + this.type + ': .wrapAround has been removed.');\n  },\n\n  set wrapAround(boolean) {\n    console.warn('THREE.' + this.type + ': .wrapAround has been removed.');\n  },\n\n  get wrapRGB() {\n    console.warn('THREE.' + this.type + ': .wrapRGB has been removed.');\n    return new THREE.Color();\n  }\n\n};\nTHREE.EventDispatcher.prototype.apply(THREE.Material.prototype);\nTHREE.MaterialIdCount = 0; // File:src/materials/LineBasicMaterial.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\",\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\n\nTHREE.LineBasicMaterial = function (parameters) {\n  THREE.Material.call(this);\n  this.type = 'LineBasicMaterial';\n  this.color = new THREE.Color(0xffffff);\n  this.linewidth = 1;\n  this.linecap = 'round';\n  this.linejoin = 'round';\n  this.vertexColors = THREE.NoColors;\n  this.fog = true;\n  this.setValues(parameters);\n};\n\nTHREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\n\nTHREE.LineBasicMaterial.prototype.copy = function (source) {\n  THREE.Material.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  this.linewidth = source.linewidth;\n  this.linecap = source.linecap;\n  this.linejoin = source.linejoin;\n  this.vertexColors = source.vertexColors;\n  this.fog = source.fog;\n  return this;\n}; // File:src/materials/LineDashedMaterial.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\n\n\nTHREE.LineDashedMaterial = function (parameters) {\n  THREE.Material.call(this);\n  this.type = 'LineDashedMaterial';\n  this.color = new THREE.Color(0xffffff);\n  this.linewidth = 1;\n  this.scale = 1;\n  this.dashSize = 3;\n  this.gapSize = 1;\n  this.vertexColors = false;\n  this.fog = true;\n  this.setValues(parameters);\n};\n\nTHREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\n\nTHREE.LineDashedMaterial.prototype.copy = function (source) {\n  THREE.Material.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  this.linewidth = source.linewidth;\n  this.scale = source.scale;\n  this.dashSize = source.dashSize;\n  this.gapSize = source.gapSize;\n  this.vertexColors = source.vertexColors;\n  this.fog = source.fog;\n  return this;\n}; // File:src/materials/MeshBasicMaterial.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\n\n\nTHREE.MeshBasicMaterial = function (parameters) {\n  THREE.Material.call(this);\n  this.type = 'MeshBasicMaterial';\n  this.color = new THREE.Color(0xffffff); // emissive\n\n  this.map = null;\n  this.aoMap = null;\n  this.aoMapIntensity = 1.0;\n  this.specularMap = null;\n  this.alphaMap = null;\n  this.envMap = null;\n  this.combine = THREE.MultiplyOperation;\n  this.reflectivity = 1;\n  this.refractionRatio = 0.98;\n  this.fog = true;\n  this.shading = THREE.SmoothShading;\n  this.wireframe = false;\n  this.wireframeLinewidth = 1;\n  this.wireframeLinecap = 'round';\n  this.wireframeLinejoin = 'round';\n  this.vertexColors = THREE.NoColors;\n  this.skinning = false;\n  this.morphTargets = false;\n  this.setValues(parameters);\n};\n\nTHREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\n\nTHREE.MeshBasicMaterial.prototype.copy = function (source) {\n  THREE.Material.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  this.map = source.map;\n  this.aoMap = source.aoMap;\n  this.aoMapIntensity = source.aoMapIntensity;\n  this.specularMap = source.specularMap;\n  this.alphaMap = source.alphaMap;\n  this.envMap = source.envMap;\n  this.combine = source.combine;\n  this.reflectivity = source.reflectivity;\n  this.refractionRatio = source.refractionRatio;\n  this.fog = source.fog;\n  this.shading = source.shading;\n  this.wireframe = source.wireframe;\n  this.wireframeLinewidth = source.wireframeLinewidth;\n  this.wireframeLinecap = source.wireframeLinecap;\n  this.wireframeLinejoin = source.wireframeLinejoin;\n  this.vertexColors = source.vertexColors;\n  this.skinning = source.skinning;\n  this.morphTargets = source.morphTargets;\n  return this;\n}; // File:src/materials/MeshLambertMaterial.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  emissive: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\n\n\nTHREE.MeshLambertMaterial = function (parameters) {\n  THREE.Material.call(this);\n  this.type = 'MeshLambertMaterial';\n  this.color = new THREE.Color(0xffffff); // diffuse\n\n  this.emissive = new THREE.Color(0x000000);\n  this.map = null;\n  this.specularMap = null;\n  this.alphaMap = null;\n  this.envMap = null;\n  this.combine = THREE.MultiplyOperation;\n  this.reflectivity = 1;\n  this.refractionRatio = 0.98;\n  this.fog = true;\n  this.wireframe = false;\n  this.wireframeLinewidth = 1;\n  this.wireframeLinecap = 'round';\n  this.wireframeLinejoin = 'round';\n  this.vertexColors = THREE.NoColors;\n  this.skinning = false;\n  this.morphTargets = false;\n  this.morphNormals = false;\n  this.setValues(parameters);\n};\n\nTHREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\n\nTHREE.MeshLambertMaterial.prototype.copy = function (source) {\n  THREE.Material.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  this.emissive.copy(source.emissive);\n  this.map = source.map;\n  this.specularMap = source.specularMap;\n  this.alphaMap = source.alphaMap;\n  this.envMap = source.envMap;\n  this.combine = source.combine;\n  this.reflectivity = source.reflectivity;\n  this.refractionRatio = source.refractionRatio;\n  this.fog = source.fog;\n  this.wireframe = source.wireframe;\n  this.wireframeLinewidth = source.wireframeLinewidth;\n  this.wireframeLinecap = source.wireframeLinecap;\n  this.wireframeLinejoin = source.wireframeLinejoin;\n  this.vertexColors = source.vertexColors;\n  this.skinning = source.skinning;\n  this.morphTargets = source.morphTargets;\n  this.morphNormals = source.morphNormals;\n  return this;\n}; // File:src/materials/MeshPhongMaterial.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  emissive: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\n\n\nTHREE.MeshPhongMaterial = function (parameters) {\n  THREE.Material.call(this);\n  this.type = 'MeshPhongMaterial';\n  this.color = new THREE.Color(0xffffff); // diffuse\n\n  this.emissive = new THREE.Color(0x000000);\n  this.specular = new THREE.Color(0x111111);\n  this.shininess = 30;\n  this.metal = false;\n  this.map = null;\n  this.lightMap = null;\n  this.lightMapIntensity = 1.0;\n  this.aoMap = null;\n  this.aoMapIntensity = 1.0;\n  this.emissiveMap = null;\n  this.bumpMap = null;\n  this.bumpScale = 1;\n  this.normalMap = null;\n  this.normalScale = new THREE.Vector2(1, 1);\n  this.displacementMap = null;\n  this.displacementScale = 1;\n  this.displacementBias = 0;\n  this.specularMap = null;\n  this.alphaMap = null;\n  this.envMap = null;\n  this.combine = THREE.MultiplyOperation;\n  this.reflectivity = 1;\n  this.refractionRatio = 0.98;\n  this.fog = true;\n  this.shading = THREE.SmoothShading;\n  this.wireframe = false;\n  this.wireframeLinewidth = 1;\n  this.wireframeLinecap = 'round';\n  this.wireframeLinejoin = 'round';\n  this.vertexColors = THREE.NoColors;\n  this.skinning = false;\n  this.morphTargets = false;\n  this.morphNormals = false;\n  this.setValues(parameters);\n};\n\nTHREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\n\nTHREE.MeshPhongMaterial.prototype.copy = function (source) {\n  THREE.Material.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  this.emissive.copy(source.emissive);\n  this.specular.copy(source.specular);\n  this.shininess = source.shininess;\n  this.metal = source.metal;\n  this.map = source.map;\n  this.lightMap = source.lightMap;\n  this.lightMapIntensity = source.lightMapIntensity;\n  this.aoMap = source.aoMap;\n  this.aoMapIntensity = source.aoMapIntensity;\n  this.emissiveMap = source.emissiveMap;\n  this.bumpMap = source.bumpMap;\n  this.bumpScale = source.bumpScale;\n  this.normalMap = source.normalMap;\n  this.normalScale.copy(source.normalScale);\n  this.displacementMap = source.displacementMap;\n  this.displacementScale = source.displacementScale;\n  this.displacementBias = source.displacementBias;\n  this.specularMap = source.specularMap;\n  this.alphaMap = source.alphaMap;\n  this.envMap = source.envMap;\n  this.combine = source.combine;\n  this.reflectivity = source.reflectivity;\n  this.refractionRatio = source.refractionRatio;\n  this.fog = source.fog;\n  this.shading = source.shading;\n  this.wireframe = source.wireframe;\n  this.wireframeLinewidth = source.wireframeLinewidth;\n  this.wireframeLinecap = source.wireframeLinecap;\n  this.wireframeLinejoin = source.wireframeLinejoin;\n  this.vertexColors = source.vertexColors;\n  this.skinning = source.skinning;\n  this.morphTargets = source.morphTargets;\n  this.morphNormals = source.morphNormals;\n  return this;\n}; // File:src/materials/MeshDepthMaterial.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\n\n\nTHREE.MeshDepthMaterial = function (parameters) {\n  THREE.Material.call(this);\n  this.type = 'MeshDepthMaterial';\n  this.morphTargets = false;\n  this.wireframe = false;\n  this.wireframeLinewidth = 1;\n  this.setValues(parameters);\n};\n\nTHREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\n\nTHREE.MeshDepthMaterial.prototype.copy = function (source) {\n  THREE.Material.prototype.copy.call(this, source);\n  this.wireframe = source.wireframe;\n  this.wireframeLinewidth = source.wireframeLinewidth;\n  return this;\n}; // File:src/materials/MeshNormalMaterial.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  shading: THREE.FlatShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\n\n\nTHREE.MeshNormalMaterial = function (parameters) {\n  THREE.Material.call(this, parameters);\n  this.type = 'MeshNormalMaterial';\n  this.wireframe = false;\n  this.wireframeLinewidth = 1;\n  this.morphTargets = false;\n  this.setValues(parameters);\n};\n\nTHREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\n\nTHREE.MeshNormalMaterial.prototype.copy = function (source) {\n  THREE.Material.prototype.copy.call(this, source);\n  this.wireframe = source.wireframe;\n  this.wireframeLinewidth = source.wireframeLinewidth;\n  return this;\n}; // File:src/materials/MultiMaterial.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.MultiMaterial = function (materials) {\n  this.uuid = THREE.Math.generateUUID();\n  this.type = 'MultiMaterial';\n  this.materials = materials instanceof Array ? materials : [];\n  this.visible = true;\n};\n\nTHREE.MultiMaterial.prototype = {\n  constructor: THREE.MultiMaterial,\n  toJSON: function toJSON() {\n    var output = {\n      metadata: {\n        version: 4.2,\n        type: 'material',\n        generator: 'MaterialExporter'\n      },\n      uuid: this.uuid,\n      type: this.type,\n      materials: []\n    };\n\n    for (var i = 0, l = this.materials.length; i < l; i++) {\n      output.materials.push(this.materials[i].toJSON());\n    }\n\n    output.visible = this.visible;\n    return output;\n  },\n  clone: function clone() {\n    var material = new this.constructor();\n\n    for (var i = 0; i < this.materials.length; i++) {\n      material.materials.push(this.materials[i].clone());\n    }\n\n    material.visible = this.visible;\n    return material;\n  }\n}; // backwards compatibility\n\nTHREE.MeshFaceMaterial = THREE.MultiMaterial; // File:src/materials/PointsMaterial.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *  sizeAttenuation: <bool>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\n\nTHREE.PointsMaterial = function (parameters) {\n  THREE.Material.call(this);\n  this.type = 'PointsMaterial';\n  this.color = new THREE.Color(0xffffff);\n  this.map = null;\n  this.size = 1;\n  this.sizeAttenuation = true;\n  this.vertexColors = THREE.NoColors;\n  this.fog = true;\n  this.setValues(parameters);\n};\n\nTHREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\n\nTHREE.PointsMaterial.prototype.copy = function (source) {\n  THREE.Material.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  this.map = source.map;\n  this.size = source.size;\n  this.sizeAttenuation = source.sizeAttenuation;\n  this.vertexColors = source.vertexColors;\n  this.fog = source.fog;\n  return this;\n}; // backwards compatibility\n\n\nTHREE.PointCloudMaterial = function (parameters) {\n  console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');\n  return new THREE.PointsMaterial(parameters);\n};\n\nTHREE.ParticleBasicMaterial = function (parameters) {\n  console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');\n  return new THREE.PointsMaterial(parameters);\n};\n\nTHREE.ParticleSystemMaterial = function (parameters) {\n  console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');\n  return new THREE.PointsMaterial(parameters);\n}; // File:src/materials/ShaderMaterial.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\n\n\nTHREE.ShaderMaterial = function (parameters) {\n  THREE.Material.call(this);\n  this.type = 'ShaderMaterial';\n  this.defines = {};\n  this.uniforms = {};\n  this.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n  this.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n  this.shading = THREE.SmoothShading;\n  this.linewidth = 1;\n  this.wireframe = false;\n  this.wireframeLinewidth = 1;\n  this.fog = false; // set to use scene fog\n\n  this.lights = false; // set to use scene lights\n\n  this.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\n\n  this.skinning = false; // set to use skinning attribute streams\n\n  this.morphTargets = false; // set to use morph targets\n\n  this.morphNormals = false; // set to use morph normals\n\n  this.derivatives = false; // set to use derivatives\n  // When rendered geometry doesn't include these attributes but the material does,\n  // use these default values in WebGL. This avoids errors when buffer data is missing.\n\n  this.defaultAttributeValues = {\n    'color': [1, 1, 1],\n    'uv': [0, 0],\n    'uv2': [0, 0]\n  };\n  this.index0AttributeName = undefined;\n\n  if (parameters !== undefined) {\n    if (parameters.attributes !== undefined) {\n      console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\n    }\n\n    this.setValues(parameters);\n  }\n};\n\nTHREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\n\nTHREE.ShaderMaterial.prototype.copy = function (source) {\n  THREE.Material.prototype.copy.call(this, source);\n  this.fragmentShader = source.fragmentShader;\n  this.vertexShader = source.vertexShader;\n  this.uniforms = THREE.UniformsUtils.clone(source.uniforms);\n  this.attributes = source.attributes;\n  this.defines = source.defines;\n  this.shading = source.shading;\n  this.wireframe = source.wireframe;\n  this.wireframeLinewidth = source.wireframeLinewidth;\n  this.fog = source.fog;\n  this.lights = source.lights;\n  this.vertexColors = source.vertexColors;\n  this.skinning = source.skinning;\n  this.morphTargets = source.morphTargets;\n  this.morphNormals = source.morphNormals;\n  this.derivatives = source.derivatives;\n  return this;\n};\n\nTHREE.ShaderMaterial.prototype.toJSON = function (meta) {\n  var data = THREE.Material.prototype.toJSON.call(this, meta);\n  data.uniforms = this.uniforms;\n  data.attributes = this.attributes;\n  data.vertexShader = this.vertexShader;\n  data.fragmentShader = this.fragmentShader;\n  return data;\n}; // File:src/materials/RawShaderMaterial.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.RawShaderMaterial = function (parameters) {\n  THREE.ShaderMaterial.call(this, parameters);\n  this.type = 'RawShaderMaterial';\n};\n\nTHREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial; // File:src/materials/SpriteMaterial.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *\tuvOffset: new THREE.Vector2(),\r\n *\tuvScale: new THREE.Vector2(),\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\n\nTHREE.SpriteMaterial = function (parameters) {\n  THREE.Material.call(this);\n  this.type = 'SpriteMaterial';\n  this.color = new THREE.Color(0xffffff);\n  this.map = null;\n  this.rotation = 0;\n  this.fog = false; // set parameters\n\n  this.setValues(parameters);\n};\n\nTHREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\n\nTHREE.SpriteMaterial.prototype.copy = function (source) {\n  THREE.Material.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  this.map = source.map;\n  this.rotation = source.rotation;\n  this.fog = source.fog;\n  return this;\n}; // File:src/textures/Texture.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\n\n\nTHREE.Texture = function (image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n  Object.defineProperty(this, 'id', {\n    value: THREE.TextureIdCount++\n  });\n  this.uuid = THREE.Math.generateUUID();\n  this.name = '';\n  this.sourceFile = '';\n  this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\n  this.mipmaps = [];\n  this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\n  this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n  this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n  this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n  this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n  this.format = format !== undefined ? format : THREE.RGBAFormat;\n  this.type = type !== undefined ? type : THREE.UnsignedByteType;\n  this.offset = new THREE.Vector2(0, 0);\n  this.repeat = new THREE.Vector2(1, 1);\n  this.generateMipmaps = true;\n  this.premultiplyAlpha = false;\n  this.flipY = true;\n  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n  this.version = 0;\n  this.onUpdate = null;\n};\n\nTHREE.Texture.DEFAULT_IMAGE = undefined;\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\nTHREE.Texture.prototype = {\n  constructor: THREE.Texture,\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  },\n\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(source) {\n    this.image = source.image;\n    this.mipmaps = source.mipmaps.slice(0);\n    this.mapping = source.mapping;\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n    this.anisotropy = source.anisotropy;\n    this.format = source.format;\n    this.type = source.type;\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.generateMipmaps = source.generateMipmaps;\n    this.premultiplyAlpha = source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    this.unpackAlignment = source.unpackAlignment;\n    return this;\n  },\n  toJSON: function toJSON(meta) {\n    if (meta.textures[this.uuid] !== undefined) {\n      return meta.textures[this.uuid];\n    }\n\n    function getDataURL(image) {\n      var canvas;\n\n      if (image.toDataURL !== undefined) {\n        canvas = image;\n      } else {\n        canvas = document.createElement('canvas');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);\n      }\n\n      if (canvas.width > 2048 || canvas.height > 2048) {\n        return canvas.toDataURL('image/jpeg', 0.6);\n      } else {\n        return canvas.toDataURL('image/png');\n      }\n    }\n\n    var output = {\n      metadata: {\n        version: 4.4,\n        type: 'Texture',\n        generator: 'Texture.toJSON'\n      },\n      uuid: this.uuid,\n      name: this.name,\n      mapping: this.mapping,\n      repeat: [this.repeat.x, this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      wrap: [this.wrapS, this.wrapT],\n      minFilter: this.minFilter,\n      magFilter: this.magFilter,\n      anisotropy: this.anisotropy\n    };\n\n    if (this.image !== undefined) {\n      // TODO: Move to THREE.Image\n      var image = this.image;\n\n      if (image.uuid === undefined) {\n        image.uuid = THREE.Math.generateUUID(); // UGH\n      }\n\n      if (meta.images[image.uuid] === undefined) {\n        meta.images[image.uuid] = {\n          uuid: image.uuid,\n          url: getDataURL(image)\n        };\n      }\n\n      output.image = image.uuid;\n    }\n\n    meta.textures[this.uuid] = output;\n    return output;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  },\n  transformUv: function transformUv(uv) {\n    if (this.mapping !== THREE.UVMapping) return;\n    uv.multiply(this.repeat);\n    uv.add(this.offset);\n\n    if (uv.x < 0 || uv.x > 1) {\n      switch (this.wrapS) {\n        case THREE.RepeatWrapping:\n          uv.x = uv.x - Math.floor(uv.x);\n          break;\n\n        case THREE.ClampToEdgeWrapping:\n          uv.x = uv.x < 0 ? 0 : 1;\n          break;\n\n        case THREE.MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n            uv.x = Math.ceil(uv.x) - uv.x;\n          } else {\n            uv.x = uv.x - Math.floor(uv.x);\n          }\n\n          break;\n      }\n    }\n\n    if (uv.y < 0 || uv.y > 1) {\n      switch (this.wrapT) {\n        case THREE.RepeatWrapping:\n          uv.y = uv.y - Math.floor(uv.y);\n          break;\n\n        case THREE.ClampToEdgeWrapping:\n          uv.y = uv.y < 0 ? 0 : 1;\n          break;\n\n        case THREE.MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n            uv.y = Math.ceil(uv.y) - uv.y;\n          } else {\n            uv.y = uv.y - Math.floor(uv.y);\n          }\n\n          break;\n      }\n    }\n\n    if (this.flipY) {\n      uv.y = 1 - uv.y;\n    }\n  }\n};\nTHREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);\nTHREE.TextureIdCount = 0; // File:src/textures/CanvasTexture.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.CanvasTexture = function (canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n  THREE.Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n  this.needsUpdate = true;\n};\n\nTHREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture; // File:src/textures/CubeTexture.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.CubeTexture = function (images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n  mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\n  THREE.Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n  this.images = images;\n  this.flipY = false;\n};\n\nTHREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\n\nTHREE.CubeTexture.prototype.copy = function (source) {\n  THREE.Texture.prototype.copy.call(this, source);\n  this.images = source.images;\n  return this;\n}; // File:src/textures/CompressedTexture.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.CompressedTexture = function (mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {\n  THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n  this.image = {\n    width: width,\n    height: height\n  };\n  this.mipmaps = mipmaps; // no flipping for cube textures\n  // (also flipping doesn't work for compressed textures )\n\n  this.flipY = false; // can't generate mipmaps for compressed textures\n  // mips must be embedded in DDS files\n\n  this.generateMipmaps = false;\n};\n\nTHREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture; // File:src/textures/DataTexture.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.DataTexture = function (data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {\n  THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n  this.image = {\n    data: data,\n    width: width,\n    height: height\n  };\n  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n  this.flipY = false;\n  this.generateMipmaps = false;\n};\n\nTHREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture; // File:src/textures/VideoTexture.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.VideoTexture = function (video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n  THREE.Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n  this.generateMipmaps = false;\n  var scope = this;\n\n  var update = function update() {\n    requestAnimationFrame(update);\n\n    if (video.readyState === video.HAVE_ENOUGH_DATA) {\n      scope.needsUpdate = true;\n    }\n  };\n\n  update();\n};\n\nTHREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture; // File:src/objects/Group.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.Group = function () {\n  THREE.Object3D.call(this);\n  this.type = 'Group';\n};\n\nTHREE.Group.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Group.prototype.constructor = THREE.Group; // File:src/objects/Points.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.Points = function (geometry, material) {\n  THREE.Object3D.call(this);\n  this.type = 'Points';\n  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n  this.material = material !== undefined ? material : new THREE.PointsMaterial({\n    color: Math.random() * 0xffffff\n  });\n};\n\nTHREE.Points.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Points.prototype.constructor = THREE.Points;\n\nTHREE.Points.prototype.raycast = function () {\n  var inverseMatrix = new THREE.Matrix4();\n  var ray = new THREE.Ray();\n  return function raycast(raycaster, intersects) {\n    var object = this;\n    var geometry = object.geometry;\n    var threshold = raycaster.params.Points.threshold;\n    inverseMatrix.getInverse(this.matrixWorld);\n    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n\n    if (geometry.boundingBox !== null) {\n      if (ray.isIntersectionBox(geometry.boundingBox) === false) {\n        return;\n      }\n    }\n\n    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    var localThresholdSq = localThreshold * localThreshold;\n    var position = new THREE.Vector3();\n\n    function testPoint(point, index) {\n      var rayPointDistanceSq = ray.distanceSqToPoint(point);\n\n      if (rayPointDistanceSq < localThresholdSq) {\n        var intersectPoint = ray.closestPointToPoint(point);\n        intersectPoint.applyMatrix4(object.matrixWorld);\n        var distance = raycaster.ray.origin.distanceTo(intersectPoint);\n        if (distance < raycaster.near || distance > raycaster.far) return;\n        intersects.push({\n          distance: distance,\n          distanceToRay: Math.sqrt(rayPointDistanceSq),\n          point: intersectPoint.clone(),\n          index: index,\n          face: null,\n          object: object\n        });\n      }\n    }\n\n    if (geometry instanceof THREE.BufferGeometry) {\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n      var positions = attributes.position.array;\n\n      if (index !== null) {\n        var indices = index.array;\n\n        for (var i = 0, il = indices.length; i < il; i++) {\n          var a = indices[i];\n          position.fromArray(positions, a * 3);\n          testPoint(position, a);\n        }\n      } else {\n        for (var i = 0, l = positions.length / 3; i < l; i++) {\n          position.fromArray(positions, i * 3);\n          testPoint(position, i);\n        }\n      }\n    } else {\n      var vertices = geometry.vertices;\n\n      for (var i = 0, l = vertices.length; i < l; i++) {\n        testPoint(vertices[i], i);\n      }\n    }\n  };\n}();\n\nTHREE.Points.prototype.clone = function () {\n  return new this.constructor(this.geometry, this.material).copy(this);\n};\n\nTHREE.Points.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta); // only serialize if not in meta geometries cache\n\n  if (meta.geometries[this.geometry.uuid] === undefined) {\n    meta.geometries[this.geometry.uuid] = this.geometry.toJSON();\n  } // only serialize if not in meta materials cache\n\n\n  if (meta.materials[this.material.uuid] === undefined) {\n    meta.materials[this.material.uuid] = this.material.toJSON();\n  }\n\n  data.object.geometry = this.geometry.uuid;\n  data.object.material = this.material.uuid;\n  return data;\n}; // Backwards compatibility\n\n\nTHREE.PointCloud = function (geometry, material) {\n  console.warn('THREE.PointCloud has been renamed to THREE.Points.');\n  return new THREE.Points(geometry, material);\n};\n\nTHREE.ParticleSystem = function (geometry, material) {\n  console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');\n  return new THREE.Points(geometry, material);\n}; // File:src/objects/Line.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.Line = function (geometry, material, mode) {\n  if (mode === 1) {\n    console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');\n    return new THREE.LineSegments(geometry, material);\n  }\n\n  THREE.Object3D.call(this);\n  this.type = 'Line';\n  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n  this.material = material !== undefined ? material : new THREE.LineBasicMaterial({\n    color: Math.random() * 0xffffff\n  });\n};\n\nTHREE.Line.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Line.prototype.constructor = THREE.Line;\n\nTHREE.Line.prototype.raycast = function () {\n  var inverseMatrix = new THREE.Matrix4();\n  var ray = new THREE.Ray();\n  var sphere = new THREE.Sphere();\n  return function raycast(raycaster, intersects) {\n    var precision = raycaster.linePrecision;\n    var precisionSq = precision * precision;\n    var geometry = this.geometry;\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere(); // Checking boundingSphere distance to ray\n\n    sphere.copy(geometry.boundingSphere);\n    sphere.applyMatrix4(this.matrixWorld);\n\n    if (raycaster.ray.isIntersectionSphere(sphere) === false) {\n      return;\n    }\n\n    inverseMatrix.getInverse(this.matrixWorld);\n    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n    var vStart = new THREE.Vector3();\n    var vEnd = new THREE.Vector3();\n    var interSegment = new THREE.Vector3();\n    var interRay = new THREE.Vector3();\n    var step = this instanceof THREE.LineSegments ? 2 : 1;\n\n    if (geometry instanceof THREE.BufferGeometry) {\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n\n      if (index !== null) {\n        var indices = index.array;\n        var positions = attributes.position.array;\n\n        for (var i = 0, l = indices.length - 1; i < l; i += step) {\n          var a = indices[i];\n          var b = indices[i + 1];\n          vStart.fromArray(positions, a * 3);\n          vEnd.fromArray(positions, b * 3);\n          var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n          if (distSq > precisionSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          var distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      } else {\n        var positions = attributes.position.array;\n\n        for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {\n          vStart.fromArray(positions, 3 * i);\n          vEnd.fromArray(positions, 3 * i + 3);\n          var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n          if (distSq > precisionSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          var distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      }\n    } else if (geometry instanceof THREE.Geometry) {\n      var vertices = geometry.vertices;\n      var nbVertices = vertices.length;\n\n      for (var i = 0; i < nbVertices - 1; i += step) {\n        var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);\n        if (distSq > precisionSq) continue;\n        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n        var distance = raycaster.ray.origin.distanceTo(interRay);\n        if (distance < raycaster.near || distance > raycaster.far) continue;\n        intersects.push({\n          distance: distance,\n          // What do we want? intersection point on the ray or on the segment??\n          // point: raycaster.ray.at( distance ),\n          point: interSegment.clone().applyMatrix4(this.matrixWorld),\n          index: i,\n          face: null,\n          faceIndex: null,\n          object: this\n        });\n      }\n    }\n  };\n}();\n\nTHREE.Line.prototype.clone = function () {\n  return new this.constructor(this.geometry, this.material).copy(this);\n};\n\nTHREE.Line.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta); // only serialize if not in meta geometries cache\n\n  if (meta.geometries[this.geometry.uuid] === undefined) {\n    meta.geometries[this.geometry.uuid] = this.geometry.toJSON();\n  } // only serialize if not in meta materials cache\n\n\n  if (meta.materials[this.material.uuid] === undefined) {\n    meta.materials[this.material.uuid] = this.material.toJSON();\n  }\n\n  data.object.geometry = this.geometry.uuid;\n  data.object.material = this.material.uuid;\n  return data;\n}; // DEPRECATED\n\n\nTHREE.LineStrip = 0;\nTHREE.LinePieces = 1; // File:src/objects/LineSegments.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.LineSegments = function (geometry, material) {\n  THREE.Line.call(this, geometry, material);\n  this.type = 'LineSegments';\n};\n\nTHREE.LineSegments.prototype = Object.create(THREE.Line.prototype);\nTHREE.LineSegments.prototype.constructor = THREE.LineSegments; // File:src/objects/Mesh.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\n\nTHREE.Mesh = function (geometry, material) {\n  THREE.Object3D.call(this);\n  this.type = 'Mesh';\n  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n  this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({\n    color: Math.random() * 0xffffff\n  });\n  this.updateMorphTargets();\n};\n\nTHREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Mesh.prototype.constructor = THREE.Mesh;\n\nTHREE.Mesh.prototype.updateMorphTargets = function () {\n  if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {\n    this.morphTargetBase = -1;\n    this.morphTargetInfluences = [];\n    this.morphTargetDictionary = {};\n\n    for (var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++) {\n      this.morphTargetInfluences.push(0);\n      this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;\n    }\n  }\n};\n\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function (name) {\n  if (this.morphTargetDictionary[name] !== undefined) {\n    return this.morphTargetDictionary[name];\n  }\n\n  console.warn('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');\n  return 0;\n};\n\nTHREE.Mesh.prototype.raycast = function () {\n  var inverseMatrix = new THREE.Matrix4();\n  var ray = new THREE.Ray();\n  var sphere = new THREE.Sphere();\n  var vA = new THREE.Vector3();\n  var vB = new THREE.Vector3();\n  var vC = new THREE.Vector3();\n  var tempA = new THREE.Vector3();\n  var tempB = new THREE.Vector3();\n  var tempC = new THREE.Vector3();\n  var uvA = new THREE.Vector2();\n  var uvB = new THREE.Vector2();\n  var uvC = new THREE.Vector2();\n  var barycoord = new THREE.Vector3();\n  var intersectionPoint = new THREE.Vector3();\n  var intersectionPointWorld = new THREE.Vector3();\n\n  function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {\n    THREE.Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);\n    uv1.multiplyScalar(barycoord.x);\n    uv2.multiplyScalar(barycoord.y);\n    uv3.multiplyScalar(barycoord.z);\n    uv1.add(uv2).add(uv3);\n    return uv1.clone();\n  }\n\n  return function raycast(raycaster, intersects) {\n    var geometry = this.geometry;\n    var material = this.material;\n    if (material === undefined) return; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n    sphere.copy(geometry.boundingSphere);\n    sphere.applyMatrix4(this.matrixWorld);\n\n    if (raycaster.ray.isIntersectionSphere(sphere) === false) {\n      return;\n    } // Check boundingBox before continuing\n\n\n    inverseMatrix.getInverse(this.matrixWorld);\n    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n\n    if (geometry.boundingBox !== null) {\n      if (ray.isIntersectionBox(geometry.boundingBox) === false) {\n        return;\n      }\n    }\n\n    var a, b, c;\n\n    if (geometry instanceof THREE.BufferGeometry) {\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n\n      if (index !== null) {\n        var indices = index.array;\n        var positions = attributes.position.array;\n\n        for (var i = 0, l = indices.length; i < l; i += 3) {\n          a = indices[i];\n          b = indices[i + 1];\n          c = indices[i + 2];\n          vA.fromArray(positions, a * 3);\n          vB.fromArray(positions, b * 3);\n          vC.fromArray(positions, c * 3);\n\n          if (material.side === THREE.BackSide) {\n            if (ray.intersectTriangle(vC, vB, vA, true, intersectionPoint) === null) continue;\n          } else {\n            if (ray.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint) === null) continue;\n          }\n\n          intersectionPointWorld.copy(intersectionPoint);\n          intersectionPointWorld.applyMatrix4(this.matrixWorld);\n          var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          var uv;\n\n          if (attributes.uv !== undefined) {\n            var uvs = attributes.uv.array;\n            uvA.fromArray(uvs, a * 2);\n            uvB.fromArray(uvs, b * 2);\n            uvC.fromArray(uvs, c * 2);\n            uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);\n          }\n\n          intersects.push({\n            distance: distance,\n            point: intersectionPointWorld.clone(),\n            uv: uv,\n            face: new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC)),\n            faceIndex: Math.floor(i / 3),\n            // triangle number in indices buffer semantics\n            object: this\n          });\n        }\n      } else {\n        var positions = attributes.position.array;\n\n        for (var i = 0, l = positions.length; i < l; i += 9) {\n          vA.fromArray(positions, i);\n          vB.fromArray(positions, i + 3);\n          vC.fromArray(positions, i + 6);\n\n          if (material.side === THREE.BackSide) {\n            if (ray.intersectTriangle(vC, vB, vA, true, intersectionPoint) === null) continue;\n          } else {\n            if (ray.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint) === null) continue;\n          }\n\n          intersectionPointWorld.copy(intersectionPoint);\n          intersectionPointWorld.applyMatrix4(this.matrixWorld);\n          var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          var uv;\n\n          if (attributes.uv !== undefined) {\n            var uvs = attributes.uv.array;\n            uvA.fromArray(uvs, i);\n            uvB.fromArray(uvs, i + 2);\n            uvC.fromArray(uvs, i + 4);\n            uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);\n          }\n\n          a = i / 3;\n          b = a + 1;\n          c = a + 2;\n          intersects.push({\n            distance: distance,\n            point: intersectionPointWorld.clone(),\n            uv: uv,\n            face: new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC)),\n            index: a,\n            // triangle number in positions buffer semantics\n            object: this\n          });\n        }\n      }\n    } else if (geometry instanceof THREE.Geometry) {\n      var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n      var materials = isFaceMaterial === true ? material.materials : null;\n      var vertices = geometry.vertices;\n      var faces = geometry.faces;\n\n      for (var f = 0, fl = faces.length; f < fl; f++) {\n        var face = faces[f];\n        var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;\n        if (faceMaterial === undefined) continue;\n        a = vertices[face.a];\n        b = vertices[face.b];\n        c = vertices[face.c];\n\n        if (faceMaterial.morphTargets === true) {\n          var morphTargets = geometry.morphTargets;\n          var morphInfluences = this.morphTargetInfluences;\n          vA.set(0, 0, 0);\n          vB.set(0, 0, 0);\n          vC.set(0, 0, 0);\n\n          for (var t = 0, tl = morphTargets.length; t < tl; t++) {\n            var influence = morphInfluences[t];\n            if (influence === 0) continue;\n            var targets = morphTargets[t].vertices;\n            vA.addScaledVector(tempA.subVectors(targets[face.a], a), influence);\n            vB.addScaledVector(tempB.subVectors(targets[face.b], b), influence);\n            vC.addScaledVector(tempC.subVectors(targets[face.c], c), influence);\n          }\n\n          vA.add(a);\n          vB.add(b);\n          vC.add(c);\n          a = vA;\n          b = vB;\n          c = vC;\n        }\n\n        if (faceMaterial.side === THREE.BackSide) {\n          if (ray.intersectTriangle(c, b, a, true, intersectionPoint) === null) continue;\n        } else {\n          if (ray.intersectTriangle(a, b, c, faceMaterial.side !== THREE.DoubleSide, intersectionPoint) === null) continue;\n        }\n\n        intersectionPointWorld.copy(intersectionPoint);\n        intersectionPointWorld.applyMatrix4(this.matrixWorld);\n        var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);\n        if (distance < raycaster.near || distance > raycaster.far) continue;\n        var uv;\n\n        if (geometry.faceVertexUvs[0].length > 0) {\n          var uvs = geometry.faceVertexUvs[0][f];\n          uvA.copy(uvs[0]);\n          uvB.copy(uvs[1]);\n          uvC.copy(uvs[2]);\n          uv = uvIntersection(intersectionPoint, a, b, c, uvA, uvB, uvC);\n        }\n\n        intersects.push({\n          distance: distance,\n          point: intersectionPointWorld.clone(),\n          uv: uv,\n          face: face,\n          faceIndex: f,\n          object: this\n        });\n      }\n    }\n  };\n}();\n\nTHREE.Mesh.prototype.clone = function () {\n  return new this.constructor(this.geometry, this.material).copy(this);\n};\n\nTHREE.Mesh.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta); // only serialize if not in meta geometries cache\n\n  if (meta.geometries[this.geometry.uuid] === undefined) {\n    meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);\n  } // only serialize if not in meta materials cache\n\n\n  if (meta.materials[this.material.uuid] === undefined) {\n    meta.materials[this.material.uuid] = this.material.toJSON(meta);\n  }\n\n  data.object.geometry = this.geometry.uuid;\n  data.object.material = this.material.uuid;\n  return data;\n}; // File:src/objects/Bone.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\n\n\nTHREE.Bone = function (skin) {\n  THREE.Object3D.call(this);\n  this.type = 'Bone';\n  this.skin = skin;\n};\n\nTHREE.Bone.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Bone.prototype.constructor = THREE.Bone;\n\nTHREE.Bone.prototype.copy = function (source) {\n  THREE.Object3D.prototype.copy.call(this, source);\n  this.skin = source.skin;\n  return this;\n}; // File:src/objects/Skeleton.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author michael guerrero / http://realitymeltdown.com\r\n * @author ikerr / http://verold.com\r\n */\n\n\nTHREE.Skeleton = function (bones, boneInverses, useVertexTexture) {\n  this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n  this.identityMatrix = new THREE.Matrix4(); // copy the bone array\n\n  bones = bones || [];\n  this.bones = bones.slice(0); // create a bone texture or an array of floats\n\n  if (this.useVertexTexture) {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n    var size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix\n\n    size = THREE.Math.nextPowerOfTwo(Math.ceil(size));\n    size = Math.max(size, 4);\n    this.boneTextureWidth = size;\n    this.boneTextureHeight = size;\n    this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4); // 4 floats per RGBA pixel\n\n    this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);\n  } else {\n    this.boneMatrices = new Float32Array(16 * this.bones.length);\n  } // use the supplied bone inverses or calculate the inverses\n\n\n  if (boneInverses === undefined) {\n    this.calculateInverses();\n  } else {\n    if (this.bones.length === boneInverses.length) {\n      this.boneInverses = boneInverses.slice(0);\n    } else {\n      console.warn('THREE.Skeleton bonInverses is the wrong length.');\n      this.boneInverses = [];\n\n      for (var b = 0, bl = this.bones.length; b < bl; b++) {\n        this.boneInverses.push(new THREE.Matrix4());\n      }\n    }\n  }\n};\n\nTHREE.Skeleton.prototype.calculateInverses = function () {\n  this.boneInverses = [];\n\n  for (var b = 0, bl = this.bones.length; b < bl; b++) {\n    var inverse = new THREE.Matrix4();\n\n    if (this.bones[b]) {\n      inverse.getInverse(this.bones[b].matrixWorld);\n    }\n\n    this.boneInverses.push(inverse);\n  }\n};\n\nTHREE.Skeleton.prototype.pose = function () {\n  var bone; // recover the bind-time world matrices\n\n  for (var b = 0, bl = this.bones.length; b < bl; b++) {\n    bone = this.bones[b];\n\n    if (bone) {\n      bone.matrixWorld.getInverse(this.boneInverses[b]);\n    }\n  } // compute the local matrices, positions, rotations and scales\n\n\n  for (var b = 0, bl = this.bones.length; b < bl; b++) {\n    bone = this.bones[b];\n\n    if (bone) {\n      if (bone.parent) {\n        bone.matrix.getInverse(bone.parent.matrixWorld);\n        bone.matrix.multiply(bone.matrixWorld);\n      } else {\n        bone.matrix.copy(bone.matrixWorld);\n      }\n\n      bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    }\n  }\n};\n\nTHREE.Skeleton.prototype.update = function () {\n  var offsetMatrix = new THREE.Matrix4();\n  return function update() {\n    // flatten bone matrices to array\n    for (var b = 0, bl = this.bones.length; b < bl; b++) {\n      // compute the offset between the current and the original transform\n      var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;\n      offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);\n      offsetMatrix.flattenToArrayOffset(this.boneMatrices, b * 16);\n    }\n\n    if (this.useVertexTexture) {\n      this.boneTexture.needsUpdate = true;\n    }\n  };\n}();\n\nTHREE.Skeleton.prototype.clone = function () {\n  return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture);\n}; // File:src/objects/SkinnedMesh.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\n\n\nTHREE.SkinnedMesh = function (geometry, material, useVertexTexture) {\n  THREE.Mesh.call(this, geometry, material);\n  this.type = 'SkinnedMesh';\n  this.bindMode = \"attached\";\n  this.bindMatrix = new THREE.Matrix4();\n  this.bindMatrixInverse = new THREE.Matrix4(); // init bones\n  // TODO: remove bone creation as there is no reason (other than\n  // convenience) for THREE.SkinnedMesh to do this.\n\n  var bones = [];\n\n  if (this.geometry && this.geometry.bones !== undefined) {\n    var bone, gbone;\n\n    for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {\n      gbone = this.geometry.bones[b];\n      bone = new THREE.Bone(this);\n      bones.push(bone);\n      bone.name = gbone.name;\n      bone.position.fromArray(gbone.pos);\n      bone.quaternion.fromArray(gbone.rotq);\n      if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);\n    }\n\n    for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {\n      gbone = this.geometry.bones[b];\n\n      if (gbone.parent !== -1) {\n        bones[gbone.parent].add(bones[b]);\n      } else {\n        this.add(bones[b]);\n      }\n    }\n  }\n\n  this.normalizeSkinWeights();\n  this.updateMatrixWorld(true);\n  this.bind(new THREE.Skeleton(bones, undefined, useVertexTexture), this.matrixWorld);\n};\n\nTHREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\n\nTHREE.SkinnedMesh.prototype.bind = function (skeleton, bindMatrix) {\n  this.skeleton = skeleton;\n\n  if (bindMatrix === undefined) {\n    this.updateMatrixWorld(true);\n    this.skeleton.calculateInverses();\n    bindMatrix = this.matrixWorld;\n  }\n\n  this.bindMatrix.copy(bindMatrix);\n  this.bindMatrixInverse.getInverse(bindMatrix);\n};\n\nTHREE.SkinnedMesh.prototype.pose = function () {\n  this.skeleton.pose();\n};\n\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\n  if (this.geometry instanceof THREE.Geometry) {\n    for (var i = 0; i < this.geometry.skinIndices.length; i++) {\n      var sw = this.geometry.skinWeights[i];\n      var scale = 1.0 / sw.lengthManhattan();\n\n      if (scale !== Infinity) {\n        sw.multiplyScalar(scale);\n      } else {\n        sw.set(1); // this will be normalized by the shader anyway\n      }\n    }\n  } else {// skinning weights assumed to be normalized for THREE.BufferGeometry\n    }\n};\n\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function (force) {\n  THREE.Mesh.prototype.updateMatrixWorld.call(this, true);\n\n  if (this.bindMode === \"attached\") {\n    this.bindMatrixInverse.getInverse(this.matrixWorld);\n  } else if (this.bindMode === \"detached\") {\n    this.bindMatrixInverse.getInverse(this.bindMatrix);\n  } else {\n    console.warn('THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode);\n  }\n};\n\nTHREE.SkinnedMesh.prototype.clone = function () {\n  return new this.constructor(this.geometry, this.material, this.useVertexTexture).copy(this);\n}; // File:src/objects/MorphAnimMesh.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.MorphAnimMesh = function (geometry, material) {\n  THREE.Mesh.call(this, geometry, material);\n  this.type = 'MorphAnimMesh'; // API\n\n  this.duration = 1000; // milliseconds\n\n  this.mirroredLoop = false;\n  this.time = 0; // internals\n\n  this.lastKeyframe = 0;\n  this.currentKeyframe = 0;\n  this.direction = 1;\n  this.directionBackwards = false;\n  this.setFrameRange(0, geometry.morphTargets.length - 1);\n};\n\nTHREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;\n\nTHREE.MorphAnimMesh.prototype.setFrameRange = function (start, end) {\n  this.startKeyframe = start;\n  this.endKeyframe = end;\n  this.length = this.endKeyframe - this.startKeyframe + 1;\n};\n\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\n  this.direction = 1;\n  this.directionBackwards = false;\n};\n\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\n  this.direction = -1;\n  this.directionBackwards = true;\n};\n\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\n  var geometry = this.geometry;\n  if (!geometry.animations) geometry.animations = {};\n  var firstAnimation,\n      animations = geometry.animations;\n  var pattern = /([a-z]+)_?(\\d+)/;\n\n  for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {\n    var morph = geometry.morphTargets[i];\n    var parts = morph.name.match(pattern);\n\n    if (parts && parts.length > 1) {\n      var label = parts[1];\n      if (!animations[label]) animations[label] = {\n        start: Infinity,\n        end: -Infinity\n      };\n      var animation = animations[label];\n      if (i < animation.start) animation.start = i;\n      if (i > animation.end) animation.end = i;\n      if (!firstAnimation) firstAnimation = label;\n    }\n  }\n\n  geometry.firstAnimation = firstAnimation;\n};\n\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function (label, start, end) {\n  if (!this.geometry.animations) this.geometry.animations = {};\n  this.geometry.animations[label] = {\n    start: start,\n    end: end\n  };\n};\n\nTHREE.MorphAnimMesh.prototype.playAnimation = function (label, fps) {\n  var animation = this.geometry.animations[label];\n\n  if (animation) {\n    this.setFrameRange(animation.start, animation.end);\n    this.duration = 1000 * ((animation.end - animation.start) / fps);\n    this.time = 0;\n  } else {\n    console.warn('THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()');\n  }\n};\n\nTHREE.MorphAnimMesh.prototype.updateAnimation = function (delta) {\n  var frameTime = this.duration / this.length;\n  this.time += this.direction * delta;\n\n  if (this.mirroredLoop) {\n    if (this.time > this.duration || this.time < 0) {\n      this.direction *= -1;\n\n      if (this.time > this.duration) {\n        this.time = this.duration;\n        this.directionBackwards = true;\n      }\n\n      if (this.time < 0) {\n        this.time = 0;\n        this.directionBackwards = false;\n      }\n    }\n  } else {\n    this.time = this.time % this.duration;\n    if (this.time < 0) this.time += this.duration;\n  }\n\n  var keyframe = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / frameTime), 0, this.length - 1);\n  var influences = this.morphTargetInfluences;\n\n  if (keyframe !== this.currentKeyframe) {\n    influences[this.lastKeyframe] = 0;\n    influences[this.currentKeyframe] = 1;\n    influences[keyframe] = 0;\n    this.lastKeyframe = this.currentKeyframe;\n    this.currentKeyframe = keyframe;\n  }\n\n  var mix = this.time % frameTime / frameTime;\n\n  if (this.directionBackwards) {\n    mix = 1 - mix;\n  }\n\n  influences[this.currentKeyframe] = mix;\n  influences[this.lastKeyframe] = 1 - mix;\n};\n\nTHREE.MorphAnimMesh.prototype.interpolateTargets = function (a, b, t) {\n  var influences = this.morphTargetInfluences;\n\n  for (var i = 0, l = influences.length; i < l; i++) {\n    influences[i] = 0;\n  }\n\n  if (a > -1) influences[a] = 1 - t;\n  if (b > -1) influences[b] = t;\n};\n\nTHREE.MorphAnimMesh.prototype.copy = function (source) {\n  THREE.Mesh.prototype.copy.call(this, source);\n  this.duration = source.duration;\n  this.mirroredLoop = source.mirroredLoop;\n  this.time = source.time;\n  this.lastKeyframe = source.lastKeyframe;\n  this.currentKeyframe = source.currentKeyframe;\n  this.direction = source.direction;\n  this.directionBackwards = source.directionBackwards;\n  return this;\n}; // File:src/objects/LOD.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.LOD = function () {\n  THREE.Object3D.call(this);\n  this.type = 'LOD';\n  Object.defineProperties(this, {\n    levels: {\n      enumerable: true,\n      value: []\n    },\n    objects: {\n      get: function get() {\n        console.warn('THREE.LOD: .objects has been renamed to .levels.');\n        return this.levels;\n      }\n    }\n  });\n};\n\nTHREE.LOD.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.LOD.prototype.constructor = THREE.LOD;\n\nTHREE.LOD.prototype.addLevel = function (object, distance) {\n  if (distance === undefined) distance = 0;\n  distance = Math.abs(distance);\n  var levels = this.levels;\n\n  for (var l = 0; l < levels.length; l++) {\n    if (distance < levels[l].distance) {\n      break;\n    }\n  }\n\n  levels.splice(l, 0, {\n    distance: distance,\n    object: object\n  });\n  this.add(object);\n};\n\nTHREE.LOD.prototype.getObjectForDistance = function (distance) {\n  var levels = this.levels;\n\n  for (var i = 1, l = levels.length; i < l; i++) {\n    if (distance < levels[i].distance) {\n      break;\n    }\n  }\n\n  return levels[i - 1].object;\n};\n\nTHREE.LOD.prototype.raycast = function () {\n  var matrixPosition = new THREE.Vector3();\n  return function raycast(raycaster, intersects) {\n    matrixPosition.setFromMatrixPosition(this.matrixWorld);\n    var distance = raycaster.ray.origin.distanceTo(matrixPosition);\n    this.getObjectForDistance(distance).raycast(raycaster, intersects);\n  };\n}();\n\nTHREE.LOD.prototype.update = function () {\n  var v1 = new THREE.Vector3();\n  var v2 = new THREE.Vector3();\n  return function update(camera) {\n    var levels = this.levels;\n\n    if (levels.length > 1) {\n      v1.setFromMatrixPosition(camera.matrixWorld);\n      v2.setFromMatrixPosition(this.matrixWorld);\n      var distance = v1.distanceTo(v2);\n      levels[0].object.visible = true;\n\n      for (var i = 1, l = levels.length; i < l; i++) {\n        if (distance >= levels[i].distance) {\n          levels[i - 1].object.visible = false;\n          levels[i].object.visible = true;\n        } else {\n          break;\n        }\n      }\n\n      for (; i < l; i++) {\n        levels[i].object.visible = false;\n      }\n    }\n  };\n}();\n\nTHREE.LOD.prototype.copy = function (source) {\n  THREE.Object3D.prototype.copy.call(this, source, false);\n  var levels = source.levels;\n\n  for (var i = 0, l = levels.length; i < l; i++) {\n    var level = levels[i];\n    this.addLevel(level.object.clone(), level.distance);\n  }\n\n  return this;\n};\n\nTHREE.LOD.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta);\n  data.object.levels = [];\n  var levels = this.levels;\n\n  for (var i = 0, l = levels.length; i < l; i++) {\n    var level = levels[i];\n    data.object.levels.push({\n      object: level.object.uuid,\n      distance: level.distance\n    });\n  }\n\n  return data;\n}; // File:src/objects/Sprite.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.Sprite = function () {\n  var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\n  var vertices = new Float32Array([-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0]);\n  var uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n  var geometry = new THREE.BufferGeometry();\n  geometry.setIndex(new THREE.BufferAttribute(indices, 1));\n  geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n  geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));\n  return function Sprite(material) {\n    THREE.Object3D.call(this);\n    this.type = 'Sprite';\n    this.geometry = geometry;\n    this.material = material !== undefined ? material : new THREE.SpriteMaterial();\n  };\n}();\n\nTHREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Sprite.prototype.constructor = THREE.Sprite;\n\nTHREE.Sprite.prototype.raycast = function () {\n  var matrixPosition = new THREE.Vector3();\n  return function raycast(raycaster, intersects) {\n    matrixPosition.setFromMatrixPosition(this.matrixWorld);\n    var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);\n    var guessSizeSq = this.scale.x * this.scale.y;\n\n    if (distanceSq > guessSizeSq) {\n      return;\n    }\n\n    intersects.push({\n      distance: Math.sqrt(distanceSq),\n      point: this.position,\n      face: null,\n      object: this\n    });\n  };\n}();\n\nTHREE.Sprite.prototype.clone = function () {\n  return new this.constructor(this.material).copy(this);\n};\n\nTHREE.Sprite.prototype.toJSON = function (meta) {\n  var data = THREE.Object3D.prototype.toJSON.call(this, meta); // only serialize if not in meta materials cache\n\n  if (meta.materials[this.material.uuid] === undefined) {\n    meta.materials[this.material.uuid] = this.material.toJSON();\n  }\n\n  data.object.material = this.material.uuid;\n  return data;\n}; // Backwards compatibility\n\n\nTHREE.Particle = THREE.Sprite; // File:src/objects/LensFlare.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.LensFlare = function (texture, size, distance, blending, color) {\n  THREE.Object3D.call(this);\n  this.lensFlares = [];\n  this.positionScreen = new THREE.Vector3();\n  this.customUpdateCallback = undefined;\n\n  if (texture !== undefined) {\n    this.add(texture, size, distance, blending, color);\n  }\n};\n\nTHREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\n/*\r\n * Add: adds another flare\r\n */\n\nTHREE.LensFlare.prototype.add = function (texture, size, distance, blending, color, opacity) {\n  if (size === undefined) size = -1;\n  if (distance === undefined) distance = 0;\n  if (opacity === undefined) opacity = 1;\n  if (color === undefined) color = new THREE.Color(0xffffff);\n  if (blending === undefined) blending = THREE.NormalBlending;\n  distance = Math.min(distance, Math.max(0, distance));\n  this.lensFlares.push({\n    texture: texture,\n    // THREE.Texture\n    size: size,\n    // size in pixels (-1 = use texture.width)\n    distance: distance,\n    // distance (0-1) from light source (0=at light source)\n    x: 0,\n    y: 0,\n    z: 0,\n    // screen position (-1 => 1) z = 0 is in front z = 1 is back\n    scale: 1,\n    // scale\n    rotation: 0,\n    // rotation\n    opacity: opacity,\n    // opacity\n    color: color,\n    // color\n    blending: blending // blending\n\n  });\n};\n/*\r\n * Update lens flares update positions on all flares based on the screen position\r\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n */\n\n\nTHREE.LensFlare.prototype.updateLensFlares = function () {\n  var f,\n      fl = this.lensFlares.length;\n  var flare;\n  var vecX = -this.positionScreen.x * 2;\n  var vecY = -this.positionScreen.y * 2;\n\n  for (f = 0; f < fl; f++) {\n    flare = this.lensFlares[f];\n    flare.x = this.positionScreen.x + vecX * flare.distance;\n    flare.y = this.positionScreen.y + vecY * flare.distance;\n    flare.wantedRotation = flare.x * Math.PI * 0.25;\n    flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;\n  }\n};\n\nTHREE.LensFlare.prototype.copy = function (source) {\n  THREE.Object3D.prototype.copy.call(this, source);\n  this.positionScreen.copy(source.positionScreen);\n  this.customUpdateCallback = source.customUpdateCallback;\n\n  for (var i = 0, l = source.lensFlares.length; i < l; i++) {\n    this.lensFlares.push(source.lensFlares[i]);\n  }\n\n  return this;\n}; // File:src/scenes/Scene.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.Scene = function () {\n  THREE.Object3D.call(this);\n  this.type = 'Scene';\n  this.fog = null;\n  this.overrideMaterial = null;\n  this.autoUpdate = true; // checked by the renderer\n};\n\nTHREE.Scene.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Scene.prototype.constructor = THREE.Scene;\n\nTHREE.Scene.prototype.copy = function (source) {\n  THREE.Object3D.prototype.copy.call(this, source);\n  if (source.fog !== null) this.fog = source.fog.clone();\n  if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n  this.autoUpdate = source.autoUpdate;\n  this.matrixAutoUpdate = source.matrixAutoUpdate;\n  return this;\n}; // File:src/scenes/Fog.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.Fog = function (color, near, far) {\n  this.name = '';\n  this.color = new THREE.Color(color);\n  this.near = near !== undefined ? near : 1;\n  this.far = far !== undefined ? far : 1000;\n};\n\nTHREE.Fog.prototype.clone = function () {\n  return new THREE.Fog(this.color.getHex(), this.near, this.far);\n}; // File:src/scenes/FogExp2.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.FogExp2 = function (color, density) {\n  this.name = '';\n  this.color = new THREE.Color(color);\n  this.density = density !== undefined ? density : 0.00025;\n};\n\nTHREE.FogExp2.prototype.clone = function () {\n  return new THREE.FogExp2(this.color.getHex(), this.density);\n}; // File:src/renderers/shaders/ShaderChunk.js\n\n\nTHREE.ShaderChunk = {}; // File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\n\nTHREE.ShaderChunk['alphamap_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\n\nTHREE.ShaderChunk['alphamap_pars_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n\tuniform sampler2D alphaMap;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\n\nTHREE.ShaderChunk['alphatest_fragment'] = \"#ifdef ALPHATEST\\n\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\n\nTHREE.ShaderChunk['aomap_fragment'] = \"#ifdef USE_AOMAP\\n\\n\ttotalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\n\nTHREE.ShaderChunk['aomap_pars_fragment'] = \"#ifdef USE_AOMAP\\n\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\n\nTHREE.ShaderChunk['begin_vertex'] = \"\\nvec3 transformed = vec3( position );\\n\"; // File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\n\nTHREE.ShaderChunk['beginnormal_vertex'] = \"\\nvec3 objectNormal = vec3( normal );\\n\"; // File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\n\nTHREE.ShaderChunk['bumpmap_pars_fragment'] = \"#ifdef USE_BUMPMAP\\n\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\\n\\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\\n\\n\tvec2 dHdxy_fwd() {\\n\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\n\t\treturn vec2( dBx, dBy );\\n\\n\t}\\n\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\t\t// normalized\\n\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\n\t}\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\n\nTHREE.ShaderChunk['color_fragment'] = \"#ifdef USE_COLOR\\n\\n\tdiffuseColor.rgb *= vColor;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\n\nTHREE.ShaderChunk['color_pars_fragment'] = \"#ifdef USE_COLOR\\n\\n\tvarying vec3 vColor;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\n\nTHREE.ShaderChunk['color_pars_vertex'] = \"#ifdef USE_COLOR\\n\\n\tvarying vec3 vColor;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\n\nTHREE.ShaderChunk['color_vertex'] = \"#ifdef USE_COLOR\\n\\n\tvColor.xyz = color.xyz;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/common.glsl\n\nTHREE.ShaderChunk['common'] = \"#define PI 3.14159\\n#define PI2 6.28318\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\n\\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\\n\\n\treturn normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\\n\\n}\\n\\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\\n\\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\\n\\n}\\n\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\n\treturn - distance * planeNormal + point;\\n\\n}\\n\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n\\n}\\n\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n\\n}\\n\\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\\n\\n\tif ( decayExponent > 0.0 ) {\\n\\n\t  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\n\t}\\n\\n\treturn 1.0;\\n\\n}\\n\\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\\n\\n\t// Original approximation by Christophe Schlick '94\\n\t//;float fresnel = pow( 1.0 - dotLH, 5.0 );\\n\\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\\n\tfloat fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\\n\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n\\n}\\n\\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\\n\\n\t// geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)\\n\\n\treturn 0.25;\\n\\n}\\n\\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\\n\\n\t// factor of 1/PI in distribution term omitted\\n\\n\treturn ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n\\n}\\n\\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\\n\\n\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\n\t//float dotNL = saturate( dot( normal, lightDir ) );\\n\t//float dotNV = saturate( dot( normal, viewDir ) );\\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( lightDir, halfDir ) );\\n\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\\n\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\n\treturn F * G * D;\\n\\n}\\n\\nvec3 inputToLinear( in vec3 a ) {\\n\\n\t#ifdef GAMMA_INPUT\\n\\n\t\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\\n\\n\t#else\\n\\n\t\treturn a;\\n\\n\t#endif\\n\\n}\\n\\nvec3 linearToOutput( in vec3 a ) {\\n\\n\t#ifdef GAMMA_OUTPUT\\n\\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\\n\\n\t#else\\n\\n\t\treturn a;\\n\\n\t#endif\\n\\n}\\n\"; // File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\n\nTHREE.ShaderChunk['defaultnormal_vertex'] = \"#ifdef FLIP_SIDED\\n\\n\tobjectNormal = -objectNormal;\\n\\n#endif\\n\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\"; // File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\n\nTHREE.ShaderChunk['displacementmap_vertex'] = \"#ifdef USE_DISPLACEMENTMAP\\n\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\n\nTHREE.ShaderChunk['displacementmap_pars_vertex'] = \"#ifdef USE_DISPLACEMENTMAP\\n\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\n\nTHREE.ShaderChunk['emissivemap_fragment'] = \"#ifdef USE_EMISSIVEMAP\\n\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\n\temissiveColor.rgb = inputToLinear( emissiveColor.rgb );\\n\\n\ttotalEmissiveLight *= emissiveColor.rgb;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\n\nTHREE.ShaderChunk['emissivemap_pars_fragment'] = \"#ifdef USE_EMISSIVEMAP\\n\\n\tuniform sampler2D emissiveMap;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\n\nTHREE.ShaderChunk['envmap_fragment'] = \"#ifdef USE_ENVMAP\\n\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\n\t\t// Transforming Normal Vectors with the Inverse Transformation\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\n\t\t#else\\n\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\t\t#endif\\n\\n\t#else\\n\\n\t\tvec3 reflectVec = vReflect;\\n\\n\t#endif\\n\\n\t#ifdef DOUBLE_SIDED\\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t#else\\n\t\tfloat flipNormal = 1.0;\\n\t#endif\\n\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\\n\tenvColor.xyz = inputToLinear( envColor.xyz );\\n\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\n\t#endif\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\n\nTHREE.ShaderChunk['envmap_pars_fragment'] = \"#ifdef USE_ENVMAP\\n\\n\tuniform float reflectivity;\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\t\tuniform float refractionRatio;\\n\\n\t#else\\n\\n\t\tvarying vec3 vReflect;\\n\\n\t#endif\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\n\nTHREE.ShaderChunk['envmap_pars_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\tvarying vec3 vReflect;\\n\\n\tuniform float refractionRatio;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\n\nTHREE.ShaderChunk['envmap_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\tvec3 worldNormal = transformDirection( objectNormal, modelMatrix );\\n\\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\n\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\n\t#else\\n\\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\t#endif\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\n\nTHREE.ShaderChunk['fog_fragment'] = \"#ifdef USE_FOG\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\n\t#else\\n\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\n\t#endif\\n\\n\t#ifdef FOG_EXP2\\n\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\\n\t#else\\n\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\n\t#endif\\n\t\\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\n\nTHREE.ShaderChunk['fog_pars_fragment'] = \"#ifdef USE_FOG\\n\\n\tuniform vec3 fogColor;\\n\\n\t#ifdef FOG_EXP2\\n\\n\t\tuniform float fogDensity;\\n\\n\t#else\\n\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\n\nTHREE.ShaderChunk['lightmap_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n\ttotalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\n\nTHREE.ShaderChunk['lightmap_pars_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl\n\nTHREE.ShaderChunk['lights_lambert_pars_vertex'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\n\nTHREE.ShaderChunk['lights_lambert_vertex'] = \"vLightFront = vec3( 0.0 );\\n\\n#ifdef DOUBLE_SIDED\\n\\n\tvLightBack = vec3( 0.0 );\\n\\n#endif\\n\\nvec3 normal = normalize( transformedNormal );\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lightColor = pointLightColor[ i ];\\n\\n\t\tvec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\\n\t\tvec3 lightDir = normalize( lVector );\\n\\n\t\t// attenuation\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lightDir );\\n\\n\t\tvLightFront += lightColor * attenuation * saturate( dotProduct );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvLightBack += lightColor * attenuation * saturate( - dotProduct );\\n\\n\t\t#endif\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lightColor = spotLightColor[ i ];\\n\\n\t\tvec3 lightPosition = spotLightPosition[ i ];\\n\t\tvec3 lVector = lightPosition - mvPosition.xyz;\\n\t\tvec3 lightDir = normalize( lVector );\\n\\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], lightDir );\\n\\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\t\t\tspotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\\n\\n\t\t\t// attenuation\\n\\n\t\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\t\t\tattenuation *= spotEffect;\\n\\n\t\t\t// diffuse\\n\\n\t\t\tfloat dotProduct = dot( normal, lightDir );\\n\\n\t\t\tvLightFront += lightColor * attenuation * saturate( dotProduct );\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tvLightBack += lightColor * attenuation * saturate( - dotProduct );\\n\\n\t\t\t#endif\\n\\n\t\t}\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lightColor = directionalLightColor[ i ];\\n\\n\t\tvec3 lightDir = directionalLightDirection[ i ];\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lightDir );\\n\\n\t\tvLightFront += lightColor * saturate( dotProduct );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvLightBack += lightColor * saturate( - dotProduct );\\n\\n\t\t#endif\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lightDir = hemisphereLightDirection[ i ];\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lightDir );\\n\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tfloat hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\\n\\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\n\\n\t\t#endif\\n\\n\t}\\n\\n#endif\\n\\nvLightFront += ambientLightColor;\\n\\n#ifdef DOUBLE_SIDED\\n\\n\tvLightBack += ambientLightColor;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\n\nTHREE.ShaderChunk['lights_phong_fragment'] = \"#ifndef FLAT_SHADED\\n\\n\tvec3 normal = normalize( vNormal );\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\\n\t#endif\\n\\n#else\\n\\n\tvec3 fdx = dFdx( vViewPosition );\\n\tvec3 fdy = dFdy( vViewPosition );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n\\n#endif\\n\\n#ifdef USE_NORMALMAP\\n\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\n#elif defined( USE_BUMPMAP )\\n\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n\\n#endif\\n\\nvec3 viewDir = normalize( vViewPosition );\\n\\nvec3 totalDiffuseLight = vec3( 0.0 );\\nvec3 totalSpecularLight = vec3( 0.0 );\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lightColor = pointLightColor[ i ];\\n\\n\t\tvec3 lightPosition = pointLightPosition[ i ];\\n\t\tvec3 lVector = lightPosition + vViewPosition.xyz;\\n\t\tvec3 lightDir = normalize( lVector );\\n\\n\t\t// attenuation\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\t\t// diffuse\\n\\n\t\tfloat cosineTerm = saturate( dot( normal, lightDir ) );\\n\\n\t\ttotalDiffuseLight += lightColor * attenuation * cosineTerm;\\n\\n\t\t// specular\\n\\n\t\tvec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\\n\\n\t\ttotalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\\n\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lightColor = spotLightColor[ i ];\\n\\n\t\tvec3 lightPosition = spotLightPosition[ i ];\\n\t\tvec3 lVector = lightPosition + vViewPosition.xyz;\\n\t\tvec3 lightDir = normalize( lVector );\\n\\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], lightDir );\\n\\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\t\t\tspotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\\n\\n\t\t\t// attenuation\\n\\n\t\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\t\t\tattenuation *= spotEffect;\\n\\n\t\t\t// diffuse\\n\\n\t\t\tfloat cosineTerm = saturate( dot( normal, lightDir ) );\\n\\n\t\t\ttotalDiffuseLight += lightColor * attenuation * cosineTerm;\\n\\n\t\t\t// specular\\n\\n\t\t\tvec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\\n\\n\t\t\ttotalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\\n\\n\t\t}\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lightColor = directionalLightColor[ i ];\\n\\n\t\tvec3 lightDir = directionalLightDirection[ i ];\\n\\n\t\t// diffuse\\n\\n\t\tfloat cosineTerm = saturate( dot( normal, lightDir ) );\\n\\n\t\ttotalDiffuseLight += lightColor * cosineTerm;\\n\\n\t\t// specular\\n\\n\t\tvec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\\n\\n\t\ttotalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lightDir = hemisphereLightDirection[ i ];\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lightDir );\\n\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\\n\t\tvec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\t\ttotalDiffuseLight += lightColor;\\n\\n\t\t// specular (sky term only)\\n\\n\t\tvec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\\n\\n\t\ttotalSpecularLight += brdf * specularStrength * lightColor * max( dotProduct, 0.0 );\\n\\n\t}\\n\\n#endif\\n\\n#ifdef METAL\\n\\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;\\n\\n#else\\n\\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\n\nTHREE.ShaderChunk['lights_phong_pars_fragment'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\\n\\n\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n\\n\tvarying vec3 vNormal;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl\n\nTHREE.ShaderChunk['lights_phong_pars_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\\n\\n\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl\n\nTHREE.ShaderChunk['lights_phong_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\\n\\n\tvWorldPosition = worldPosition.xyz;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl\n\nTHREE.ShaderChunk['linear_to_gamma_fragment'] = \"\\n\toutgoingLight = linearToOutput( outgoingLight );\\n\"; // File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\n\nTHREE.ShaderChunk['logdepthbuf_fragment'] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\n\nTHREE.ShaderChunk['logdepthbuf_pars_fragment'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\tuniform float logDepthBufFC;\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tvarying float vFragDepth;\\n\\n\t#endif\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\n\nTHREE.ShaderChunk['logdepthbuf_pars_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tvarying float vFragDepth;\\n\\n\t#endif\\n\\n\tuniform float logDepthBufFC;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\n\nTHREE.ShaderChunk['logdepthbuf_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\\n#else\\n\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\n\t#endif\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\n\nTHREE.ShaderChunk['map_fragment'] = \"#ifdef USE_MAP\\n\\n\tvec4 texelColor = texture2D( map, vUv );\\n\\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\\n\\n\tdiffuseColor *= texelColor;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\n\nTHREE.ShaderChunk['map_pars_fragment'] = \"#ifdef USE_MAP\\n\\n\tuniform sampler2D map;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\n\nTHREE.ShaderChunk['map_particle_fragment'] = \"#ifdef USE_MAP\\n\\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\n\nTHREE.ShaderChunk['map_particle_pars_fragment'] = \"#ifdef USE_MAP\\n\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\n\nTHREE.ShaderChunk['morphnormal_vertex'] = \"#ifdef USE_MORPHNORMALS\\n\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\n\nTHREE.ShaderChunk['morphtarget_pars_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n\t#ifndef USE_MORPHNORMALS\\n\\n\tuniform float morphTargetInfluences[ 8 ];\\n\\n\t#else\\n\\n\tuniform float morphTargetInfluences[ 4 ];\\n\\n\t#endif\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\n\nTHREE.ShaderChunk['morphtarget_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\n\t#ifndef USE_MORPHNORMALS\\n\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\n\t#endif\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\n\nTHREE.ShaderChunk['normalmap_pars_fragment'] = \"#ifdef USE_NORMALMAP\\n\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\\n\t// Per-Pixel Tangent Space Normal Mapping\\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\\n\t}\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\n\nTHREE.ShaderChunk['project_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n\\n#else\\n\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n\\n#endif\\n\\ngl_Position = projectionMatrix * mvPosition;\\n\"; // File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl\n\nTHREE.ShaderChunk['shadowmap_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n\t#ifdef SHADOWMAP_DEBUG\\n\\n\t\tvec3 frustumColors[3];\\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\n\\n\t#endif\\n\\n\tfloat fDepth;\\n\tvec3 shadowColor = vec3( 1.0 );\\n\\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\n\\n\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\\n\t\t\t\t// if ( all( something, something ) ) using this instead\\n\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\n\t\tbool frustumTest = all( frustumTestVec );\\n\\n\t\tif ( frustumTest ) {\\n\\n\t\t\tshadowCoord.z += shadowBias[ i ];\\n\\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\n\t\t\t\t\t\t// Percentage-close filtering\\n\t\t\t\t\t\t// (9 pixel kernel)\\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\t\t\t\tfloat shadow = 0.0;\\n\\n\t\t/*\\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\\n\t\t\t\t\t\t// must enroll loop manually\\n\\n\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\\n\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\\n\\n\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\\n\\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\\n\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\\n\\n\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\\n\t\t\t\t\t\t\tshadow += 1.0;\\n\\n\t\t\t\t}\\n\\n\t\t\t\tshadow /= 9.0;\\n\\n\t\t*/\\n\\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\\n\\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\n\t\t\t\t\t\t// Percentage-close filtering\\n\t\t\t\t\t\t// (9 pixel kernel)\\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\t\t\t\tfloat shadow = 0.0;\\n\\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\\n\\n\t\t\t\tmat3 shadowKernel;\\n\t\t\t\tmat3 depthKernel;\\n\\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\\n\\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\\n\\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\\n\\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\n\\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\n\\n\t\t\t\tvec4 shadowValues;\\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\n\\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\\n\\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\t\t\t#else\\n\\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\t\t\t\tif ( fDepth < shadowCoord.z )\\n\\n\t\t// spot with multiple shadows is darker\\n\\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\n\\n\t\t// spot with multiple shadows has the same color as single shadow spot\\n\\n\t\t// \t\t\t\t\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\\n\\n\t\t\t#endif\\n\\n\t\t}\\n\\n\\n\t\t#ifdef SHADOWMAP_DEBUG\\n\\n\t\t\tif ( inFrustum ) outgoingLight *= frustumColors[ i ];\\n\\n\t\t#endif\\n\\n\t}\\n\\n\toutgoingLight = outgoingLight * shadowColor;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\n\nTHREE.ShaderChunk['shadowmap_pars_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\\n\\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\\n\tuniform float shadowBias[ MAX_SHADOWS ];\\n\\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\\n\\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\t\tfloat depth = dot( rgba_depth, bit_shift );\\n\t\treturn depth;\\n\\n\t}\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\n\nTHREE.ShaderChunk['shadowmap_pars_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\n\nTHREE.ShaderChunk['shadowmap_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n\\n\t}\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\n\nTHREE.ShaderChunk['skinbase_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\n\nTHREE.ShaderChunk['skinning_pars_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\\n\t#ifdef BONE_TEXTURE\\n\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\n\t\t\ty = dy * ( y + 0.5 );\\n\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\n\t\t\treturn bone;\\n\\n\t\t}\\n\\n\t#else\\n\\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\n\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\\n\t\t}\\n\\n\t#endif\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\n\nTHREE.ShaderChunk['skinning_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\n\nTHREE.ShaderChunk['skinnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\n\nTHREE.ShaderChunk['specularmap_fragment'] = \"float specularStrength;\\n\\n#ifdef USE_SPECULARMAP\\n\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n\\n#else\\n\\n\tspecularStrength = 1.0;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\n\nTHREE.ShaderChunk['specularmap_pars_fragment'] = \"#ifdef USE_SPECULARMAP\\n\\n\tuniform sampler2D specularMap;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\n\nTHREE.ShaderChunk['uv2_pars_fragment'] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\n\tvarying vec2 vUv2;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\n\nTHREE.ShaderChunk['uv2_pars_vertex'] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\n\nTHREE.ShaderChunk['uv2_vertex'] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\n\tvUv2 = uv2;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\n\nTHREE.ShaderChunk['uv_pars_fragment'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\\n\\n\tvarying vec2 vUv;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\n\nTHREE.ShaderChunk['uv_pars_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\\n\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n\\n#endif\\n\"; // File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\n\nTHREE.ShaderChunk['uv_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\\n\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n\\n#endif\"; // File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\n\nTHREE.ShaderChunk['worldpos_vertex'] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\n\t#ifdef USE_SKINNING\\n\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\\n\t#else\\n\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\n\t#endif\\n\\n#endif\\n\"; // File:src/renderers/shaders/UniformsUtils.js\n\n/**\r\n * Uniform Utilities\r\n */\n\nTHREE.UniformsUtils = {\n  merge: function merge(uniforms) {\n    var merged = {};\n\n    for (var u = 0; u < uniforms.length; u++) {\n      var tmp = this.clone(uniforms[u]);\n\n      for (var p in tmp) {\n        merged[p] = tmp[p];\n      }\n    }\n\n    return merged;\n  },\n  clone: function clone(uniforms_src) {\n    var uniforms_dst = {};\n\n    for (var u in uniforms_src) {\n      uniforms_dst[u] = {};\n\n      for (var p in uniforms_src[u]) {\n        var parameter_src = uniforms_src[u][p];\n\n        if (parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix3 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture) {\n          uniforms_dst[u][p] = parameter_src.clone();\n        } else if (Array.isArray(parameter_src)) {\n          uniforms_dst[u][p] = parameter_src.slice();\n        } else {\n          uniforms_dst[u][p] = parameter_src;\n        }\n      }\n    }\n\n    return uniforms_dst;\n  }\n}; // File:src/renderers/shaders/UniformsLib.js\n\n/**\r\n * Uniforms library for shared webgl shaders\r\n */\n\nTHREE.UniformsLib = {\n  common: {\n    \"diffuse\": {\n      type: \"c\",\n      value: new THREE.Color(0xeeeeee)\n    },\n    \"opacity\": {\n      type: \"f\",\n      value: 1.0\n    },\n    \"map\": {\n      type: \"t\",\n      value: null\n    },\n    \"offsetRepeat\": {\n      type: \"v4\",\n      value: new THREE.Vector4(0, 0, 1, 1)\n    },\n    \"specularMap\": {\n      type: \"t\",\n      value: null\n    },\n    \"alphaMap\": {\n      type: \"t\",\n      value: null\n    },\n    \"envMap\": {\n      type: \"t\",\n      value: null\n    },\n    \"flipEnvMap\": {\n      type: \"f\",\n      value: -1\n    },\n    \"reflectivity\": {\n      type: \"f\",\n      value: 1.0\n    },\n    \"refractionRatio\": {\n      type: \"f\",\n      value: 0.98\n    }\n  },\n  aomap: {\n    \"aoMap\": {\n      type: \"t\",\n      value: null\n    },\n    \"aoMapIntensity\": {\n      type: \"f\",\n      value: 1\n    }\n  },\n  lightmap: {\n    \"lightMap\": {\n      type: \"t\",\n      value: null\n    },\n    \"lightMapIntensity\": {\n      type: \"f\",\n      value: 1\n    }\n  },\n  emissivemap: {\n    \"emissiveMap\": {\n      type: \"t\",\n      value: null\n    }\n  },\n  bumpmap: {\n    \"bumpMap\": {\n      type: \"t\",\n      value: null\n    },\n    \"bumpScale\": {\n      type: \"f\",\n      value: 1\n    }\n  },\n  normalmap: {\n    \"normalMap\": {\n      type: \"t\",\n      value: null\n    },\n    \"normalScale\": {\n      type: \"v2\",\n      value: new THREE.Vector2(1, 1)\n    }\n  },\n  displacementmap: {\n    \"displacementMap\": {\n      type: \"t\",\n      value: null\n    },\n    \"displacementScale\": {\n      type: \"f\",\n      value: 1\n    },\n    \"displacementBias\": {\n      type: \"f\",\n      value: 0\n    }\n  },\n  fog: {\n    \"fogDensity\": {\n      type: \"f\",\n      value: 0.00025\n    },\n    \"fogNear\": {\n      type: \"f\",\n      value: 1\n    },\n    \"fogFar\": {\n      type: \"f\",\n      value: 2000\n    },\n    \"fogColor\": {\n      type: \"c\",\n      value: new THREE.Color(0xffffff)\n    }\n  },\n  lights: {\n    \"ambientLightColor\": {\n      type: \"fv\",\n      value: []\n    },\n    \"directionalLightDirection\": {\n      type: \"fv\",\n      value: []\n    },\n    \"directionalLightColor\": {\n      type: \"fv\",\n      value: []\n    },\n    \"hemisphereLightDirection\": {\n      type: \"fv\",\n      value: []\n    },\n    \"hemisphereLightSkyColor\": {\n      type: \"fv\",\n      value: []\n    },\n    \"hemisphereLightGroundColor\": {\n      type: \"fv\",\n      value: []\n    },\n    \"pointLightColor\": {\n      type: \"fv\",\n      value: []\n    },\n    \"pointLightPosition\": {\n      type: \"fv\",\n      value: []\n    },\n    \"pointLightDistance\": {\n      type: \"fv1\",\n      value: []\n    },\n    \"pointLightDecay\": {\n      type: \"fv1\",\n      value: []\n    },\n    \"spotLightColor\": {\n      type: \"fv\",\n      value: []\n    },\n    \"spotLightPosition\": {\n      type: \"fv\",\n      value: []\n    },\n    \"spotLightDirection\": {\n      type: \"fv\",\n      value: []\n    },\n    \"spotLightDistance\": {\n      type: \"fv1\",\n      value: []\n    },\n    \"spotLightAngleCos\": {\n      type: \"fv1\",\n      value: []\n    },\n    \"spotLightExponent\": {\n      type: \"fv1\",\n      value: []\n    },\n    \"spotLightDecay\": {\n      type: \"fv1\",\n      value: []\n    }\n  },\n  points: {\n    \"psColor\": {\n      type: \"c\",\n      value: new THREE.Color(0xeeeeee)\n    },\n    \"opacity\": {\n      type: \"f\",\n      value: 1.0\n    },\n    \"size\": {\n      type: \"f\",\n      value: 1.0\n    },\n    \"scale\": {\n      type: \"f\",\n      value: 1.0\n    },\n    \"map\": {\n      type: \"t\",\n      value: null\n    },\n    \"offsetRepeat\": {\n      type: \"v4\",\n      value: new THREE.Vector4(0, 0, 1, 1)\n    },\n    \"fogDensity\": {\n      type: \"f\",\n      value: 0.00025\n    },\n    \"fogNear\": {\n      type: \"f\",\n      value: 1\n    },\n    \"fogFar\": {\n      type: \"f\",\n      value: 2000\n    },\n    \"fogColor\": {\n      type: \"c\",\n      value: new THREE.Color(0xffffff)\n    }\n  },\n  shadowmap: {\n    \"shadowMap\": {\n      type: \"tv\",\n      value: []\n    },\n    \"shadowMapSize\": {\n      type: \"v2v\",\n      value: []\n    },\n    \"shadowBias\": {\n      type: \"fv1\",\n      value: []\n    },\n    \"shadowDarkness\": {\n      type: \"fv1\",\n      value: []\n    },\n    \"shadowMatrix\": {\n      type: \"m4v\",\n      value: []\n    }\n  }\n}; // File:src/renderers/shaders/ShaderLib.js\n\n/**\r\n * Webgl Shader Library for three.js\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\n\nTHREE.ShaderLib = {\n  'basic': {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[\"common\"], THREE.UniformsLib[\"aomap\"], THREE.UniformsLib[\"fog\"], THREE.UniformsLib[\"shadowmap\"]]),\n    vertexShader: [THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"uv_pars_vertex\"], THREE.ShaderChunk[\"uv2_pars_vertex\"], THREE.ShaderChunk[\"envmap_pars_vertex\"], THREE.ShaderChunk[\"color_pars_vertex\"], THREE.ShaderChunk[\"morphtarget_pars_vertex\"], THREE.ShaderChunk[\"skinning_pars_vertex\"], THREE.ShaderChunk[\"shadowmap_pars_vertex\"], THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"], \"void main() {\", THREE.ShaderChunk[\"uv_vertex\"], THREE.ShaderChunk[\"uv2_vertex\"], THREE.ShaderChunk[\"color_vertex\"], THREE.ShaderChunk[\"skinbase_vertex\"], \"\t#ifdef USE_ENVMAP\", THREE.ShaderChunk[\"beginnormal_vertex\"], THREE.ShaderChunk[\"morphnormal_vertex\"], THREE.ShaderChunk[\"skinnormal_vertex\"], THREE.ShaderChunk[\"defaultnormal_vertex\"], \"\t#endif\", THREE.ShaderChunk[\"begin_vertex\"], THREE.ShaderChunk[\"morphtarget_vertex\"], THREE.ShaderChunk[\"skinning_vertex\"], THREE.ShaderChunk[\"project_vertex\"], THREE.ShaderChunk[\"logdepthbuf_vertex\"], THREE.ShaderChunk[\"worldpos_vertex\"], THREE.ShaderChunk[\"envmap_vertex\"], THREE.ShaderChunk[\"shadowmap_vertex\"], \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform vec3 diffuse;\", \"uniform float opacity;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"color_pars_fragment\"], THREE.ShaderChunk[\"uv_pars_fragment\"], THREE.ShaderChunk[\"uv2_pars_fragment\"], THREE.ShaderChunk[\"map_pars_fragment\"], THREE.ShaderChunk[\"alphamap_pars_fragment\"], THREE.ShaderChunk[\"aomap_pars_fragment\"], THREE.ShaderChunk[\"envmap_pars_fragment\"], THREE.ShaderChunk[\"fog_pars_fragment\"], THREE.ShaderChunk[\"shadowmap_pars_fragment\"], THREE.ShaderChunk[\"specularmap_pars_fragment\"], THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"], \"void main() {\", \"\tvec3 outgoingLight = vec3( 0.0 );\", \"\tvec4 diffuseColor = vec4( diffuse, opacity );\", \"\tvec3 totalAmbientLight = vec3( 1.0 );\", // hardwired\n    THREE.ShaderChunk[\"logdepthbuf_fragment\"], THREE.ShaderChunk[\"map_fragment\"], THREE.ShaderChunk[\"color_fragment\"], THREE.ShaderChunk[\"alphamap_fragment\"], THREE.ShaderChunk[\"alphatest_fragment\"], THREE.ShaderChunk[\"specularmap_fragment\"], THREE.ShaderChunk[\"aomap_fragment\"], \"\toutgoingLight = diffuseColor.rgb * totalAmbientLight;\", // simple shader\n    THREE.ShaderChunk[\"envmap_fragment\"], THREE.ShaderChunk[\"shadowmap_fragment\"], // TODO: Shadows on an otherwise unlit surface doesn't make sense.\n    THREE.ShaderChunk[\"linear_to_gamma_fragment\"], THREE.ShaderChunk[\"fog_fragment\"], \"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\", \"}\"].join(\"\\n\")\n  },\n  'lambert': {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[\"common\"], THREE.UniformsLib[\"fog\"], THREE.UniformsLib[\"lights\"], THREE.UniformsLib[\"shadowmap\"], {\n      \"emissive\": {\n        type: \"c\",\n        value: new THREE.Color(0x000000)\n      }\n    }]),\n    vertexShader: [\"#define LAMBERT\", \"varying vec3 vLightFront;\", \"#ifdef DOUBLE_SIDED\", \"\tvarying vec3 vLightBack;\", \"#endif\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"uv_pars_vertex\"], THREE.ShaderChunk[\"uv2_pars_vertex\"], THREE.ShaderChunk[\"envmap_pars_vertex\"], THREE.ShaderChunk[\"lights_lambert_pars_vertex\"], THREE.ShaderChunk[\"color_pars_vertex\"], THREE.ShaderChunk[\"morphtarget_pars_vertex\"], THREE.ShaderChunk[\"skinning_pars_vertex\"], THREE.ShaderChunk[\"shadowmap_pars_vertex\"], THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"], \"void main() {\", THREE.ShaderChunk[\"uv_vertex\"], THREE.ShaderChunk[\"uv2_vertex\"], THREE.ShaderChunk[\"color_vertex\"], THREE.ShaderChunk[\"beginnormal_vertex\"], THREE.ShaderChunk[\"morphnormal_vertex\"], THREE.ShaderChunk[\"skinbase_vertex\"], THREE.ShaderChunk[\"skinnormal_vertex\"], THREE.ShaderChunk[\"defaultnormal_vertex\"], THREE.ShaderChunk[\"begin_vertex\"], THREE.ShaderChunk[\"morphtarget_vertex\"], THREE.ShaderChunk[\"skinning_vertex\"], THREE.ShaderChunk[\"project_vertex\"], THREE.ShaderChunk[\"logdepthbuf_vertex\"], THREE.ShaderChunk[\"worldpos_vertex\"], THREE.ShaderChunk[\"envmap_vertex\"], THREE.ShaderChunk[\"lights_lambert_vertex\"], THREE.ShaderChunk[\"shadowmap_vertex\"], \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform vec3 diffuse;\", \"uniform vec3 emissive;\", \"uniform float opacity;\", \"varying vec3 vLightFront;\", \"#ifdef DOUBLE_SIDED\", \"\tvarying vec3 vLightBack;\", \"#endif\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"color_pars_fragment\"], THREE.ShaderChunk[\"uv_pars_fragment\"], THREE.ShaderChunk[\"uv2_pars_fragment\"], THREE.ShaderChunk[\"map_pars_fragment\"], THREE.ShaderChunk[\"alphamap_pars_fragment\"], THREE.ShaderChunk[\"envmap_pars_fragment\"], THREE.ShaderChunk[\"fog_pars_fragment\"], THREE.ShaderChunk[\"shadowmap_pars_fragment\"], THREE.ShaderChunk[\"specularmap_pars_fragment\"], THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"], \"void main() {\", \"\tvec3 outgoingLight = vec3( 0.0 );\", // outgoing light does not have an alpha, the surface does\n    \"\tvec4 diffuseColor = vec4( diffuse, opacity );\", THREE.ShaderChunk[\"logdepthbuf_fragment\"], THREE.ShaderChunk[\"map_fragment\"], THREE.ShaderChunk[\"color_fragment\"], THREE.ShaderChunk[\"alphamap_fragment\"], THREE.ShaderChunk[\"alphatest_fragment\"], THREE.ShaderChunk[\"specularmap_fragment\"], \"\t#ifdef DOUBLE_SIDED\", \"\t\tif ( gl_FrontFacing )\", \"\t\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\", \"\t\telse\", \"\t\t\toutgoingLight += diffuseColor.rgb * vLightBack + emissive;\", \"\t#else\", \"\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\", \"\t#endif\", THREE.ShaderChunk[\"envmap_fragment\"], THREE.ShaderChunk[\"shadowmap_fragment\"], THREE.ShaderChunk[\"linear_to_gamma_fragment\"], THREE.ShaderChunk[\"fog_fragment\"], \"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\", \"}\"].join(\"\\n\")\n  },\n  'phong': {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[\"common\"], THREE.UniformsLib[\"aomap\"], THREE.UniformsLib[\"lightmap\"], THREE.UniformsLib[\"emissivemap\"], THREE.UniformsLib[\"bumpmap\"], THREE.UniformsLib[\"normalmap\"], THREE.UniformsLib[\"displacementmap\"], THREE.UniformsLib[\"fog\"], THREE.UniformsLib[\"lights\"], THREE.UniformsLib[\"shadowmap\"], {\n      \"emissive\": {\n        type: \"c\",\n        value: new THREE.Color(0x000000)\n      },\n      \"specular\": {\n        type: \"c\",\n        value: new THREE.Color(0x111111)\n      },\n      \"shininess\": {\n        type: \"f\",\n        value: 30\n      }\n    }]),\n    vertexShader: [\"#define PHONG\", \"varying vec3 vViewPosition;\", \"#ifndef FLAT_SHADED\", \"\tvarying vec3 vNormal;\", \"#endif\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"uv_pars_vertex\"], THREE.ShaderChunk[\"uv2_pars_vertex\"], THREE.ShaderChunk[\"displacementmap_pars_vertex\"], THREE.ShaderChunk[\"envmap_pars_vertex\"], THREE.ShaderChunk[\"lights_phong_pars_vertex\"], THREE.ShaderChunk[\"color_pars_vertex\"], THREE.ShaderChunk[\"morphtarget_pars_vertex\"], THREE.ShaderChunk[\"skinning_pars_vertex\"], THREE.ShaderChunk[\"shadowmap_pars_vertex\"], THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"], \"void main() {\", THREE.ShaderChunk[\"uv_vertex\"], THREE.ShaderChunk[\"uv2_vertex\"], THREE.ShaderChunk[\"color_vertex\"], THREE.ShaderChunk[\"beginnormal_vertex\"], THREE.ShaderChunk[\"morphnormal_vertex\"], THREE.ShaderChunk[\"skinbase_vertex\"], THREE.ShaderChunk[\"skinnormal_vertex\"], THREE.ShaderChunk[\"defaultnormal_vertex\"], \"#ifndef FLAT_SHADED\", // Normal computed with derivatives when FLAT_SHADED\n    \"\tvNormal = normalize( transformedNormal );\", \"#endif\", THREE.ShaderChunk[\"begin_vertex\"], THREE.ShaderChunk[\"displacementmap_vertex\"], THREE.ShaderChunk[\"morphtarget_vertex\"], THREE.ShaderChunk[\"skinning_vertex\"], THREE.ShaderChunk[\"project_vertex\"], THREE.ShaderChunk[\"logdepthbuf_vertex\"], \"\tvViewPosition = - mvPosition.xyz;\", THREE.ShaderChunk[\"worldpos_vertex\"], THREE.ShaderChunk[\"envmap_vertex\"], THREE.ShaderChunk[\"lights_phong_vertex\"], THREE.ShaderChunk[\"shadowmap_vertex\"], \"}\"].join(\"\\n\"),\n    fragmentShader: [\"#define PHONG\", \"uniform vec3 diffuse;\", \"uniform vec3 emissive;\", \"uniform vec3 specular;\", \"uniform float shininess;\", \"uniform float opacity;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"color_pars_fragment\"], THREE.ShaderChunk[\"uv_pars_fragment\"], THREE.ShaderChunk[\"uv2_pars_fragment\"], THREE.ShaderChunk[\"map_pars_fragment\"], THREE.ShaderChunk[\"alphamap_pars_fragment\"], THREE.ShaderChunk[\"aomap_pars_fragment\"], THREE.ShaderChunk[\"lightmap_pars_fragment\"], THREE.ShaderChunk[\"emissivemap_pars_fragment\"], THREE.ShaderChunk[\"envmap_pars_fragment\"], THREE.ShaderChunk[\"fog_pars_fragment\"], THREE.ShaderChunk[\"lights_phong_pars_fragment\"], THREE.ShaderChunk[\"shadowmap_pars_fragment\"], THREE.ShaderChunk[\"bumpmap_pars_fragment\"], THREE.ShaderChunk[\"normalmap_pars_fragment\"], THREE.ShaderChunk[\"specularmap_pars_fragment\"], THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"], \"void main() {\", \"\tvec3 outgoingLight = vec3( 0.0 );\", \"\tvec4 diffuseColor = vec4( diffuse, opacity );\", \"\tvec3 totalAmbientLight = ambientLightColor;\", \"\tvec3 totalEmissiveLight = emissive;\", THREE.ShaderChunk[\"logdepthbuf_fragment\"], THREE.ShaderChunk[\"map_fragment\"], THREE.ShaderChunk[\"color_fragment\"], THREE.ShaderChunk[\"alphamap_fragment\"], THREE.ShaderChunk[\"alphatest_fragment\"], THREE.ShaderChunk[\"specularmap_fragment\"], THREE.ShaderChunk[\"lightmap_fragment\"], THREE.ShaderChunk[\"aomap_fragment\"], THREE.ShaderChunk[\"emissivemap_fragment\"], THREE.ShaderChunk[\"lights_phong_fragment\"], THREE.ShaderChunk[\"envmap_fragment\"], THREE.ShaderChunk[\"shadowmap_fragment\"], THREE.ShaderChunk[\"linear_to_gamma_fragment\"], THREE.ShaderChunk[\"fog_fragment\"], \"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\", \"}\"].join(\"\\n\")\n  },\n  'points': {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[\"points\"], THREE.UniformsLib[\"shadowmap\"]]),\n    vertexShader: [\"uniform float size;\", \"uniform float scale;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"color_pars_vertex\"], THREE.ShaderChunk[\"shadowmap_pars_vertex\"], THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"], \"void main() {\", THREE.ShaderChunk[\"color_vertex\"], \"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", \"\t#ifdef USE_SIZEATTENUATION\", \"\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\", \"\t#else\", \"\t\tgl_PointSize = size;\", \"\t#endif\", \"\tgl_Position = projectionMatrix * mvPosition;\", THREE.ShaderChunk[\"logdepthbuf_vertex\"], THREE.ShaderChunk[\"worldpos_vertex\"], THREE.ShaderChunk[\"shadowmap_vertex\"], \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform vec3 psColor;\", \"uniform float opacity;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"color_pars_fragment\"], THREE.ShaderChunk[\"map_particle_pars_fragment\"], THREE.ShaderChunk[\"fog_pars_fragment\"], THREE.ShaderChunk[\"shadowmap_pars_fragment\"], THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"], \"void main() {\", \"\tvec3 outgoingLight = vec3( 0.0 );\", \"\tvec4 diffuseColor = vec4( psColor, opacity );\", THREE.ShaderChunk[\"logdepthbuf_fragment\"], THREE.ShaderChunk[\"map_particle_fragment\"], THREE.ShaderChunk[\"color_fragment\"], THREE.ShaderChunk[\"alphatest_fragment\"], \"\toutgoingLight = diffuseColor.rgb;\", // simple shader\n    THREE.ShaderChunk[\"shadowmap_fragment\"], THREE.ShaderChunk[\"fog_fragment\"], \"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\", \"}\"].join(\"\\n\")\n  },\n  'dashed': {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[\"common\"], THREE.UniformsLib[\"fog\"], {\n      \"scale\": {\n        type: \"f\",\n        value: 1\n      },\n      \"dashSize\": {\n        type: \"f\",\n        value: 1\n      },\n      \"totalSize\": {\n        type: \"f\",\n        value: 2\n      }\n    }]),\n    vertexShader: [\"uniform float scale;\", \"attribute float lineDistance;\", \"varying float vLineDistance;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"color_pars_vertex\"], THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"], \"void main() {\", THREE.ShaderChunk[\"color_vertex\"], \"\tvLineDistance = scale * lineDistance;\", \"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", \"\tgl_Position = projectionMatrix * mvPosition;\", THREE.ShaderChunk[\"logdepthbuf_vertex\"], \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform vec3 diffuse;\", \"uniform float opacity;\", \"uniform float dashSize;\", \"uniform float totalSize;\", \"varying float vLineDistance;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"color_pars_fragment\"], THREE.ShaderChunk[\"fog_pars_fragment\"], THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"], \"void main() {\", \"\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\", \"\t\tdiscard;\", \"\t}\", \"\tvec3 outgoingLight = vec3( 0.0 );\", \"\tvec4 diffuseColor = vec4( diffuse, opacity );\", THREE.ShaderChunk[\"logdepthbuf_fragment\"], THREE.ShaderChunk[\"color_fragment\"], \"\toutgoingLight = diffuseColor.rgb;\", // simple shader\n    THREE.ShaderChunk[\"fog_fragment\"], \"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\", \"}\"].join(\"\\n\")\n  },\n  'depth': {\n    uniforms: {\n      \"mNear\": {\n        type: \"f\",\n        value: 1.0\n      },\n      \"mFar\": {\n        type: \"f\",\n        value: 2000.0\n      },\n      \"opacity\": {\n        type: \"f\",\n        value: 1.0\n      }\n    },\n    vertexShader: [THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"morphtarget_pars_vertex\"], THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"], \"void main() {\", THREE.ShaderChunk[\"begin_vertex\"], THREE.ShaderChunk[\"morphtarget_vertex\"], THREE.ShaderChunk[\"project_vertex\"], THREE.ShaderChunk[\"logdepthbuf_vertex\"], \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform float mNear;\", \"uniform float mFar;\", \"uniform float opacity;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"], \"void main() {\", THREE.ShaderChunk[\"logdepthbuf_fragment\"], \"\t#ifdef USE_LOGDEPTHBUF_EXT\", \"\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\", \"\t#else\", \"\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\", \"\t#endif\", \"\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\", \"\tgl_FragColor = vec4( vec3( color ), opacity );\", \"}\"].join(\"\\n\")\n  },\n  'normal': {\n    uniforms: {\n      \"opacity\": {\n        type: \"f\",\n        value: 1.0\n      }\n    },\n    vertexShader: [\"varying vec3 vNormal;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"morphtarget_pars_vertex\"], THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"], \"void main() {\", \"\tvNormal = normalize( normalMatrix * normal );\", THREE.ShaderChunk[\"begin_vertex\"], THREE.ShaderChunk[\"morphtarget_vertex\"], THREE.ShaderChunk[\"project_vertex\"], THREE.ShaderChunk[\"logdepthbuf_vertex\"], \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform float opacity;\", \"varying vec3 vNormal;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"], \"void main() {\", \"\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\", THREE.ShaderChunk[\"logdepthbuf_fragment\"], \"}\"].join(\"\\n\")\n  },\n\n  /* -------------------------------------------------------------------------\r\n  //\tCube map shader\r\n   ------------------------------------------------------------------------- */\n  'cube': {\n    uniforms: {\n      \"tCube\": {\n        type: \"t\",\n        value: null\n      },\n      \"tFlip\": {\n        type: \"f\",\n        value: -1\n      }\n    },\n    vertexShader: [\"varying vec3 vWorldPosition;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"], \"void main() {\", \"\tvWorldPosition = transformDirection( position, modelMatrix );\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", THREE.ShaderChunk[\"logdepthbuf_vertex\"], \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform samplerCube tCube;\", \"uniform float tFlip;\", \"varying vec3 vWorldPosition;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"], \"void main() {\", \"\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\", THREE.ShaderChunk[\"logdepthbuf_fragment\"], \"}\"].join(\"\\n\")\n  },\n\n  /* -------------------------------------------------------------------------\r\n  //\tCube map shader\r\n   ------------------------------------------------------------------------- */\n  'equirect': {\n    uniforms: {\n      \"tEquirect\": {\n        type: \"t\",\n        value: null\n      },\n      \"tFlip\": {\n        type: \"f\",\n        value: -1\n      }\n    },\n    vertexShader: [\"varying vec3 vWorldPosition;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"], \"void main() {\", \"\tvWorldPosition = transformDirection( position, modelMatrix );\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", THREE.ShaderChunk[\"logdepthbuf_vertex\"], \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform sampler2D tEquirect;\", \"uniform float tFlip;\", \"varying vec3 vWorldPosition;\", THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"], \"void main() {\", // \"\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\n    \"vec3 direction = normalize( vWorldPosition );\", \"vec2 sampleUV;\", \"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\", \"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\", \"gl_FragColor = texture2D( tEquirect, sampleUV );\", THREE.ShaderChunk[\"logdepthbuf_fragment\"], \"}\"].join(\"\\n\")\n  },\n\n  /* Depth encoding into RGBA texture\r\n   *\r\n   * based on SpiderGL shadow map example\r\n   * http://spidergl.org/example.php?id=6\r\n   *\r\n   * originally from\r\n   * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n   *\r\n   * see also\r\n   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n   */\n  'depthRGBA': {\n    uniforms: {},\n    vertexShader: [THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"morphtarget_pars_vertex\"], THREE.ShaderChunk[\"skinning_pars_vertex\"], THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"], \"void main() {\", THREE.ShaderChunk[\"skinbase_vertex\"], THREE.ShaderChunk[\"begin_vertex\"], THREE.ShaderChunk[\"morphtarget_vertex\"], THREE.ShaderChunk[\"skinning_vertex\"], THREE.ShaderChunk[\"project_vertex\"], THREE.ShaderChunk[\"logdepthbuf_vertex\"], \"}\"].join(\"\\n\"),\n    fragmentShader: [THREE.ShaderChunk[\"common\"], THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"], \"vec4 pack_depth( const in float depth ) {\", \"\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\", \"\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\", \"\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\", // \"\tvec4 res = fract( depth * bit_shift );\",\n    \"\tres -= res.xxyz * bit_mask;\", \"\treturn res;\", \"}\", \"void main() {\", THREE.ShaderChunk[\"logdepthbuf_fragment\"], \"\t#ifdef USE_LOGDEPTHBUF_EXT\", \"\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\", \"\t#else\", \"\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\", \"\t#endif\", //\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\n    //\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\n    //\"gl_FragData[ 0 ] = pack_depth( z );\",\n    //\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\n    \"}\"].join(\"\\n\")\n  }\n}; // File:src/renderers/WebGLRenderer.js\n\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\n\nTHREE.WebGLRenderer = function (parameters) {\n  console.log('THREE.WebGLRenderer', THREE.REVISION);\n  parameters = parameters || {};\n\n  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'),\n      _context = parameters.context !== undefined ? parameters.context : null,\n      _width = _canvas.width,\n      _height = _canvas.height,\n      pixelRatio = 1,\n      _alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n      _depth = parameters.depth !== undefined ? parameters.depth : true,\n      _stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n      _antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n      _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n      _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n      _clearColor = new THREE.Color(0x000000),\n      _clearAlpha = 0;\n\n  var lights = [];\n  var opaqueObjects = [];\n  var opaqueObjectsLastIndex = -1;\n  var transparentObjects = [];\n  var transparentObjectsLastIndex = -1;\n  var opaqueImmediateObjects = [];\n  var opaqueImmediateObjectsLastIndex = -1;\n  var transparentImmediateObjects = [];\n  var transparentImmediateObjectsLastIndex = -1;\n  var morphInfluences = new Float32Array(8);\n  var sprites = [];\n  var lensFlares = []; // public properties\n\n  this.domElement = _canvas;\n  this.context = null; // clearing\n\n  this.autoClear = true;\n  this.autoClearColor = true;\n  this.autoClearDepth = true;\n  this.autoClearStencil = true; // scene graph\n\n  this.sortObjects = true; // physically based shading\n\n  this.gammaFactor = 2.0; // for backwards compatibility\n\n  this.gammaInput = false;\n  this.gammaOutput = false; // morphs\n\n  this.maxMorphTargets = 8;\n  this.maxMorphNormals = 4; // flags\n\n  this.autoScaleCubemaps = true; // internal properties\n\n  var _this = this,\n      // internal state cache\n  _currentProgram = null,\n      _currentFramebuffer = null,\n      _currentMaterialId = -1,\n      _currentGeometryProgram = '',\n      _currentCamera = null,\n      _usedTextureUnits = 0,\n      _viewportX = 0,\n      _viewportY = 0,\n      _viewportWidth = _canvas.width,\n      _viewportHeight = _canvas.height,\n      _currentWidth = 0,\n      _currentHeight = 0,\n      // frustum\n  _frustum = new THREE.Frustum(),\n      // camera matrices cache\n  _projScreenMatrix = new THREE.Matrix4(),\n      _vector3 = new THREE.Vector3(),\n      // light arrays cache\n  _direction = new THREE.Vector3(),\n      _lightsNeedUpdate = true,\n      _lights = {\n    ambient: [0, 0, 0],\n    directional: {\n      length: 0,\n      colors: [],\n      positions: []\n    },\n    point: {\n      length: 0,\n      colors: [],\n      positions: [],\n      distances: [],\n      decays: []\n    },\n    spot: {\n      length: 0,\n      colors: [],\n      positions: [],\n      distances: [],\n      directions: [],\n      anglesCos: [],\n      exponents: [],\n      decays: []\n    },\n    hemi: {\n      length: 0,\n      skyColors: [],\n      groundColors: [],\n      positions: []\n    }\n  },\n      // info\n  _infoMemory = {\n    geometries: 0,\n    textures: 0\n  },\n      _infoRender = {\n    calls: 0,\n    vertices: 0,\n    faces: 0,\n    points: 0\n  };\n\n  this.info = {\n    render: _infoRender,\n    memory: _infoMemory,\n    programs: null\n  }; // initialize\n\n  var _gl;\n\n  try {\n    var attributes = {\n      alpha: _alpha,\n      depth: _depth,\n      stencil: _stencil,\n      antialias: _antialias,\n      premultipliedAlpha: _premultipliedAlpha,\n      preserveDrawingBuffer: _preserveDrawingBuffer\n    };\n    _gl = _context || _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);\n\n    if (_gl === null) {\n      if (_canvas.getContext('webgl') !== null) {\n        throw 'Error creating WebGL context with your selected attributes.';\n      } else {\n        throw 'Error creating WebGL context.';\n      }\n    }\n\n    _canvas.addEventListener('webglcontextlost', onContextLost, false);\n  } catch (error) {\n    console.error('THREE.WebGLRenderer: ' + error);\n  }\n\n  var extensions = new THREE.WebGLExtensions(_gl);\n  extensions.get('OES_texture_float');\n  extensions.get('OES_texture_float_linear');\n  extensions.get('OES_texture_half_float');\n  extensions.get('OES_texture_half_float_linear');\n  extensions.get('OES_standard_derivatives');\n  extensions.get('ANGLE_instanced_arrays');\n\n  if (extensions.get('OES_element_index_uint')) {\n    THREE.BufferGeometry.MaxIndex = 4294967296;\n  }\n\n  var capabilities = new THREE.WebGLCapabilities(_gl, extensions, parameters);\n  var state = new THREE.WebGLState(_gl, extensions, paramThreeToGL);\n  var properties = new THREE.WebGLProperties();\n  var objects = new THREE.WebGLObjects(_gl, properties, this.info);\n  var programCache = new THREE.WebGLPrograms(this, capabilities);\n  this.info.programs = programCache.programs;\n  var bufferRenderer = new THREE.WebGLBufferRenderer(_gl, extensions, _infoRender);\n  var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer(_gl, extensions, _infoRender); //\n\n  function glClearColor(r, g, b, a) {\n    if (_premultipliedAlpha === true) {\n      r *= a;\n      g *= a;\n      b *= a;\n    }\n\n    _gl.clearColor(r, g, b, a);\n  }\n\n  function setDefaultGLState() {\n    state.init();\n\n    _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);\n\n    glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);\n  }\n\n  function resetGLState() {\n    _currentProgram = null;\n    _currentCamera = null;\n    _currentGeometryProgram = '';\n    _currentMaterialId = -1;\n    _lightsNeedUpdate = true;\n    state.reset();\n  }\n\n  setDefaultGLState();\n  this.context = _gl;\n  this.capabilities = capabilities;\n  this.extensions = extensions;\n  this.state = state; // shadow map\n\n  var shadowMap = new THREE.WebGLShadowMap(this, lights, objects);\n  this.shadowMap = shadowMap; // Plugins\n\n  var spritePlugin = new THREE.SpritePlugin(this, sprites);\n  var lensFlarePlugin = new THREE.LensFlarePlugin(this, lensFlares); // API\n\n  this.getContext = function () {\n    return _gl;\n  };\n\n  this.getContextAttributes = function () {\n    return _gl.getContextAttributes();\n  };\n\n  this.forceContextLoss = function () {\n    extensions.get('WEBGL_lose_context').loseContext();\n  };\n\n  this.getMaxAnisotropy = function () {\n    var value;\n    return function getMaxAnisotropy() {\n      if (value !== undefined) return value;\n      var extension = extensions.get('EXT_texture_filter_anisotropic');\n\n      if (extension !== null) {\n        value = _gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n      } else {\n        value = 0;\n      }\n\n      return value;\n    };\n  }();\n\n  this.getPrecision = function () {\n    return capabilities.precision;\n  };\n\n  this.getPixelRatio = function () {\n    return pixelRatio;\n  };\n\n  this.setPixelRatio = function (value) {\n    if (value !== undefined) pixelRatio = value;\n  };\n\n  this.getSize = function () {\n    return {\n      width: _width,\n      height: _height\n    };\n  };\n\n  this.setSize = function (width, height, updateStyle) {\n    _width = width;\n    _height = height;\n    _canvas.width = width * pixelRatio;\n    _canvas.height = height * pixelRatio;\n\n    if (updateStyle !== false) {\n      _canvas.style.width = width + 'px';\n      _canvas.style.height = height + 'px';\n    }\n\n    this.setViewport(0, 0, width, height);\n  };\n\n  this.setViewport = function (x, y, width, height) {\n    _viewportX = x * pixelRatio;\n    _viewportY = y * pixelRatio;\n    _viewportWidth = width * pixelRatio;\n    _viewportHeight = height * pixelRatio;\n\n    _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);\n  };\n\n  this.setScissor = function (x, y, width, height) {\n    _gl.scissor(x * pixelRatio, y * pixelRatio, width * pixelRatio, height * pixelRatio);\n  };\n\n  this.enableScissorTest = function (boolean) {\n    state.setScissorTest(boolean);\n  }; // Clearing\n\n\n  this.getClearColor = function () {\n    return _clearColor;\n  };\n\n  this.setClearColor = function (color, alpha) {\n    _clearColor.set(color);\n\n    _clearAlpha = alpha !== undefined ? alpha : 1;\n    glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);\n  };\n\n  this.getClearAlpha = function () {\n    return _clearAlpha;\n  };\n\n  this.setClearAlpha = function (alpha) {\n    _clearAlpha = alpha;\n    glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);\n  };\n\n  this.clear = function (color, depth, stencil) {\n    var bits = 0;\n    if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;\n    if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;\n    if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;\n\n    _gl.clear(bits);\n  };\n\n  this.clearColor = function () {\n    _gl.clear(_gl.COLOR_BUFFER_BIT);\n  };\n\n  this.clearDepth = function () {\n    _gl.clear(_gl.DEPTH_BUFFER_BIT);\n  };\n\n  this.clearStencil = function () {\n    _gl.clear(_gl.STENCIL_BUFFER_BIT);\n  };\n\n  this.clearTarget = function (renderTarget, color, depth, stencil) {\n    this.setRenderTarget(renderTarget);\n    this.clear(color, depth, stencil);\n  }; // Reset\n\n\n  this.resetGLState = resetGLState;\n\n  this.dispose = function () {\n    _canvas.removeEventListener('webglcontextlost', onContextLost, false);\n  }; // Events\n\n\n  function onContextLost(event) {\n    event.preventDefault();\n    resetGLState();\n    setDefaultGLState();\n    properties.clear();\n  }\n\n  ;\n\n  function onTextureDispose(event) {\n    var texture = event.target;\n    texture.removeEventListener('dispose', onTextureDispose);\n    deallocateTexture(texture);\n    _infoMemory.textures--;\n  }\n\n  function onRenderTargetDispose(event) {\n    var renderTarget = event.target;\n    renderTarget.removeEventListener('dispose', onRenderTargetDispose);\n    deallocateRenderTarget(renderTarget);\n    _infoMemory.textures--;\n  }\n\n  function onMaterialDispose(event) {\n    var material = event.target;\n    material.removeEventListener('dispose', onMaterialDispose);\n    deallocateMaterial(material);\n  } // Buffer deallocation\n\n\n  function deallocateTexture(texture) {\n    var textureProperties = properties.get(texture);\n\n    if (texture.image && textureProperties.__image__webglTextureCube) {\n      // cube texture\n      _gl.deleteTexture(textureProperties.__image__webglTextureCube);\n    } else {\n      // 2D texture\n      if (textureProperties.__webglInit === undefined) return;\n\n      _gl.deleteTexture(textureProperties.__webglTexture);\n    } // remove all webgl properties\n\n\n    properties.delete(texture);\n  }\n\n  function deallocateRenderTarget(renderTarget) {\n    var renderTargetProperties = properties.get(renderTarget);\n    if (!renderTarget || renderTargetProperties.__webglTexture === undefined) return;\n\n    _gl.deleteTexture(renderTargetProperties.__webglTexture);\n\n    if (renderTarget instanceof THREE.WebGLRenderTargetCube) {\n      for (var i = 0; i < 6; i++) {\n        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\n\n        _gl.deleteRenderbuffer(renderTargetProperties.__webglRenderbuffer[i]);\n      }\n    } else {\n      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\n\n      _gl.deleteRenderbuffer(renderTargetProperties.__webglRenderbuffer);\n    }\n\n    properties.delete(renderTarget);\n  }\n\n  function deallocateMaterial(material) {\n    releaseMaterialProgramReference(material);\n    properties.delete(material);\n  }\n\n  function releaseMaterialProgramReference(material) {\n    var programInfo = properties.get(material).program;\n    material.program = undefined;\n\n    if (programInfo !== undefined) {\n      programCache.releaseProgram(programInfo);\n    }\n  } // Buffer rendering\n\n\n  this.renderBufferImmediate = function (object, program, material) {\n    state.initAttributes();\n    var buffers = properties.get(object);\n    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();\n    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();\n    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();\n    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();\n    var attributes = program.getAttributes();\n\n    if (object.hasPositions) {\n      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);\n\n      _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);\n\n      state.enableAttribute(attributes.position);\n\n      _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);\n    }\n\n    if (object.hasNormals) {\n      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);\n\n      if (material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading) {\n        for (var i = 0, l = object.count * 3; i < l; i += 9) {\n          var array = object.normalArray;\n          var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;\n          var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;\n          var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;\n          array[i + 0] = nx;\n          array[i + 1] = ny;\n          array[i + 2] = nz;\n          array[i + 3] = nx;\n          array[i + 4] = ny;\n          array[i + 5] = nz;\n          array[i + 6] = nx;\n          array[i + 7] = ny;\n          array[i + 8] = nz;\n        }\n      }\n\n      _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);\n\n      state.enableAttribute(attributes.normal);\n\n      _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);\n    }\n\n    if (object.hasUvs && material.map) {\n      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);\n\n      _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);\n\n      state.enableAttribute(attributes.uv);\n\n      _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);\n    }\n\n    if (object.hasColors && material.vertexColors !== THREE.NoColors) {\n      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);\n\n      _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);\n\n      state.enableAttribute(attributes.color);\n\n      _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);\n    }\n\n    state.disableUnusedAttributes();\n\n    _gl.drawArrays(_gl.TRIANGLES, 0, object.count);\n\n    object.count = 0;\n  };\n\n  this.renderBufferDirect = function (camera, lights, fog, geometry, material, object, group) {\n    setMaterial(material);\n    var program = setProgram(camera, lights, fog, material, object);\n    var updateBuffers = false;\n    var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n    if (geometryProgram !== _currentGeometryProgram) {\n      _currentGeometryProgram = geometryProgram;\n      updateBuffers = true;\n    } // morph targets\n\n\n    var morphTargetInfluences = object.morphTargetInfluences;\n\n    if (morphTargetInfluences !== undefined) {\n      var activeInfluences = [];\n\n      for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {\n        var influence = morphTargetInfluences[i];\n        activeInfluences.push([influence, i]);\n      }\n\n      activeInfluences.sort(numericalSort);\n\n      if (activeInfluences.length > 8) {\n        activeInfluences.length = 8;\n      }\n\n      var morphAttributes = geometry.morphAttributes;\n\n      for (var i = 0, l = activeInfluences.length; i < l; i++) {\n        var influence = activeInfluences[i];\n        morphInfluences[i] = influence[0];\n\n        if (influence[0] !== 0) {\n          var index = influence[1];\n          if (material.morphTargets === true && morphAttributes.position) geometry.addAttribute('morphTarget' + i, morphAttributes.position[index]);\n          if (material.morphNormals === true && morphAttributes.normal) geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index]);\n        } else {\n          if (material.morphTargets === true) geometry.removeAttribute('morphTarget' + i);\n          if (material.morphNormals === true) geometry.removeAttribute('morphNormal' + i);\n        }\n      }\n\n      var uniforms = program.getUniforms();\n\n      if (uniforms.morphTargetInfluences !== null) {\n        _gl.uniform1fv(uniforms.morphTargetInfluences, morphInfluences);\n      }\n\n      updateBuffers = true;\n    } //\n\n\n    var index = geometry.index;\n    var position = geometry.attributes.position;\n\n    if (material.wireframe === true) {\n      index = objects.getWireframeAttribute(geometry);\n    }\n\n    var renderer;\n\n    if (index !== null) {\n      renderer = indexedBufferRenderer;\n      renderer.setIndex(index);\n    } else {\n      renderer = bufferRenderer;\n    }\n\n    if (updateBuffers) {\n      setupVertexAttributes(material, program, geometry);\n\n      if (index !== null) {\n        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index));\n      }\n    }\n\n    if (group === undefined) {\n      var count;\n\n      if (index !== null) {\n        count = index.count;\n      } else if (position instanceof THREE.InterleavedBufferAttribute) {\n        count = position.data.array.length / 3;\n      } else {\n        count = position.count;\n      }\n\n      var drawRange = geometry.drawRange;\n      group = {\n        start: drawRange.start,\n        count: Math.min(drawRange.count, count)\n      };\n    }\n\n    if (object instanceof THREE.Mesh) {\n      if (material.wireframe === true) {\n        state.setLineWidth(material.wireframeLinewidth * pixelRatio);\n        renderer.setMode(_gl.LINES);\n      } else {\n        renderer.setMode(_gl.TRIANGLES);\n      }\n\n      if (geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0) {\n        renderer.renderInstances(geometry);\n      } else {\n        renderer.render(group.start, group.count);\n      }\n    } else if (object instanceof THREE.Line) {\n      var lineWidth = material.linewidth;\n      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material\n\n      state.setLineWidth(lineWidth * pixelRatio);\n\n      if (object instanceof THREE.LineSegments) {\n        renderer.setMode(_gl.LINES);\n      } else {\n        renderer.setMode(_gl.LINE_STRIP);\n      }\n\n      renderer.render(group.start, group.count);\n    } else if (object instanceof THREE.Points) {\n      renderer.setMode(_gl.POINTS);\n      renderer.render(group.start, group.count);\n    }\n  };\n\n  function setupVertexAttributes(material, program, geometry, startIndex) {\n    var extension;\n\n    if (geometry instanceof THREE.InstancedBufferGeometry) {\n      extension = extensions.get('ANGLE_instanced_arrays');\n\n      if (extension === null) {\n        console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\n        return;\n      }\n    }\n\n    if (startIndex === undefined) startIndex = 0;\n    state.initAttributes();\n    var geometryAttributes = geometry.attributes;\n    var programAttributes = program.getAttributes();\n    var materialDefaultAttributeValues = material.defaultAttributeValues;\n\n    for (var name in programAttributes) {\n      var programAttribute = programAttributes[name];\n\n      if (programAttribute >= 0) {\n        var geometryAttribute = geometryAttributes[name];\n\n        if (geometryAttribute !== undefined) {\n          state.enableAttribute(programAttribute);\n          var size = geometryAttribute.itemSize;\n          var buffer = objects.getAttributeBuffer(geometryAttribute);\n\n          if (geometryAttribute instanceof THREE.InterleavedBufferAttribute) {\n            var data = geometryAttribute.data;\n            var stride = data.stride;\n            var offset = geometryAttribute.offset;\n\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);\n\n            _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);\n\n            if (data instanceof THREE.InstancedInterleavedBuffer) {\n              if (extension === null) {\n                console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.');\n                return;\n              }\n\n              extension.vertexAttribDivisorANGLE(programAttribute, data.meshPerAttribute);\n\n              if (geometry.maxInstancedCount === undefined) {\n                geometry.maxInstancedCount = data.meshPerAttribute * data.count;\n              }\n            }\n          } else {\n            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);\n\n            _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4); // 4 bytes per Float32\n\n\n            if (geometryAttribute instanceof THREE.InstancedBufferAttribute) {\n              if (extension === null) {\n                console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.');\n                return;\n              }\n\n              extension.vertexAttribDivisorANGLE(programAttribute, geometryAttribute.meshPerAttribute);\n\n              if (geometry.maxInstancedCount === undefined) {\n                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n              }\n            }\n          }\n        } else if (materialDefaultAttributeValues !== undefined) {\n          var value = materialDefaultAttributeValues[name];\n\n          if (value !== undefined) {\n            switch (value.length) {\n              case 2:\n                _gl.vertexAttrib2fv(programAttribute, value);\n\n                break;\n\n              case 3:\n                _gl.vertexAttrib3fv(programAttribute, value);\n\n                break;\n\n              case 4:\n                _gl.vertexAttrib4fv(programAttribute, value);\n\n                break;\n\n              default:\n                _gl.vertexAttrib1fv(programAttribute, value);\n\n            }\n          }\n        }\n      }\n    }\n\n    state.disableUnusedAttributes();\n  } // Sorting\n\n\n  function numericalSort(a, b) {\n    return b[0] - a[0];\n  }\n\n  function painterSortStable(a, b) {\n    if (a.object.renderOrder !== b.object.renderOrder) {\n      return a.object.renderOrder - b.object.renderOrder;\n    } else if (a.material.id !== b.material.id) {\n      return a.material.id - b.material.id;\n    } else if (a.z !== b.z) {\n      return a.z - b.z;\n    } else {\n      return a.id - b.id;\n    }\n  }\n\n  function reversePainterSortStable(a, b) {\n    if (a.object.renderOrder !== b.object.renderOrder) {\n      return a.object.renderOrder - b.object.renderOrder;\n    }\n\n    if (a.z !== b.z) {\n      return b.z - a.z;\n    } else {\n      return a.id - b.id;\n    }\n  } // Rendering\n\n\n  this.render = function (scene, camera, renderTarget, forceClear) {\n    if (camera instanceof THREE.Camera === false) {\n      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');\n      return;\n    }\n\n    var fog = scene.fog; // reset caching for this frame\n\n    _currentGeometryProgram = '';\n    _currentMaterialId = -1;\n    _currentCamera = null;\n    _lightsNeedUpdate = true; // update scene graph\n\n    if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum\n\n    if (camera.parent === null) camera.updateMatrixWorld();\n    camera.matrixWorldInverse.getInverse(camera.matrixWorld);\n\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n    _frustum.setFromMatrix(_projScreenMatrix);\n\n    lights.length = 0;\n    opaqueObjectsLastIndex = -1;\n    transparentObjectsLastIndex = -1;\n    opaqueImmediateObjectsLastIndex = -1;\n    transparentImmediateObjectsLastIndex = -1;\n    sprites.length = 0;\n    lensFlares.length = 0;\n    projectObject(scene);\n    opaqueObjects.length = opaqueObjectsLastIndex + 1;\n    transparentObjects.length = transparentObjectsLastIndex + 1;\n    opaqueImmediateObjects.length = opaqueImmediateObjectsLastIndex + 1;\n    transparentImmediateObjects.length = transparentImmediateObjectsLastIndex + 1;\n\n    if (_this.sortObjects === true) {\n      opaqueObjects.sort(painterSortStable);\n      transparentObjects.sort(reversePainterSortStable);\n    } //\n\n\n    shadowMap.render(scene, camera); //\n\n    _infoRender.calls = 0;\n    _infoRender.vertices = 0;\n    _infoRender.faces = 0;\n    _infoRender.points = 0;\n    this.setRenderTarget(renderTarget);\n\n    if (this.autoClear || forceClear) {\n      this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);\n    } //\n\n\n    if (scene.overrideMaterial) {\n      var overrideMaterial = scene.overrideMaterial;\n      renderObjects(opaqueObjects, camera, lights, fog, overrideMaterial);\n      renderObjects(transparentObjects, camera, lights, fog, overrideMaterial);\n      renderObjectsImmediate(opaqueImmediateObjects, camera, lights, fog, overrideMaterial);\n      renderObjectsImmediate(transparentImmediateObjects, camera, lights, fog, overrideMaterial);\n    } else {\n      // opaque pass (front-to-back order)\n      state.setBlending(THREE.NoBlending);\n      renderObjects(opaqueObjects, camera, lights, fog);\n      renderObjectsImmediate(opaqueImmediateObjects, camera, lights, fog); // transparent pass (back-to-front order)\n\n      renderObjects(transparentObjects, camera, lights, fog);\n      renderObjectsImmediate(transparentImmediateObjects, camera, lights, fog);\n    } // custom render plugins (post pass)\n\n\n    spritePlugin.render(scene, camera);\n    lensFlarePlugin.render(scene, camera, _currentWidth, _currentHeight); // Generate mipmap if we're using any kind of mipmap filtering\n\n    if (renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter) {\n      updateRenderTargetMipmap(renderTarget);\n    } // Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\n    state.setDepthTest(true);\n    state.setDepthWrite(true);\n    state.setColorWrite(true); // _gl.finish();\n  };\n\n  function pushImmediateRenderItem(object) {\n    var array, index; // allocate the next position in the appropriate array\n\n    if (object.material.transparent) {\n      array = transparentImmediateObjects;\n      index = ++transparentImmediateObjectsLastIndex;\n    } else {\n      array = opaqueImmediateObjects;\n      index = ++opaqueImmediateObjectsLastIndex;\n    } // recycle existing position or grow the array\n\n\n    if (index < array.length) {\n      array[index] = object;\n    } else {\n      // assert( index === array.length );\n      array.push(object);\n    }\n  }\n\n  function pushRenderItem(object, geometry, material, z, group) {\n    var array, index; // allocate the next position in the appropriate array\n\n    if (material.transparent) {\n      array = transparentObjects;\n      index = ++transparentObjectsLastIndex;\n    } else {\n      array = opaqueObjects;\n      index = ++opaqueObjectsLastIndex;\n    } // recycle existing render item or grow the array\n\n\n    var renderItem = array[index];\n\n    if (renderItem !== undefined) {\n      renderItem.id = object.id;\n      renderItem.object = object;\n      renderItem.geometry = geometry;\n      renderItem.material = material;\n      renderItem.z = _vector3.z;\n      renderItem.group = group;\n    } else {\n      renderItem = {\n        id: object.id,\n        object: object,\n        geometry: geometry,\n        material: material,\n        z: _vector3.z,\n        group: group\n      }; // assert( index === array.length );\n\n      array.push(renderItem);\n    }\n  }\n\n  function projectObject(object) {\n    if (object.visible === false) return;\n\n    if (object instanceof THREE.Light) {\n      lights.push(object);\n    } else if (object instanceof THREE.Sprite) {\n      sprites.push(object);\n    } else if (object instanceof THREE.LensFlare) {\n      lensFlares.push(object);\n    } else if (object instanceof THREE.ImmediateRenderObject) {\n      pushImmediateRenderItem(object);\n    } else if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {\n      if (object instanceof THREE.SkinnedMesh) {\n        object.skeleton.update();\n      }\n\n      if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {\n        var material = object.material;\n\n        if (material.visible === true) {\n          if (_this.sortObjects === true) {\n            _vector3.setFromMatrixPosition(object.matrixWorld);\n\n            _vector3.applyProjection(_projScreenMatrix);\n          }\n\n          var geometry = objects.update(object);\n\n          if (material instanceof THREE.MeshFaceMaterial) {\n            var groups = geometry.groups;\n            var materials = material.materials;\n\n            for (var i = 0, l = groups.length; i < l; i++) {\n              var group = groups[i];\n              var groupMaterial = materials[group.materialIndex];\n\n              if (groupMaterial.visible === true) {\n                pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);\n              }\n            }\n          } else {\n            pushRenderItem(object, geometry, material, _vector3.z);\n          }\n        }\n      }\n    }\n\n    var children = object.children;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      projectObject(children[i]);\n    }\n  }\n\n  function renderObjects(renderList, camera, lights, fog, overrideMaterial) {\n    for (var i = 0, l = renderList.length; i < l; i++) {\n      var renderItem = renderList[i];\n      var object = renderItem.object;\n      var geometry = renderItem.geometry;\n      var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n      var group = renderItem.group;\n      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n\n      _this.renderBufferDirect(camera, lights, fog, geometry, material, object, group);\n    }\n  }\n\n  function renderObjectsImmediate(renderList, camera, lights, fog, overrideMaterial) {\n    var material = overrideMaterial;\n\n    for (var i = 0, l = renderList.length; i < l; i++) {\n      var object = renderList[i];\n      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n      if (overrideMaterial === undefined) material = object.material;\n      setMaterial(material);\n      var program = setProgram(camera, lights, fog, material, object);\n      _currentGeometryProgram = '';\n      object.render(function (object) {\n        _this.renderBufferImmediate(object, program, material);\n      });\n    }\n  }\n\n  function initMaterial(material, lights, fog, object) {\n    var materialProperties = properties.get(material);\n    var parameters = programCache.getParameters(material, lights, fog, object);\n    var code = programCache.getProgramCode(material, parameters);\n    var program = materialProperties.program;\n    var programChange = true;\n\n    if (program === undefined) {\n      // new material\n      material.addEventListener('dispose', onMaterialDispose);\n    } else if (program.code !== code) {\n      // changed glsl or parameters\n      releaseMaterialProgramReference(material);\n    } else if (parameters.shaderID !== undefined) {\n      // same glsl and uniform list\n      return;\n    } else {\n      // only rebuild uniform list\n      programChange = false;\n    }\n\n    if (programChange) {\n      if (parameters.shaderID) {\n        var shader = THREE.ShaderLib[parameters.shaderID];\n        materialProperties.__webglShader = {\n          name: material.type,\n          uniforms: THREE.UniformsUtils.clone(shader.uniforms),\n          vertexShader: shader.vertexShader,\n          fragmentShader: shader.fragmentShader\n        };\n      } else {\n        materialProperties.__webglShader = {\n          name: material.type,\n          uniforms: material.uniforms,\n          vertexShader: material.vertexShader,\n          fragmentShader: material.fragmentShader\n        };\n      }\n\n      material.__webglShader = materialProperties.__webglShader;\n      program = programCache.acquireProgram(material, parameters, code);\n      materialProperties.program = program;\n      material.program = program;\n    }\n\n    var attributes = program.getAttributes();\n\n    if (material.morphTargets) {\n      material.numSupportedMorphTargets = 0;\n\n      for (var i = 0; i < _this.maxMorphTargets; i++) {\n        if (attributes['morphTarget' + i] >= 0) {\n          material.numSupportedMorphTargets++;\n        }\n      }\n    }\n\n    if (material.morphNormals) {\n      material.numSupportedMorphNormals = 0;\n\n      for (i = 0; i < _this.maxMorphNormals; i++) {\n        if (attributes['morphNormal' + i] >= 0) {\n          material.numSupportedMorphNormals++;\n        }\n      }\n    }\n\n    materialProperties.uniformsList = [];\n    var uniformLocations = materialProperties.program.getUniforms();\n\n    for (var u in materialProperties.__webglShader.uniforms) {\n      var location = uniformLocations[u];\n\n      if (location) {\n        materialProperties.uniformsList.push([materialProperties.__webglShader.uniforms[u], location]);\n      }\n    }\n  }\n\n  function setMaterial(material) {\n    setMaterialFaces(material);\n\n    if (material.transparent === true) {\n      state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha);\n    } else {\n      state.setBlending(THREE.NoBlending);\n    }\n\n    state.setDepthFunc(material.depthFunc);\n    state.setDepthTest(material.depthTest);\n    state.setDepthWrite(material.depthWrite);\n    state.setColorWrite(material.colorWrite);\n    state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n  }\n\n  function setMaterialFaces(material) {\n    material.side !== THREE.DoubleSide ? state.enable(_gl.CULL_FACE) : state.disable(_gl.CULL_FACE);\n    state.setFlipSided(material.side === THREE.BackSide);\n  }\n\n  function setProgram(camera, lights, fog, material, object) {\n    _usedTextureUnits = 0;\n    var materialProperties = properties.get(material);\n\n    if (material.needsUpdate || !materialProperties.program) {\n      initMaterial(material, lights, fog, object);\n      material.needsUpdate = false;\n    }\n\n    var refreshProgram = false;\n    var refreshMaterial = false;\n    var refreshLights = false;\n    var program = materialProperties.program,\n        p_uniforms = program.getUniforms(),\n        m_uniforms = materialProperties.__webglShader.uniforms;\n\n    if (program.id !== _currentProgram) {\n      _gl.useProgram(program.program);\n\n      _currentProgram = program.id;\n      refreshProgram = true;\n      refreshMaterial = true;\n      refreshLights = true;\n    }\n\n    if (material.id !== _currentMaterialId) {\n      if (_currentMaterialId === -1) refreshLights = true;\n      _currentMaterialId = material.id;\n      refreshMaterial = true;\n    }\n\n    if (refreshProgram || camera !== _currentCamera) {\n      _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);\n\n      if (capabilities.logarithmicDepthBuffer) {\n        _gl.uniform1f(p_uniforms.logDepthBufFC, 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));\n      }\n\n      if (camera !== _currentCamera) _currentCamera = camera; // load material specific uniforms\n      // (shader material also gets them for the sake of genericity)\n\n      if (material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material.envMap) {\n        if (p_uniforms.cameraPosition !== undefined) {\n          _vector3.setFromMatrixPosition(camera.matrixWorld);\n\n          _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);\n        }\n      }\n\n      if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshBasicMaterial || material instanceof THREE.ShaderMaterial || material.skinning) {\n        if (p_uniforms.viewMatrix !== undefined) {\n          _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);\n        }\n      }\n    } // skinning uniforms must be set even if material didn't change\n    // auto-setting of texture unit for bone texture must go before other textures\n    // not sure why, but otherwise weird things happen\n\n\n    if (material.skinning) {\n      if (object.bindMatrix && p_uniforms.bindMatrix !== undefined) {\n        _gl.uniformMatrix4fv(p_uniforms.bindMatrix, false, object.bindMatrix.elements);\n      }\n\n      if (object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined) {\n        _gl.uniformMatrix4fv(p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements);\n      }\n\n      if (capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture) {\n        if (p_uniforms.boneTexture !== undefined) {\n          var textureUnit = getTextureUnit();\n\n          _gl.uniform1i(p_uniforms.boneTexture, textureUnit);\n\n          _this.setTexture(object.skeleton.boneTexture, textureUnit);\n        }\n\n        if (p_uniforms.boneTextureWidth !== undefined) {\n          _gl.uniform1i(p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth);\n        }\n\n        if (p_uniforms.boneTextureHeight !== undefined) {\n          _gl.uniform1i(p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight);\n        }\n      } else if (object.skeleton && object.skeleton.boneMatrices) {\n        if (p_uniforms.boneGlobalMatrices !== undefined) {\n          _gl.uniformMatrix4fv(p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices);\n        }\n      }\n    }\n\n    if (refreshMaterial) {\n      // refresh uniforms common to several materials\n      if (fog && material.fog) {\n        refreshUniformsFog(m_uniforms, fog);\n      }\n\n      if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material.lights) {\n        if (_lightsNeedUpdate) {\n          refreshLights = true;\n          setupLights(lights, camera);\n          _lightsNeedUpdate = false;\n        }\n\n        if (refreshLights) {\n          refreshUniformsLights(m_uniforms, _lights);\n          markUniformsLightsNeedsUpdate(m_uniforms, true);\n        } else {\n          markUniformsLightsNeedsUpdate(m_uniforms, false);\n        }\n      }\n\n      if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {\n        refreshUniformsCommon(m_uniforms, material);\n      } // refresh single material specific uniforms\n\n\n      if (material instanceof THREE.LineBasicMaterial) {\n        refreshUniformsLine(m_uniforms, material);\n      } else if (material instanceof THREE.LineDashedMaterial) {\n        refreshUniformsLine(m_uniforms, material);\n        refreshUniformsDash(m_uniforms, material);\n      } else if (material instanceof THREE.PointsMaterial) {\n        refreshUniformsParticle(m_uniforms, material);\n      } else if (material instanceof THREE.MeshPhongMaterial) {\n        refreshUniformsPhong(m_uniforms, material);\n      } else if (material instanceof THREE.MeshDepthMaterial) {\n        m_uniforms.mNear.value = camera.near;\n        m_uniforms.mFar.value = camera.far;\n        m_uniforms.opacity.value = material.opacity;\n      } else if (material instanceof THREE.MeshNormalMaterial) {\n        m_uniforms.opacity.value = material.opacity;\n      }\n\n      if (object.receiveShadow && !material._shadowPass) {\n        refreshUniformsShadow(m_uniforms, lights);\n      } // load common uniforms\n\n\n      loadUniformsGeneric(materialProperties.uniformsList);\n    }\n\n    loadUniformsMatrices(p_uniforms, object);\n\n    if (p_uniforms.modelMatrix !== undefined) {\n      _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);\n    }\n\n    return program;\n  } // Uniforms (refresh uniforms objects)\n\n\n  function refreshUniformsCommon(uniforms, material) {\n    uniforms.opacity.value = material.opacity;\n    uniforms.diffuse.value = material.color;\n\n    if (material.emissive) {\n      uniforms.emissive.value = material.emissive;\n    }\n\n    uniforms.map.value = material.map;\n    uniforms.specularMap.value = material.specularMap;\n    uniforms.alphaMap.value = material.alphaMap;\n\n    if (material.aoMap) {\n      uniforms.aoMap.value = material.aoMap;\n      uniforms.aoMapIntensity.value = material.aoMapIntensity;\n    } // uv repeat and offset setting priorities\n    // 1. color map\n    // 2. specular map\n    // 3. normal map\n    // 4. bump map\n    // 5. alpha map\n    // 6. emissive map\n\n\n    var uvScaleMap;\n\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.specularMap) {\n      uvScaleMap = material.specularMap;\n    } else if (material.displacementMap) {\n      uvScaleMap = material.displacementMap;\n    } else if (material.normalMap) {\n      uvScaleMap = material.normalMap;\n    } else if (material.bumpMap) {\n      uvScaleMap = material.bumpMap;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    } else if (material.emissiveMap) {\n      uvScaleMap = material.emissiveMap;\n    }\n\n    if (uvScaleMap !== undefined) {\n      var offset = uvScaleMap.offset;\n      var repeat = uvScaleMap.repeat;\n      uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);\n    }\n\n    uniforms.envMap.value = material.envMap;\n    uniforms.flipEnvMap.value = material.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;\n    uniforms.reflectivity.value = material.reflectivity;\n    uniforms.refractionRatio.value = material.refractionRatio;\n  }\n\n  function refreshUniformsLine(uniforms, material) {\n    uniforms.diffuse.value = material.color;\n    uniforms.opacity.value = material.opacity;\n  }\n\n  function refreshUniformsDash(uniforms, material) {\n    uniforms.dashSize.value = material.dashSize;\n    uniforms.totalSize.value = material.dashSize + material.gapSize;\n    uniforms.scale.value = material.scale;\n  }\n\n  function refreshUniformsParticle(uniforms, material) {\n    uniforms.psColor.value = material.color;\n    uniforms.opacity.value = material.opacity;\n    uniforms.size.value = material.size;\n    uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\n\n    uniforms.map.value = material.map;\n\n    if (material.map !== null) {\n      var offset = material.map.offset;\n      var repeat = material.map.repeat;\n      uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);\n    }\n  }\n\n  function refreshUniformsFog(uniforms, fog) {\n    uniforms.fogColor.value = fog.color;\n\n    if (fog instanceof THREE.Fog) {\n      uniforms.fogNear.value = fog.near;\n      uniforms.fogFar.value = fog.far;\n    } else if (fog instanceof THREE.FogExp2) {\n      uniforms.fogDensity.value = fog.density;\n    }\n  }\n\n  function refreshUniformsPhong(uniforms, material) {\n    uniforms.specular.value = material.specular;\n    uniforms.shininess.value = material.shininess;\n\n    if (material.lightMap) {\n      uniforms.lightMap.value = material.lightMap;\n      uniforms.lightMapIntensity.value = material.lightMapIntensity;\n    }\n\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n\n  function refreshUniformsLights(uniforms, lights) {\n    uniforms.ambientLightColor.value = lights.ambient;\n    uniforms.directionalLightColor.value = lights.directional.colors;\n    uniforms.directionalLightDirection.value = lights.directional.positions;\n    uniforms.pointLightColor.value = lights.point.colors;\n    uniforms.pointLightPosition.value = lights.point.positions;\n    uniforms.pointLightDistance.value = lights.point.distances;\n    uniforms.pointLightDecay.value = lights.point.decays;\n    uniforms.spotLightColor.value = lights.spot.colors;\n    uniforms.spotLightPosition.value = lights.spot.positions;\n    uniforms.spotLightDistance.value = lights.spot.distances;\n    uniforms.spotLightDirection.value = lights.spot.directions;\n    uniforms.spotLightAngleCos.value = lights.spot.anglesCos;\n    uniforms.spotLightExponent.value = lights.spot.exponents;\n    uniforms.spotLightDecay.value = lights.spot.decays;\n    uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\n    uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\n    uniforms.hemisphereLightDirection.value = lights.hemi.positions;\n  } // If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\n  function markUniformsLightsNeedsUpdate(uniforms, value) {\n    uniforms.ambientLightColor.needsUpdate = value;\n    uniforms.directionalLightColor.needsUpdate = value;\n    uniforms.directionalLightDirection.needsUpdate = value;\n    uniforms.pointLightColor.needsUpdate = value;\n    uniforms.pointLightPosition.needsUpdate = value;\n    uniforms.pointLightDistance.needsUpdate = value;\n    uniforms.pointLightDecay.needsUpdate = value;\n    uniforms.spotLightColor.needsUpdate = value;\n    uniforms.spotLightPosition.needsUpdate = value;\n    uniforms.spotLightDistance.needsUpdate = value;\n    uniforms.spotLightDirection.needsUpdate = value;\n    uniforms.spotLightAngleCos.needsUpdate = value;\n    uniforms.spotLightExponent.needsUpdate = value;\n    uniforms.spotLightDecay.needsUpdate = value;\n    uniforms.hemisphereLightSkyColor.needsUpdate = value;\n    uniforms.hemisphereLightGroundColor.needsUpdate = value;\n    uniforms.hemisphereLightDirection.needsUpdate = value;\n  }\n\n  function refreshUniformsShadow(uniforms, lights) {\n    if (uniforms.shadowMatrix) {\n      var j = 0;\n\n      for (var i = 0, il = lights.length; i < il; i++) {\n        var light = lights[i];\n        if (!light.castShadow) continue;\n\n        if (light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight) {\n          uniforms.shadowMap.value[j] = light.shadowMap;\n          uniforms.shadowMapSize.value[j] = light.shadowMapSize;\n          uniforms.shadowMatrix.value[j] = light.shadowMatrix;\n          uniforms.shadowDarkness.value[j] = light.shadowDarkness;\n          uniforms.shadowBias.value[j] = light.shadowBias;\n          j++;\n        }\n      }\n    }\n  } // Uniforms (load to GPU)\n\n\n  function loadUniformsMatrices(uniforms, object) {\n    _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object.modelViewMatrix.elements);\n\n    if (uniforms.normalMatrix) {\n      _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object.normalMatrix.elements);\n    }\n  }\n\n  function getTextureUnit() {\n    var textureUnit = _usedTextureUnits;\n\n    if (textureUnit >= capabilities.maxTextures) {\n      console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);\n    }\n\n    _usedTextureUnits += 1;\n    return textureUnit;\n  }\n\n  function loadUniformsGeneric(uniforms) {\n    var texture, textureUnit;\n\n    for (var j = 0, jl = uniforms.length; j < jl; j++) {\n      var uniform = uniforms[j][0]; // needsUpdate property is not added to all uniforms.\n\n      if (uniform.needsUpdate === false) continue;\n      var type = uniform.type;\n      var value = uniform.value;\n      var location = uniforms[j][1];\n\n      switch (type) {\n        case '1i':\n          _gl.uniform1i(location, value);\n\n          break;\n\n        case '1f':\n          _gl.uniform1f(location, value);\n\n          break;\n\n        case '2f':\n          _gl.uniform2f(location, value[0], value[1]);\n\n          break;\n\n        case '3f':\n          _gl.uniform3f(location, value[0], value[1], value[2]);\n\n          break;\n\n        case '4f':\n          _gl.uniform4f(location, value[0], value[1], value[2], value[3]);\n\n          break;\n\n        case '1iv':\n          _gl.uniform1iv(location, value);\n\n          break;\n\n        case '3iv':\n          _gl.uniform3iv(location, value);\n\n          break;\n\n        case '1fv':\n          _gl.uniform1fv(location, value);\n\n          break;\n\n        case '2fv':\n          _gl.uniform2fv(location, value);\n\n          break;\n\n        case '3fv':\n          _gl.uniform3fv(location, value);\n\n          break;\n\n        case '4fv':\n          _gl.uniform4fv(location, value);\n\n          break;\n\n        case 'Matrix3fv':\n          _gl.uniformMatrix3fv(location, false, value);\n\n          break;\n\n        case 'Matrix4fv':\n          _gl.uniformMatrix4fv(location, false, value);\n\n          break;\n        //\n\n        case 'i':\n          // single integer\n          _gl.uniform1i(location, value);\n\n          break;\n\n        case 'f':\n          // single float\n          _gl.uniform1f(location, value);\n\n          break;\n\n        case 'v2':\n          // single THREE.Vector2\n          _gl.uniform2f(location, value.x, value.y);\n\n          break;\n\n        case 'v3':\n          // single THREE.Vector3\n          _gl.uniform3f(location, value.x, value.y, value.z);\n\n          break;\n\n        case 'v4':\n          // single THREE.Vector4\n          _gl.uniform4f(location, value.x, value.y, value.z, value.w);\n\n          break;\n\n        case 'c':\n          // single THREE.Color\n          _gl.uniform3f(location, value.r, value.g, value.b);\n\n          break;\n\n        case 'iv1':\n          // flat array of integers (JS or typed array)\n          _gl.uniform1iv(location, value);\n\n          break;\n\n        case 'iv':\n          // flat array of integers with 3 x N size (JS or typed array)\n          _gl.uniform3iv(location, value);\n\n          break;\n\n        case 'fv1':\n          // flat array of floats (JS or typed array)\n          _gl.uniform1fv(location, value);\n\n          break;\n\n        case 'fv':\n          // flat array of floats with 3 x N size (JS or typed array)\n          _gl.uniform3fv(location, value);\n\n          break;\n\n        case 'v2v':\n          // array of THREE.Vector2\n          if (uniform._array === undefined) {\n            uniform._array = new Float32Array(2 * value.length);\n          }\n\n          for (var i = 0, i2 = 0, il = value.length; i < il; i++, i2 += 2) {\n            uniform._array[i2 + 0] = value[i].x;\n            uniform._array[i2 + 1] = value[i].y;\n          }\n\n          _gl.uniform2fv(location, uniform._array);\n\n          break;\n\n        case 'v3v':\n          // array of THREE.Vector3\n          if (uniform._array === undefined) {\n            uniform._array = new Float32Array(3 * value.length);\n          }\n\n          for (var i = 0, i3 = 0, il = value.length; i < il; i++, i3 += 3) {\n            uniform._array[i3 + 0] = value[i].x;\n            uniform._array[i3 + 1] = value[i].y;\n            uniform._array[i3 + 2] = value[i].z;\n          }\n\n          _gl.uniform3fv(location, uniform._array);\n\n          break;\n\n        case 'v4v':\n          // array of THREE.Vector4\n          if (uniform._array === undefined) {\n            uniform._array = new Float32Array(4 * value.length);\n          }\n\n          for (var i = 0, i4 = 0, il = value.length; i < il; i++, i4 += 4) {\n            uniform._array[i4 + 0] = value[i].x;\n            uniform._array[i4 + 1] = value[i].y;\n            uniform._array[i4 + 2] = value[i].z;\n            uniform._array[i4 + 3] = value[i].w;\n          }\n\n          _gl.uniform4fv(location, uniform._array);\n\n          break;\n\n        case 'm3':\n          // single THREE.Matrix3\n          _gl.uniformMatrix3fv(location, false, value.elements);\n\n          break;\n\n        case 'm3v':\n          // array of THREE.Matrix3\n          if (uniform._array === undefined) {\n            uniform._array = new Float32Array(9 * value.length);\n          }\n\n          for (var i = 0, il = value.length; i < il; i++) {\n            value[i].flattenToArrayOffset(uniform._array, i * 9);\n          }\n\n          _gl.uniformMatrix3fv(location, false, uniform._array);\n\n          break;\n\n        case 'm4':\n          // single THREE.Matrix4\n          _gl.uniformMatrix4fv(location, false, value.elements);\n\n          break;\n\n        case 'm4v':\n          // array of THREE.Matrix4\n          if (uniform._array === undefined) {\n            uniform._array = new Float32Array(16 * value.length);\n          }\n\n          for (var i = 0, il = value.length; i < il; i++) {\n            value[i].flattenToArrayOffset(uniform._array, i * 16);\n          }\n\n          _gl.uniformMatrix4fv(location, false, uniform._array);\n\n          break;\n\n        case 't':\n          // single THREE.Texture (2d or cube)\n          texture = value;\n          textureUnit = getTextureUnit();\n\n          _gl.uniform1i(location, textureUnit);\n\n          if (!texture) continue;\n\n          if (texture instanceof THREE.CubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {\n            // CompressedTexture can have Array in image :/\n            setCubeTexture(texture, textureUnit);\n          } else if (texture instanceof THREE.WebGLRenderTargetCube) {\n            setCubeTextureDynamic(texture, textureUnit);\n          } else {\n            _this.setTexture(texture, textureUnit);\n          }\n\n          break;\n\n        case 'tv':\n          // array of THREE.Texture (2d)\n          if (uniform._array === undefined) {\n            uniform._array = [];\n          }\n\n          for (var i = 0, il = uniform.value.length; i < il; i++) {\n            uniform._array[i] = getTextureUnit();\n          }\n\n          _gl.uniform1iv(location, uniform._array);\n\n          for (var i = 0, il = uniform.value.length; i < il; i++) {\n            texture = uniform.value[i];\n            textureUnit = uniform._array[i];\n            if (!texture) continue;\n\n            _this.setTexture(texture, textureUnit);\n          }\n\n          break;\n\n        default:\n          console.warn('THREE.WebGLRenderer: Unknown uniform type: ' + type);\n      }\n    }\n  }\n\n  function setColorLinear(array, offset, color, intensity) {\n    array[offset + 0] = color.r * intensity;\n    array[offset + 1] = color.g * intensity;\n    array[offset + 2] = color.b * intensity;\n  }\n\n  function setupLights(lights, camera) {\n    var l,\n        ll,\n        light,\n        r = 0,\n        g = 0,\n        b = 0,\n        color,\n        skyColor,\n        groundColor,\n        intensity,\n        distance,\n        zlights = _lights,\n        viewMatrix = camera.matrixWorldInverse,\n        dirColors = zlights.directional.colors,\n        dirPositions = zlights.directional.positions,\n        pointColors = zlights.point.colors,\n        pointPositions = zlights.point.positions,\n        pointDistances = zlights.point.distances,\n        pointDecays = zlights.point.decays,\n        spotColors = zlights.spot.colors,\n        spotPositions = zlights.spot.positions,\n        spotDistances = zlights.spot.distances,\n        spotDirections = zlights.spot.directions,\n        spotAnglesCos = zlights.spot.anglesCos,\n        spotExponents = zlights.spot.exponents,\n        spotDecays = zlights.spot.decays,\n        hemiSkyColors = zlights.hemi.skyColors,\n        hemiGroundColors = zlights.hemi.groundColors,\n        hemiPositions = zlights.hemi.positions,\n        dirLength = 0,\n        pointLength = 0,\n        spotLength = 0,\n        hemiLength = 0,\n        dirCount = 0,\n        pointCount = 0,\n        spotCount = 0,\n        hemiCount = 0,\n        dirOffset = 0,\n        pointOffset = 0,\n        spotOffset = 0,\n        hemiOffset = 0;\n\n    for (l = 0, ll = lights.length; l < ll; l++) {\n      light = lights[l];\n      if (light.onlyShadow) continue;\n      color = light.color;\n      intensity = light.intensity;\n      distance = light.distance;\n\n      if (light instanceof THREE.AmbientLight) {\n        if (!light.visible) continue;\n        r += color.r;\n        g += color.g;\n        b += color.b;\n      } else if (light instanceof THREE.DirectionalLight) {\n        dirCount += 1;\n        if (!light.visible) continue;\n\n        _direction.setFromMatrixPosition(light.matrixWorld);\n\n        _vector3.setFromMatrixPosition(light.target.matrixWorld);\n\n        _direction.sub(_vector3);\n\n        _direction.transformDirection(viewMatrix);\n\n        dirOffset = dirLength * 3;\n        dirPositions[dirOffset + 0] = _direction.x;\n        dirPositions[dirOffset + 1] = _direction.y;\n        dirPositions[dirOffset + 2] = _direction.z;\n        setColorLinear(dirColors, dirOffset, color, intensity);\n        dirLength += 1;\n      } else if (light instanceof THREE.PointLight) {\n        pointCount += 1;\n        if (!light.visible) continue;\n        pointOffset = pointLength * 3;\n        setColorLinear(pointColors, pointOffset, color, intensity);\n\n        _vector3.setFromMatrixPosition(light.matrixWorld);\n\n        _vector3.applyMatrix4(viewMatrix);\n\n        pointPositions[pointOffset + 0] = _vector3.x;\n        pointPositions[pointOffset + 1] = _vector3.y;\n        pointPositions[pointOffset + 2] = _vector3.z; // distance is 0 if decay is 0, because there is no attenuation at all.\n\n        pointDistances[pointLength] = distance;\n        pointDecays[pointLength] = light.distance === 0 ? 0.0 : light.decay;\n        pointLength += 1;\n      } else if (light instanceof THREE.SpotLight) {\n        spotCount += 1;\n        if (!light.visible) continue;\n        spotOffset = spotLength * 3;\n        setColorLinear(spotColors, spotOffset, color, intensity);\n\n        _direction.setFromMatrixPosition(light.matrixWorld);\n\n        _vector3.copy(_direction).applyMatrix4(viewMatrix);\n\n        spotPositions[spotOffset + 0] = _vector3.x;\n        spotPositions[spotOffset + 1] = _vector3.y;\n        spotPositions[spotOffset + 2] = _vector3.z;\n        spotDistances[spotLength] = distance;\n\n        _vector3.setFromMatrixPosition(light.target.matrixWorld);\n\n        _direction.sub(_vector3);\n\n        _direction.transformDirection(viewMatrix);\n\n        spotDirections[spotOffset + 0] = _direction.x;\n        spotDirections[spotOffset + 1] = _direction.y;\n        spotDirections[spotOffset + 2] = _direction.z;\n        spotAnglesCos[spotLength] = Math.cos(light.angle);\n        spotExponents[spotLength] = light.exponent;\n        spotDecays[spotLength] = light.distance === 0 ? 0.0 : light.decay;\n        spotLength += 1;\n      } else if (light instanceof THREE.HemisphereLight) {\n        hemiCount += 1;\n        if (!light.visible) continue;\n\n        _direction.setFromMatrixPosition(light.matrixWorld);\n\n        _direction.transformDirection(viewMatrix);\n\n        hemiOffset = hemiLength * 3;\n        hemiPositions[hemiOffset + 0] = _direction.x;\n        hemiPositions[hemiOffset + 1] = _direction.y;\n        hemiPositions[hemiOffset + 2] = _direction.z;\n        skyColor = light.color;\n        groundColor = light.groundColor;\n        setColorLinear(hemiSkyColors, hemiOffset, skyColor, intensity);\n        setColorLinear(hemiGroundColors, hemiOffset, groundColor, intensity);\n        hemiLength += 1;\n      }\n    } // null eventual remains from removed lights\n    // (this is to avoid if in shader)\n\n\n    for (l = dirLength * 3, ll = Math.max(dirColors.length, dirCount * 3); l < ll; l++) {\n      dirColors[l] = 0.0;\n    }\n\n    for (l = pointLength * 3, ll = Math.max(pointColors.length, pointCount * 3); l < ll; l++) {\n      pointColors[l] = 0.0;\n    }\n\n    for (l = spotLength * 3, ll = Math.max(spotColors.length, spotCount * 3); l < ll; l++) {\n      spotColors[l] = 0.0;\n    }\n\n    for (l = hemiLength * 3, ll = Math.max(hemiSkyColors.length, hemiCount * 3); l < ll; l++) {\n      hemiSkyColors[l] = 0.0;\n    }\n\n    for (l = hemiLength * 3, ll = Math.max(hemiGroundColors.length, hemiCount * 3); l < ll; l++) {\n      hemiGroundColors[l] = 0.0;\n    }\n\n    zlights.directional.length = dirLength;\n    zlights.point.length = pointLength;\n    zlights.spot.length = spotLength;\n    zlights.hemi.length = hemiLength;\n    zlights.ambient[0] = r;\n    zlights.ambient[1] = g;\n    zlights.ambient[2] = b;\n  } // GL state setting\n\n\n  this.setFaceCulling = function (cullFace, frontFaceDirection) {\n    if (cullFace === THREE.CullFaceNone) {\n      state.disable(_gl.CULL_FACE);\n    } else {\n      if (frontFaceDirection === THREE.FrontFaceDirectionCW) {\n        _gl.frontFace(_gl.CW);\n      } else {\n        _gl.frontFace(_gl.CCW);\n      }\n\n      if (cullFace === THREE.CullFaceBack) {\n        _gl.cullFace(_gl.BACK);\n      } else if (cullFace === THREE.CullFaceFront) {\n        _gl.cullFace(_gl.FRONT);\n      } else {\n        _gl.cullFace(_gl.FRONT_AND_BACK);\n      }\n\n      state.enable(_gl.CULL_FACE);\n    }\n  }; // Textures\n\n\n  function setTextureParameters(textureType, texture, isImagePowerOfTwo) {\n    var extension;\n\n    if (isImagePowerOfTwo) {\n      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));\n    } else {\n      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);\n\n      if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) {\n        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )');\n      }\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));\n\n      if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {\n        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )');\n      }\n    }\n\n    extension = extensions.get('EXT_texture_filter_anisotropic');\n\n    if (extension) {\n      if (texture.type === THREE.FloatType && extensions.get('OES_texture_float_linear') === null) return;\n      if (texture.type === THREE.HalfFloatType && extensions.get('OES_texture_half_float_linear') === null) return;\n\n      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {\n        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _this.getMaxAnisotropy()));\n\n        properties.get(texture).__currentAnisotropy = texture.anisotropy;\n      }\n    }\n  }\n\n  function uploadTexture(textureProperties, texture, slot) {\n    if (textureProperties.__webglInit === undefined) {\n      textureProperties.__webglInit = true;\n      texture.__webglInit = true;\n      texture.addEventListener('dispose', onTextureDispose);\n      textureProperties.__webglTexture = _gl.createTexture();\n      _infoMemory.textures++;\n    }\n\n    state.activeTexture(_gl.TEXTURE0 + slot);\n    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);\n\n    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n\n    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n\n    texture.image = clampToMaxSize(texture.image, capabilities.maxTextureSize);\n    var image = texture.image,\n        isImagePowerOfTwo = THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height),\n        glFormat = paramThreeToGL(texture.format),\n        glType = paramThreeToGL(texture.type);\n    setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);\n    var mipmap,\n        mipmaps = texture.mipmaps;\n\n    if (texture instanceof THREE.DataTexture) {\n      // use manually created mipmaps if available\n      // if there are no manual mipmaps\n      // set 0 level mipmap and then use GL to generate other mipmap levels\n      if (mipmaps.length > 0 && isImagePowerOfTwo) {\n        for (var i = 0, il = mipmaps.length; i < il; i++) {\n          mipmap = mipmaps[i];\n          state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n        }\n\n        texture.generateMipmaps = false;\n      } else {\n        state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);\n      }\n    } else if (texture instanceof THREE.CompressedTexture) {\n      for (var i = 0, il = mipmaps.length; i < il; i++) {\n        mipmap = mipmaps[i];\n\n        if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {\n          if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {\n            state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n          } else {\n            console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\");\n          }\n        } else {\n          state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n        }\n      }\n    } else {\n      // regular Texture (image, video, canvas)\n      // use manually created mipmaps if available\n      // if there are no manual mipmaps\n      // set 0 level mipmap and then use GL to generate other mipmap levels\n      if (mipmaps.length > 0 && isImagePowerOfTwo) {\n        for (var i = 0, il = mipmaps.length; i < il; i++) {\n          mipmap = mipmaps[i];\n          state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);\n        }\n\n        texture.generateMipmaps = false;\n      } else {\n        state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);\n      }\n    }\n\n    if (texture.generateMipmaps && isImagePowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_2D);\n    textureProperties.__version = texture.version;\n    if (texture.onUpdate) texture.onUpdate(texture);\n  }\n\n  this.setTexture = function (texture, slot) {\n    var textureProperties = properties.get(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      var image = texture.image;\n\n      if (image === undefined) {\n        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);\n        return;\n      }\n\n      if (image.complete === false) {\n        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);\n        return;\n      }\n\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(_gl.TEXTURE0 + slot);\n    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);\n  };\n\n  function clampToMaxSize(image, maxSize) {\n    if (image.width > maxSize || image.height > maxSize) {\n      // Warning: Scaling through the canvas will only work with images that use\n      // premultiplied alpha.\n      var scale = maxSize / Math.max(image.width, image.height);\n      var canvas = document.createElement('canvas');\n      canvas.width = Math.floor(image.width * scale);\n      canvas.height = Math.floor(image.height * scale);\n      var context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n      console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);\n      return canvas;\n    }\n\n    return image;\n  }\n\n  function setCubeTexture(texture, slot) {\n    var textureProperties = properties.get(texture);\n\n    if (texture.image.length === 6) {\n      if (texture.version > 0 && textureProperties.__version !== texture.version) {\n        if (!textureProperties.__image__webglTextureCube) {\n          texture.addEventListener('dispose', onTextureDispose);\n          textureProperties.__image__webglTextureCube = _gl.createTexture();\n          _infoMemory.textures++;\n        }\n\n        state.activeTexture(_gl.TEXTURE0 + slot);\n        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);\n\n        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n        var isCompressed = texture instanceof THREE.CompressedTexture;\n        var isDataTexture = texture.image[0] instanceof THREE.DataTexture;\n        var cubeImage = [];\n\n        for (var i = 0; i < 6; i++) {\n          if (_this.autoScaleCubemaps && !isCompressed && !isDataTexture) {\n            cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);\n          } else {\n            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];\n          }\n        }\n\n        var image = cubeImage[0],\n            isImagePowerOfTwo = THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height),\n            glFormat = paramThreeToGL(texture.format),\n            glType = paramThreeToGL(texture.type);\n        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo);\n\n        for (var i = 0; i < 6; i++) {\n          if (!isCompressed) {\n            if (isDataTexture) {\n              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);\n            } else {\n              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);\n            }\n          } else {\n            var mipmap,\n                mipmaps = cubeImage[i].mipmaps;\n\n            for (var j = 0, jl = mipmaps.length; j < jl; j++) {\n              mipmap = mipmaps[j];\n\n              if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {\n                if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {\n                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n                } else {\n                  console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\");\n                }\n              } else {\n                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n              }\n            }\n          }\n        }\n\n        if (texture.generateMipmaps && isImagePowerOfTwo) {\n          _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);\n        }\n\n        textureProperties.__version = texture.version;\n        if (texture.onUpdate) texture.onUpdate(texture);\n      } else {\n        state.activeTexture(_gl.TEXTURE0 + slot);\n        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);\n      }\n    }\n  }\n\n  function setCubeTextureDynamic(texture, slot) {\n    state.activeTexture(_gl.TEXTURE0 + slot);\n    state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);\n  } // Render targets\n\n\n  function setupFrameBuffer(framebuffer, renderTarget, textureTarget) {\n    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get(renderTarget).__webglTexture, 0);\n  }\n\n  function setupRenderBuffer(renderbuffer, renderTarget) {\n    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n\n    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\n      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);\n\n      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n      /* For some reason this is not working. Defaulting to RGBA4.\r\n      } else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n      \t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\r\n      \t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n      */\n\n    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\n      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);\n\n      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n    } else {\n      _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);\n    }\n  }\n\n  this.setRenderTarget = function (renderTarget) {\n    var isCube = renderTarget instanceof THREE.WebGLRenderTargetCube;\n\n    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {\n      var renderTargetProperties = properties.get(renderTarget);\n      if (renderTarget.depthBuffer === undefined) renderTarget.depthBuffer = true;\n      if (renderTarget.stencilBuffer === undefined) renderTarget.stencilBuffer = true;\n      renderTarget.addEventListener('dispose', onRenderTargetDispose);\n      renderTargetProperties.__webglTexture = _gl.createTexture();\n      _infoMemory.textures++; // Setup texture, create render and frame buffers\n\n      var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo(renderTarget.width) && THREE.Math.isPowerOfTwo(renderTarget.height),\n          glFormat = paramThreeToGL(renderTarget.format),\n          glType = paramThreeToGL(renderTarget.type);\n\n      if (isCube) {\n        renderTargetProperties.__webglFramebuffer = [];\n        renderTargetProperties.__webglRenderbuffer = [];\n        state.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTargetProperties.__webglTexture);\n        setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo);\n\n        for (var i = 0; i < 6; i++) {\n          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();\n          renderTargetProperties.__webglRenderbuffer[i] = _gl.createRenderbuffer();\n          state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\n          setupFrameBuffer(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n          setupRenderBuffer(renderTargetProperties.__webglRenderbuffer[i], renderTarget);\n        }\n\n        if (renderTarget.generateMipmaps && isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);\n      } else {\n        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n        if (renderTarget.shareDepthFrom) {\n          renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\n        } else {\n          renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();\n        }\n\n        state.bindTexture(_gl.TEXTURE_2D, renderTargetProperties.__webglTexture);\n        setTextureParameters(_gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo);\n        state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\n        setupFrameBuffer(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D);\n\n        if (renderTarget.shareDepthFrom) {\n          if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\n            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer);\n          } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\n            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer);\n          }\n        } else {\n          setupRenderBuffer(renderTargetProperties.__webglRenderbuffer, renderTarget);\n        }\n\n        if (renderTarget.generateMipmaps && isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_2D);\n      } // Release everything\n\n\n      if (isCube) {\n        state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);\n      } else {\n        state.bindTexture(_gl.TEXTURE_2D, null);\n      }\n\n      _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n\n      _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);\n    }\n\n    var framebuffer, width, height, vx, vy;\n\n    if (renderTarget) {\n      var renderTargetProperties = properties.get(renderTarget);\n\n      if (isCube) {\n        framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];\n      } else {\n        framebuffer = renderTargetProperties.__webglFramebuffer;\n      }\n\n      width = renderTarget.width;\n      height = renderTarget.height;\n      vx = 0;\n      vy = 0;\n    } else {\n      framebuffer = null;\n      width = _viewportWidth;\n      height = _viewportHeight;\n      vx = _viewportX;\n      vy = _viewportY;\n    }\n\n    if (framebuffer !== _currentFramebuffer) {\n      _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n      _gl.viewport(vx, vy, width, height);\n\n      _currentFramebuffer = framebuffer;\n    }\n\n    _currentWidth = width;\n    _currentHeight = height;\n  };\n\n  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {\n    if (!(renderTarget instanceof THREE.WebGLRenderTarget)) {\n      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');\n      return;\n    }\n\n    if (properties.get(renderTarget).__webglFramebuffer) {\n      if (renderTarget.format !== THREE.RGBAFormat) {\n        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.');\n        return;\n      }\n\n      var restore = false;\n\n      if (properties.get(renderTarget).__webglFramebuffer !== _currentFramebuffer) {\n        _gl.bindFramebuffer(_gl.FRAMEBUFFER, properties.get(renderTarget).__webglFramebuffer);\n\n        restore = true;\n      }\n\n      if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {\n        _gl.readPixels(x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer);\n      } else {\n        console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');\n      }\n\n      if (restore) {\n        _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);\n      }\n    }\n  };\n\n  function updateRenderTargetMipmap(renderTarget) {\n    if (renderTarget instanceof THREE.WebGLRenderTargetCube) {\n      state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(renderTarget).__webglTexture);\n\n      _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);\n\n      state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);\n    } else {\n      state.bindTexture(_gl.TEXTURE_2D, properties.get(renderTarget).__webglTexture);\n\n      _gl.generateMipmap(_gl.TEXTURE_2D);\n\n      state.bindTexture(_gl.TEXTURE_2D, null);\n    }\n  } // Fallback filters for non-power-of-2 textures\n\n\n  function filterFallback(f) {\n    if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {\n      return _gl.NEAREST;\n    }\n\n    return _gl.LINEAR;\n  } // Map three.js constants to WebGL constants\n\n\n  function paramThreeToGL(p) {\n    var extension;\n    if (p === THREE.RepeatWrapping) return _gl.REPEAT;\n    if (p === THREE.ClampToEdgeWrapping) return _gl.CLAMP_TO_EDGE;\n    if (p === THREE.MirroredRepeatWrapping) return _gl.MIRRORED_REPEAT;\n    if (p === THREE.NearestFilter) return _gl.NEAREST;\n    if (p === THREE.NearestMipMapNearestFilter) return _gl.NEAREST_MIPMAP_NEAREST;\n    if (p === THREE.NearestMipMapLinearFilter) return _gl.NEAREST_MIPMAP_LINEAR;\n    if (p === THREE.LinearFilter) return _gl.LINEAR;\n    if (p === THREE.LinearMipMapNearestFilter) return _gl.LINEAR_MIPMAP_NEAREST;\n    if (p === THREE.LinearMipMapLinearFilter) return _gl.LINEAR_MIPMAP_LINEAR;\n    if (p === THREE.UnsignedByteType) return _gl.UNSIGNED_BYTE;\n    if (p === THREE.UnsignedShort4444Type) return _gl.UNSIGNED_SHORT_4_4_4_4;\n    if (p === THREE.UnsignedShort5551Type) return _gl.UNSIGNED_SHORT_5_5_5_1;\n    if (p === THREE.UnsignedShort565Type) return _gl.UNSIGNED_SHORT_5_6_5;\n    if (p === THREE.ByteType) return _gl.BYTE;\n    if (p === THREE.ShortType) return _gl.SHORT;\n    if (p === THREE.UnsignedShortType) return _gl.UNSIGNED_SHORT;\n    if (p === THREE.IntType) return _gl.INT;\n    if (p === THREE.UnsignedIntType) return _gl.UNSIGNED_INT;\n    if (p === THREE.FloatType) return _gl.FLOAT;\n    extension = extensions.get('OES_texture_half_float');\n\n    if (extension !== null) {\n      if (p === THREE.HalfFloatType) return extension.HALF_FLOAT_OES;\n    }\n\n    if (p === THREE.AlphaFormat) return _gl.ALPHA;\n    if (p === THREE.RGBFormat) return _gl.RGB;\n    if (p === THREE.RGBAFormat) return _gl.RGBA;\n    if (p === THREE.LuminanceFormat) return _gl.LUMINANCE;\n    if (p === THREE.LuminanceAlphaFormat) return _gl.LUMINANCE_ALPHA;\n    if (p === THREE.AddEquation) return _gl.FUNC_ADD;\n    if (p === THREE.SubtractEquation) return _gl.FUNC_SUBTRACT;\n    if (p === THREE.ReverseSubtractEquation) return _gl.FUNC_REVERSE_SUBTRACT;\n    if (p === THREE.ZeroFactor) return _gl.ZERO;\n    if (p === THREE.OneFactor) return _gl.ONE;\n    if (p === THREE.SrcColorFactor) return _gl.SRC_COLOR;\n    if (p === THREE.OneMinusSrcColorFactor) return _gl.ONE_MINUS_SRC_COLOR;\n    if (p === THREE.SrcAlphaFactor) return _gl.SRC_ALPHA;\n    if (p === THREE.OneMinusSrcAlphaFactor) return _gl.ONE_MINUS_SRC_ALPHA;\n    if (p === THREE.DstAlphaFactor) return _gl.DST_ALPHA;\n    if (p === THREE.OneMinusDstAlphaFactor) return _gl.ONE_MINUS_DST_ALPHA;\n    if (p === THREE.DstColorFactor) return _gl.DST_COLOR;\n    if (p === THREE.OneMinusDstColorFactor) return _gl.ONE_MINUS_DST_COLOR;\n    if (p === THREE.SrcAlphaSaturateFactor) return _gl.SRC_ALPHA_SATURATE;\n    extension = extensions.get('WEBGL_compressed_texture_s3tc');\n\n    if (extension !== null) {\n      if (p === THREE.RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n      if (p === THREE.RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n      if (p === THREE.RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n      if (p === THREE.RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n    }\n\n    extension = extensions.get('WEBGL_compressed_texture_pvrtc');\n\n    if (extension !== null) {\n      if (p === THREE.RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n      if (p === THREE.RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n      if (p === THREE.RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n      if (p === THREE.RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n    }\n\n    extension = extensions.get('EXT_blend_minmax');\n\n    if (extension !== null) {\n      if (p === THREE.MinEquation) return extension.MIN_EXT;\n      if (p === THREE.MaxEquation) return extension.MAX_EXT;\n    }\n\n    return 0;\n  } // DEPRECATED\n\n\n  this.supportsFloatTextures = function () {\n    console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).');\n    return extensions.get('OES_texture_float');\n  };\n\n  this.supportsHalfFloatTextures = function () {\n    console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).');\n    return extensions.get('OES_texture_half_float');\n  };\n\n  this.supportsStandardDerivatives = function () {\n    console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).');\n    return extensions.get('OES_standard_derivatives');\n  };\n\n  this.supportsCompressedTextureS3TC = function () {\n    console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).');\n    return extensions.get('WEBGL_compressed_texture_s3tc');\n  };\n\n  this.supportsCompressedTexturePVRTC = function () {\n    console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).');\n    return extensions.get('WEBGL_compressed_texture_pvrtc');\n  };\n\n  this.supportsBlendMinMax = function () {\n    console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).');\n    return extensions.get('EXT_blend_minmax');\n  };\n\n  this.supportsVertexTextures = function () {\n    return capabilities.vertexTextures;\n  };\n\n  this.supportsInstancedArrays = function () {\n    console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).');\n    return extensions.get('ANGLE_instanced_arrays');\n  }; //\n\n\n  this.initMaterial = function () {\n    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');\n  };\n\n  this.addPrePlugin = function () {\n    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');\n  };\n\n  this.addPostPlugin = function () {\n    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');\n  };\n\n  this.updateShadowMap = function () {\n    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');\n  };\n\n  Object.defineProperties(this, {\n    shadowMapEnabled: {\n      get: function get() {\n        return shadowMap.enabled;\n      },\n      set: function set(value) {\n        console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');\n        shadowMap.enabled = value;\n      }\n    },\n    shadowMapType: {\n      get: function get() {\n        return shadowMap.type;\n      },\n      set: function set(value) {\n        console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');\n        shadowMap.type = value;\n      }\n    },\n    shadowMapCullFace: {\n      get: function get() {\n        return shadowMap.cullFace;\n      },\n      set: function set(value) {\n        console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');\n        shadowMap.cullFace = value;\n      }\n    },\n    shadowMapDebug: {\n      get: function get() {\n        return shadowMap.debug;\n      },\n      set: function set(value) {\n        console.warn('THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.');\n        shadowMap.debug = value;\n      }\n    }\n  });\n}; // File:src/renderers/WebGLRenderTarget.js\n\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.WebGLRenderTarget = function (width, height, options) {\n  this.uuid = THREE.Math.generateUUID();\n  this.width = width;\n  this.height = height;\n  options = options || {};\n  this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\n  this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\n  this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\n  this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\n  this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\n  this.offset = new THREE.Vector2(0, 0);\n  this.repeat = new THREE.Vector2(1, 1);\n  this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\n  this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\n  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n  this.generateMipmaps = true;\n  this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;\n};\n\nTHREE.WebGLRenderTarget.prototype = {\n  constructor: THREE.WebGLRenderTarget,\n  setSize: function setSize(width, height) {\n    if (this.width !== width || this.height !== height) {\n      this.width = width;\n      this.height = height;\n      this.dispose();\n    }\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(source) {\n    this.width = source.width;\n    this.height = source.height;\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n    this.anisotropy = source.anisotropy;\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.format = source.format;\n    this.type = source.type;\n    this.depthBuffer = source.depthBuffer;\n    this.stencilBuffer = source.stencilBuffer;\n    this.generateMipmaps = source.generateMipmaps;\n    this.shareDepthFrom = source.shareDepthFrom;\n    return this;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n};\nTHREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype); // File:src/renderers/WebGLRenderTargetCube.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\n\nTHREE.WebGLRenderTargetCube = function (width, height, options) {\n  THREE.WebGLRenderTarget.call(this, width, height, options);\n  this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n};\n\nTHREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube; // File:src/renderers/webgl/WebGLBufferRenderer.js\n\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\n\nTHREE.WebGLBufferRenderer = function (_gl, extensions, _infoRender) {\n  var mode;\n\n  function setMode(value) {\n    mode = value;\n  }\n\n  function render(start, count) {\n    _gl.drawArrays(mode, start, count);\n\n    _infoRender.calls++;\n    _infoRender.vertices += count;\n    if (mode === _gl.TRIANGLES) _infoRender.faces += count / 3;\n  }\n\n  function renderInstances(geometry) {\n    var extension = extensions.get('ANGLE_instanced_arrays');\n\n    if (extension === null) {\n      console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\n      return;\n    }\n\n    var position = geometry.attributes.position;\n\n    if (position instanceof THREE.InterleavedBufferAttribute) {\n      extension.drawArraysInstancedANGLE(mode, 0, position.data.count, geometry.maxInstancedCount);\n    } else {\n      extension.drawArraysInstancedANGLE(mode, 0, position.count, geometry.maxInstancedCount);\n    }\n  }\n\n  this.setMode = setMode;\n  this.render = render;\n  this.renderInstances = renderInstances;\n}; // File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\n\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\n\n\nTHREE.WebGLIndexedBufferRenderer = function (_gl, extensions, _infoRender) {\n  var mode;\n\n  function setMode(value) {\n    mode = value;\n  }\n\n  var type, size;\n\n  function setIndex(index) {\n    if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {\n      type = _gl.UNSIGNED_INT;\n      size = 4;\n    } else {\n      type = _gl.UNSIGNED_SHORT;\n      size = 2;\n    }\n  }\n\n  function render(start, count) {\n    _gl.drawElements(mode, count, type, start * size);\n\n    _infoRender.calls++;\n    _infoRender.vertices += count;\n    if (mode === _gl.TRIANGLES) _infoRender.faces += count / 3;\n  }\n\n  function renderInstances(geometry) {\n    var extension = extensions.get('ANGLE_instanced_arrays');\n\n    if (extension === null) {\n      console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\n      return;\n    }\n\n    var index = geometry.index;\n    extension.drawElementsInstancedANGLE(mode, index.array.length, type, 0, geometry.maxInstancedCount);\n  }\n\n  this.setMode = setMode;\n  this.setIndex = setIndex;\n  this.render = render;\n  this.renderInstances = renderInstances;\n}; // File:src/renderers/webgl/WebGLExtensions.js\n\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\n\n\nTHREE.WebGLExtensions = function (gl) {\n  var extensions = {};\n\n  this.get = function (name) {\n    if (extensions[name] !== undefined) {\n      return extensions[name];\n    }\n\n    var extension;\n\n    switch (name) {\n      case 'EXT_texture_filter_anisotropic':\n        extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');\n        break;\n\n      case 'WEBGL_compressed_texture_s3tc':\n        extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\n        break;\n\n      case 'WEBGL_compressed_texture_pvrtc':\n        extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n        break;\n\n      default:\n        extension = gl.getExtension(name);\n    }\n\n    if (extension === null) {\n      console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');\n    }\n\n    extensions[name] = extension;\n    return extension;\n  };\n}; // File:src/renderers/webgl/WebGLCapabilities.js\n\n\nTHREE.WebGLCapabilities = function (gl, extensions, parameters) {\n  function getMaxPrecision(precision) {\n    if (precision === 'highp') {\n      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {\n        return 'highp';\n      }\n\n      precision = 'mediump';\n    }\n\n    if (precision === 'mediump') {\n      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {\n        return 'mediump';\n      }\n    }\n\n    return 'lowp';\n  }\n\n  this.getMaxPrecision = getMaxPrecision;\n  this.precision = parameters.precision !== undefined ? parameters.precision : 'highp', this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\n  this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n  this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n  this.maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n  this.maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n  this.maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);\n  this.maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n  this.vertexTextures = this.maxVertexTextures > 0;\n  this.floatFragmentTextures = !!extensions.get('OES_texture_float');\n  this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\n\n  var _maxPrecision = getMaxPrecision(this.precision);\n\n  if (_maxPrecision !== this.precision) {\n    console.warn('THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.');\n    this.precision = _maxPrecision;\n  }\n\n  if (this.logarithmicDepthBuffer) {\n    this.logarithmicDepthBuffer = !!extensions.get('EXT_frag_depth');\n  }\n}; // File:src/renderers/webgl/WebGLGeometries.js\n\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\n\n\nTHREE.WebGLGeometries = function (gl, properties, info) {\n  var geometries = {};\n\n  function get(object) {\n    var geometry = object.geometry;\n\n    if (geometries[geometry.id] !== undefined) {\n      return geometries[geometry.id];\n    }\n\n    geometry.addEventListener('dispose', onGeometryDispose);\n    var buffergeometry;\n\n    if (geometry instanceof THREE.BufferGeometry) {\n      buffergeometry = geometry;\n    } else if (geometry instanceof THREE.Geometry) {\n      if (geometry._bufferGeometry === undefined) {\n        geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject(object);\n      }\n\n      buffergeometry = geometry._bufferGeometry;\n    }\n\n    geometries[geometry.id] = buffergeometry;\n    info.memory.geometries++;\n    return buffergeometry;\n  }\n\n  function onGeometryDispose(event) {\n    var geometry = event.target;\n    var buffergeometry = geometries[geometry.id];\n    deleteAttributes(buffergeometry.attributes);\n    geometry.removeEventListener('dispose', onGeometryDispose);\n    delete geometries[geometry.id];\n    var property = properties.get(geometry);\n    if (property.wireframe) deleteAttribute(property.wireframe);\n    info.memory.geometries--;\n  }\n\n  function getAttributeBuffer(attribute) {\n    if (attribute instanceof THREE.InterleavedBufferAttribute) {\n      return properties.get(attribute.data).__webglBuffer;\n    }\n\n    return properties.get(attribute).__webglBuffer;\n  }\n\n  function deleteAttribute(attribute) {\n    var buffer = getAttributeBuffer(attribute);\n\n    if (buffer !== undefined) {\n      gl.deleteBuffer(buffer);\n      removeAttributeBuffer(attribute);\n    }\n  }\n\n  function deleteAttributes(attributes) {\n    for (var name in attributes) {\n      deleteAttribute(attributes[name]);\n    }\n  }\n\n  function removeAttributeBuffer(attribute) {\n    if (attribute instanceof THREE.InterleavedBufferAttribute) {\n      properties.delete(attribute.data);\n    } else {\n      properties.delete(attribute);\n    }\n  }\n\n  this.get = get;\n}; // File:src/renderers/webgl/WebGLObjects.js\n\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\n\n\nTHREE.WebGLObjects = function (gl, properties, info) {\n  var geometries = new THREE.WebGLGeometries(gl, properties, info); //\n\n  function update(object) {\n    // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n    var geometry = geometries.get(object);\n\n    if (object.geometry instanceof THREE.Geometry) {\n      geometry.updateFromObject(object);\n    }\n\n    var index = geometry.index;\n    var attributes = geometry.attributes;\n\n    if (index !== null) {\n      updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);\n    }\n\n    for (var name in attributes) {\n      updateAttribute(attributes[name], gl.ARRAY_BUFFER);\n    } // morph targets\n\n\n    var morphAttributes = geometry.morphAttributes;\n\n    for (var name in morphAttributes) {\n      var array = morphAttributes[name];\n\n      for (var i = 0, l = array.length; i < l; i++) {\n        updateAttribute(array[i], gl.ARRAY_BUFFER);\n      }\n    }\n\n    return geometry;\n  }\n\n  function updateAttribute(attribute, bufferType) {\n    var data = attribute instanceof THREE.InterleavedBufferAttribute ? attribute.data : attribute;\n    var attributeProperties = properties.get(data);\n\n    if (attributeProperties.__webglBuffer === undefined) {\n      createBuffer(attributeProperties, data, bufferType);\n    } else if (attributeProperties.version !== data.version) {\n      updateBuffer(attributeProperties, data, bufferType);\n    }\n  }\n\n  function createBuffer(attributeProperties, data, bufferType) {\n    attributeProperties.__webglBuffer = gl.createBuffer();\n    gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);\n    var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n    gl.bufferData(bufferType, data.array, usage);\n    attributeProperties.version = data.version;\n  }\n\n  function updateBuffer(attributeProperties, data, bufferType) {\n    gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);\n\n    if (data.dynamic === false || data.updateRange.count === -1) {\n      // Not using update ranges\n      gl.bufferSubData(bufferType, 0, data.array);\n    } else if (data.updateRange.count === 0) {\n      console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');\n    } else {\n      gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));\n      data.updateRange.count = 0; // reset range\n    }\n\n    attributeProperties.version = data.version;\n  }\n\n  function getAttributeBuffer(attribute) {\n    if (attribute instanceof THREE.InterleavedBufferAttribute) {\n      return properties.get(attribute.data).__webglBuffer;\n    }\n\n    return properties.get(attribute).__webglBuffer;\n  }\n\n  function getWireframeAttribute(geometry) {\n    var property = properties.get(geometry);\n\n    if (property.wireframe !== undefined) {\n      return property.wireframe;\n    }\n\n    var indices = [];\n    var index = geometry.index;\n    var attributes = geometry.attributes;\n    var position = attributes.position; // console.time( 'wireframe' );\n\n    if (index !== null) {\n      var edges = {};\n      var array = index.array;\n\n      for (var i = 0, l = array.length; i < l; i += 3) {\n        var a = array[i + 0];\n        var b = array[i + 1];\n        var c = array[i + 2];\n        if (checkEdge(edges, a, b)) indices.push(a, b);\n        if (checkEdge(edges, b, c)) indices.push(b, c);\n        if (checkEdge(edges, c, a)) indices.push(c, a);\n      }\n    } else {\n      var array = attributes.position.array;\n\n      for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n        var a = i + 0;\n        var b = i + 1;\n        var c = i + 2;\n        indices.push(a, b, b, c, c, a);\n      }\n    } // console.timeEnd( 'wireframe' );\n\n\n    var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n    var attribute = new THREE.BufferAttribute(new TypeArray(indices), 1);\n    updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);\n    property.wireframe = attribute;\n    return attribute;\n  }\n\n  function checkEdge(edges, a, b) {\n    if (a > b) {\n      var tmp = a;\n      a = b;\n      b = tmp;\n    }\n\n    var list = edges[a];\n\n    if (list === undefined) {\n      edges[a] = [b];\n      return true;\n    } else if (list.indexOf(b) === -1) {\n      list.push(b);\n      return true;\n    }\n\n    return false;\n  }\n\n  this.getAttributeBuffer = getAttributeBuffer;\n  this.getWireframeAttribute = getWireframeAttribute;\n  this.update = update;\n}; // File:src/renderers/webgl/WebGLProgram.js\n\n\nTHREE.WebGLProgram = function () {\n  var programIdCount = 0;\n\n  function generateDefines(defines) {\n    var chunks = [];\n\n    for (var name in defines) {\n      var value = defines[name];\n      if (value === false) continue;\n      chunks.push('#define ' + name + ' ' + value);\n    }\n\n    return chunks.join('\\n');\n  }\n\n  function fetchUniformLocations(gl, program, identifiers) {\n    var uniforms = {};\n    var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    for (var i = 0; i < n; i++) {\n      var info = gl.getActiveUniform(program, i);\n      var name = info.name;\n      var location = gl.getUniformLocation(program, name); // console.log(\"THREE.WebGLProgram: ACTIVE UNIFORM:\", name);\n\n      var suffixPos = name.lastIndexOf('[0]');\n\n      if (suffixPos !== -1 && suffixPos === name.length - 3) {\n        uniforms[name.substr(0, suffixPos)] = location;\n      }\n\n      uniforms[name] = location;\n    }\n\n    return uniforms;\n  }\n\n  function fetchAttributeLocations(gl, program, identifiers) {\n    var attributes = {};\n    var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n    for (var i = 0; i < n; i++) {\n      var info = gl.getActiveAttrib(program, i);\n      var name = info.name; // console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n      attributes[name] = gl.getAttribLocation(program, name);\n    }\n\n    return attributes;\n  }\n\n  function filterEmptyLine(string) {\n    return string !== '';\n  }\n\n  return function WebGLProgram(renderer, code, material, parameters) {\n    var gl = renderer.context;\n    var defines = material.defines;\n    var vertexShader = material.__webglShader.vertexShader;\n    var fragmentShader = material.__webglShader.fragmentShader;\n    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n    if (parameters.shadowMapType === THREE.PCFShadowMap) {\n      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n    } else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {\n      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n    }\n\n    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n    var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n    if (parameters.envMap) {\n      switch (material.envMap.mapping) {\n        case THREE.CubeReflectionMapping:\n        case THREE.CubeRefractionMapping:\n          envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n          break;\n\n        case THREE.EquirectangularReflectionMapping:\n        case THREE.EquirectangularRefractionMapping:\n          envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n          break;\n\n        case THREE.SphericalReflectionMapping:\n          envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n          break;\n      }\n\n      switch (material.envMap.mapping) {\n        case THREE.CubeRefractionMapping:\n        case THREE.EquirectangularRefractionMapping:\n          envMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n          break;\n      }\n\n      switch (material.combine) {\n        case THREE.MultiplyOperation:\n          envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n          break;\n\n        case THREE.MixOperation:\n          envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n          break;\n\n        case THREE.AddOperation:\n          envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n          break;\n      }\n    }\n\n    var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0; // console.log( 'building new program ' );\n    //\n\n    var customDefines = generateDefines(defines); //\n\n    var program = gl.createProgram();\n    var prefixVertex, prefixFragment;\n\n    if (material instanceof THREE.RawShaderMaterial) {\n      prefixVertex = '';\n      prefixFragment = '';\n    } else {\n      prefixVertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + material.__webglShader.name, customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', renderer.gammaInput ? '#define GAMMA_INPUT' : '', renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, '#define MAX_BONES ' + parameters.maxBones, parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_COLOR', '\tattribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '\tattribute vec3 morphTarget0;', '\tattribute vec3 morphTarget1;', '\tattribute vec3 morphTarget2;', '\tattribute vec3 morphTarget3;', '\t#ifdef USE_MORPHNORMALS', '\t\tattribute vec3 morphNormal0;', '\t\tattribute vec3 morphNormal1;', '\t\tattribute vec3 morphNormal2;', '\t\tattribute vec3 morphNormal3;', '\t#else', '\t\tattribute vec3 morphTarget4;', '\t\tattribute vec3 morphTarget5;', '\t\tattribute vec3 morphTarget6;', '\t\tattribute vec3 morphTarget7;', '\t#endif', '#endif', '#ifdef USE_SKINNING', '\tattribute vec4 skinIndex;', '\tattribute vec4 skinWeight;', '#endif', '\\n'].filter(filterEmptyLine).join('\\n');\n      prefixFragment = [parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', 'precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + material.__webglShader.name, customDefines, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '', renderer.gammaInput ? '#define GAMMA_INPUT' : '', renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.metal ? '#define METAL' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', '\\n'].filter(filterEmptyLine).join('\\n');\n    }\n\n    var vertexGlsl = prefixVertex + vertexShader;\n    var fragmentGlsl = prefixFragment + fragmentShader;\n    var glVertexShader = THREE.WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);\n    var glFragmentShader = THREE.WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);\n    gl.attachShader(program, glVertexShader);\n    gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.\n\n    if (material.index0AttributeName !== undefined) {\n      gl.bindAttribLocation(program, 0, material.index0AttributeName);\n    } else if (parameters.morphTargets === true) {\n      // programs with morphTargets displace position out of attribute 0\n      gl.bindAttribLocation(program, 0, 'position');\n    }\n\n    gl.linkProgram(program);\n    var programLog = gl.getProgramInfoLog(program);\n    var vertexLog = gl.getShaderInfoLog(glVertexShader);\n    var fragmentLog = gl.getShaderInfoLog(glFragmentShader);\n    var runnable = true;\n    var haveDiagnostics = true;\n\n    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n      runnable = false;\n      console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);\n    } else if (programLog !== '') {\n      console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);\n    } else if (vertexLog === '' || fragmentLog === '') {\n      haveDiagnostics = false;\n    }\n\n    if (haveDiagnostics) {\n      this.diagnostics = {\n        runnable: runnable,\n        material: material,\n        programLog: programLog,\n        vertexShader: {\n          log: vertexLog,\n          prefix: prefixVertex\n        },\n        fragmentShader: {\n          log: fragmentLog,\n          prefix: prefixFragment\n        }\n      };\n    } // clean up\n\n\n    gl.deleteShader(glVertexShader);\n    gl.deleteShader(glFragmentShader); // set up caching for uniform locations\n\n    var cachedUniforms;\n\n    this.getUniforms = function () {\n      if (cachedUniforms === undefined) {\n        cachedUniforms = fetchUniformLocations(gl, program);\n      }\n\n      return cachedUniforms;\n    }; // set up caching for attribute locations\n\n\n    var cachedAttributes;\n\n    this.getAttributes = function () {\n      if (cachedAttributes === undefined) {\n        cachedAttributes = fetchAttributeLocations(gl, program);\n      }\n\n      return cachedAttributes;\n    }; // free resource\n\n\n    this.destroy = function () {\n      gl.deleteProgram(program);\n      this.program = undefined;\n    }; // DEPRECATED\n\n\n    Object.defineProperties(this, {\n      uniforms: {\n        get: function get() {\n          console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');\n          return this.getUniforms();\n        }\n      },\n      attributes: {\n        get: function get() {\n          console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');\n          return this.getAttributes();\n        }\n      }\n    }); //\n\n    this.id = programIdCount++;\n    this.code = code;\n    this.usedTimes = 1;\n    this.program = program;\n    this.vertexShader = glVertexShader;\n    this.fragmentShader = glFragmentShader;\n    return this;\n  };\n}(); // File:src/renderers/webgl/WebGLPrograms.js\n\n\nTHREE.WebGLPrograms = function (renderer, capabilities) {\n  var programs = [];\n  var shaderIDs = {\n    MeshDepthMaterial: 'depth',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points'\n  };\n  var parameterNames = [\"precision\", \"supportsVertexTextures\", \"map\", \"envMap\", \"envMapMode\", \"lightMap\", \"aoMap\", \"emissiveMap\", \"bumpMap\", \"normalMap\", \"specularMap\", \"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\", \"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\", \"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\", \"maxMorphTargets\", \"maxMorphNormals\", \"maxDirLights\", \"maxPointLights\", \"maxSpotLights\", \"maxHemiLights\", \"maxShadows\", \"shadowMapEnabled\", \"shadowMapType\", \"shadowMapDebug\", \"alphaTest\", \"metal\", \"doubleSided\", \"flipSided\"];\n\n  function allocateBones(object) {\n    if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {\n      return 1024;\n    } else {\n      // default for when object is not specified\n      // ( for example when prebuilding shader to be used with multiple objects )\n      //\n      //  - leave some extra space for other uniforms\n      //  - limit here is ANGLE's 254 max uniform vectors\n      //    (up to 54 should be safe)\n      var nVertexUniforms = capabilities.maxVertexUniforms;\n      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);\n      var maxBones = nVertexMatrices;\n\n      if (object !== undefined && object instanceof THREE.SkinnedMesh) {\n        maxBones = Math.min(object.skeleton.bones.length, maxBones);\n\n        if (maxBones < object.skeleton.bones.length) {\n          console.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');\n        }\n      }\n\n      return maxBones;\n    }\n  }\n\n  function allocateLights(lights) {\n    var dirLights = 0;\n    var pointLights = 0;\n    var spotLights = 0;\n    var hemiLights = 0;\n\n    for (var l = 0, ll = lights.length; l < ll; l++) {\n      var light = lights[l];\n      if (light.onlyShadow || light.visible === false) continue;\n      if (light instanceof THREE.DirectionalLight) dirLights++;\n      if (light instanceof THREE.PointLight) pointLights++;\n      if (light instanceof THREE.SpotLight) spotLights++;\n      if (light instanceof THREE.HemisphereLight) hemiLights++;\n    }\n\n    return {\n      'directional': dirLights,\n      'point': pointLights,\n      'spot': spotLights,\n      'hemi': hemiLights\n    };\n  }\n\n  function allocateShadows(lights) {\n    var maxShadows = 0;\n\n    for (var l = 0, ll = lights.length; l < ll; l++) {\n      var light = lights[l];\n      if (!light.castShadow) continue;\n      if (light instanceof THREE.SpotLight) maxShadows++;\n      if (light instanceof THREE.DirectionalLight) maxShadows++;\n    }\n\n    return maxShadows;\n  }\n\n  this.getParameters = function (material, lights, fog, object) {\n    var shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene\n    // (not to blow over maxLights budget)\n\n    var maxLightCount = allocateLights(lights);\n    var maxShadows = allocateShadows(lights);\n    var maxBones = allocateBones(object);\n    var precision = renderer.getPrecision();\n\n    if (material.precision !== null) {\n      precision = capabilities.getMaxPrecision(material.precision);\n\n      if (precision !== material.precision) {\n        console.warn('THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.');\n      }\n    }\n\n    var parameters = {\n      shaderID: shaderID,\n      precision: precision,\n      supportsVertexTextures: capabilities.vertexTextures,\n      map: !!material.map,\n      envMap: !!material.envMap,\n      envMapMode: material.envMap && material.envMap.mapping,\n      lightMap: !!material.lightMap,\n      aoMap: !!material.aoMap,\n      emissiveMap: !!material.emissiveMap,\n      bumpMap: !!material.bumpMap,\n      normalMap: !!material.normalMap,\n      displacementMap: !!material.displacementMap,\n      specularMap: !!material.specularMap,\n      alphaMap: !!material.alphaMap,\n      combine: material.combine,\n      vertexColors: material.vertexColors,\n      fog: fog,\n      useFog: material.fog,\n      fogExp: fog instanceof THREE.FogExp2,\n      flatShading: material.shading === THREE.FlatShading,\n      sizeAttenuation: material.sizeAttenuation,\n      logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n      skinning: material.skinning,\n      maxBones: maxBones,\n      useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n      morphTargets: material.morphTargets,\n      morphNormals: material.morphNormals,\n      maxMorphTargets: renderer.maxMorphTargets,\n      maxMorphNormals: renderer.maxMorphNormals,\n      maxDirLights: maxLightCount.directional,\n      maxPointLights: maxLightCount.point,\n      maxSpotLights: maxLightCount.spot,\n      maxHemiLights: maxLightCount.hemi,\n      maxShadows: maxShadows,\n      shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && maxShadows > 0,\n      shadowMapType: renderer.shadowMap.type,\n      shadowMapDebug: renderer.shadowMap.debug,\n      alphaTest: material.alphaTest,\n      metal: material.metal,\n      doubleSided: material.side === THREE.DoubleSide,\n      flipSided: material.side === THREE.BackSide\n    };\n    return parameters;\n  };\n\n  this.getProgramCode = function (material, parameters) {\n    var chunks = [];\n\n    if (parameters.shaderID) {\n      chunks.push(parameters.shaderID);\n    } else {\n      chunks.push(material.fragmentShader);\n      chunks.push(material.vertexShader);\n    }\n\n    if (material.defines !== undefined) {\n      for (var name in material.defines) {\n        chunks.push(name);\n        chunks.push(material.defines[name]);\n      }\n    }\n\n    for (var i = 0; i < parameterNames.length; i++) {\n      var parameterName = parameterNames[i];\n      chunks.push(parameterName);\n      chunks.push(parameters[parameterName]);\n    }\n\n    return chunks.join();\n  };\n\n  this.acquireProgram = function (material, parameters, code) {\n    var program; // Check if code has been already compiled\n\n    for (var p = 0, pl = programs.length; p < pl; p++) {\n      var programInfo = programs[p];\n\n      if (programInfo.code === code) {\n        program = programInfo;\n        ++program.usedTimes;\n        break;\n      }\n    }\n\n    if (program === undefined) {\n      program = new THREE.WebGLProgram(renderer, code, material, parameters);\n      programs.push(program);\n    }\n\n    return program;\n  };\n\n  this.releaseProgram = function (program) {\n    if (--program.usedTimes === 0) {\n      // Remove from unordered set\n      var i = programs.indexOf(program);\n      programs[i] = programs[programs.length - 1];\n      programs.pop(); // Free WebGL resources\n\n      program.destroy();\n    }\n  }; // Exposed for resource monitoring & error feedback via renderer.info:\n\n\n  this.programs = programs;\n}; // File:src/renderers/webgl/WebGLProperties.js\n\n/**\r\n* @author fordacious / fordacious.github.io\r\n*/\n\n\nTHREE.WebGLProperties = function () {\n  var properties = {};\n\n  this.get = function (object) {\n    var uuid = object.uuid;\n    var map = properties[uuid];\n\n    if (map === undefined) {\n      map = {};\n      properties[uuid] = map;\n    }\n\n    return map;\n  };\n\n  this.delete = function (object) {\n    delete properties[object.uuid];\n  };\n\n  this.clear = function () {\n    properties = {};\n  };\n}; // File:src/renderers/webgl/WebGLShader.js\n\n\nTHREE.WebGLShader = function () {\n  var addLineNumbers = function addLineNumbers(string) {\n    var lines = string.split('\\n');\n\n    for (var i = 0; i < lines.length; i++) {\n      lines[i] = i + 1 + ': ' + lines[i];\n    }\n\n    return lines.join('\\n');\n  };\n\n  return function WebGLShader(gl, type, string) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, string);\n    gl.compileShader(shader);\n\n    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {\n      console.error('THREE.WebGLShader: Shader couldn\\'t compile.');\n    }\n\n    if (gl.getShaderInfoLog(shader) !== '') {\n      console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));\n    } // --enable-privileged-webgl-extension\n    // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\n    return shader;\n  };\n}(); // File:src/renderers/webgl/WebGLShadowMap.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.WebGLShadowMap = function (_renderer, _lights, _objects) {\n  var _gl = _renderer.context,\n      _state = _renderer.state,\n      _frustum = new THREE.Frustum(),\n      _projScreenMatrix = new THREE.Matrix4(),\n      _min = new THREE.Vector3(),\n      _max = new THREE.Vector3(),\n      _matrixPosition = new THREE.Vector3(),\n      _renderList = []; // init\n\n\n  var depthShader = THREE.ShaderLib[\"depthRGBA\"];\n  var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);\n\n  var _depthMaterial = new THREE.ShaderMaterial({\n    uniforms: depthUniforms,\n    vertexShader: depthShader.vertexShader,\n    fragmentShader: depthShader.fragmentShader\n  });\n\n  var _depthMaterialMorph = new THREE.ShaderMaterial({\n    uniforms: depthUniforms,\n    vertexShader: depthShader.vertexShader,\n    fragmentShader: depthShader.fragmentShader,\n    morphTargets: true\n  });\n\n  var _depthMaterialSkin = new THREE.ShaderMaterial({\n    uniforms: depthUniforms,\n    vertexShader: depthShader.vertexShader,\n    fragmentShader: depthShader.fragmentShader,\n    skinning: true\n  });\n\n  var _depthMaterialMorphSkin = new THREE.ShaderMaterial({\n    uniforms: depthUniforms,\n    vertexShader: depthShader.vertexShader,\n    fragmentShader: depthShader.fragmentShader,\n    morphTargets: true,\n    skinning: true\n  });\n\n  _depthMaterial._shadowPass = true;\n  _depthMaterialMorph._shadowPass = true;\n  _depthMaterialSkin._shadowPass = true;\n  _depthMaterialMorphSkin._shadowPass = true; //\n\n  var scope = this;\n  this.enabled = false;\n  this.autoUpdate = true;\n  this.needsUpdate = false;\n  this.type = THREE.PCFShadowMap;\n  this.cullFace = THREE.CullFaceFront;\n\n  this.render = function (scene, camera) {\n    if (scope.enabled === false) return;\n    if (scope.autoUpdate === false && scope.needsUpdate === false) return; // set GL state for depth map\n\n    _gl.clearColor(1, 1, 1, 1);\n\n    _state.disable(_gl.BLEND);\n\n    _state.enable(_gl.CULL_FACE);\n\n    _gl.frontFace(_gl.CCW);\n\n    if (scope.cullFace === THREE.CullFaceFront) {\n      _gl.cullFace(_gl.FRONT);\n    } else {\n      _gl.cullFace(_gl.BACK);\n    }\n\n    _state.setDepthTest(true); // render depth map\n\n\n    for (var i = 0, il = _lights.length; i < il; i++) {\n      var light = _lights[i];\n      if (!light.castShadow) continue;\n\n      if (!light.shadowMap) {\n        var shadowFilter = THREE.LinearFilter;\n\n        if (scope.type === THREE.PCFSoftShadowMap) {\n          shadowFilter = THREE.NearestFilter;\n        }\n\n        var pars = {\n          minFilter: shadowFilter,\n          magFilter: shadowFilter,\n          format: THREE.RGBAFormat\n        };\n        light.shadowMap = new THREE.WebGLRenderTarget(light.shadowMapWidth, light.shadowMapHeight, pars);\n        light.shadowMapSize = new THREE.Vector2(light.shadowMapWidth, light.shadowMapHeight);\n        light.shadowMatrix = new THREE.Matrix4();\n      }\n\n      if (!light.shadowCamera) {\n        if (light instanceof THREE.SpotLight) {\n          light.shadowCamera = new THREE.PerspectiveCamera(light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar);\n        } else if (light instanceof THREE.DirectionalLight) {\n          light.shadowCamera = new THREE.OrthographicCamera(light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar);\n        } else {\n          console.error(\"THREE.ShadowMapPlugin: Unsupported light type for shadow\", light);\n          continue;\n        }\n\n        scene.add(light.shadowCamera);\n        if (scene.autoUpdate === true) scene.updateMatrixWorld();\n      }\n\n      if (light.shadowCameraVisible && !light.cameraHelper) {\n        light.cameraHelper = new THREE.CameraHelper(light.shadowCamera);\n        scene.add(light.cameraHelper);\n      }\n\n      var shadowMap = light.shadowMap;\n      var shadowMatrix = light.shadowMatrix;\n      var shadowCamera = light.shadowCamera; //\n\n      shadowCamera.position.setFromMatrixPosition(light.matrixWorld);\n\n      _matrixPosition.setFromMatrixPosition(light.target.matrixWorld);\n\n      shadowCamera.lookAt(_matrixPosition);\n      shadowCamera.updateMatrixWorld();\n      shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld); //\n\n      if (light.cameraHelper) light.cameraHelper.visible = light.shadowCameraVisible;\n      if (light.shadowCameraVisible) light.cameraHelper.update(); // compute shadow matrix\n\n      shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      shadowMatrix.multiply(shadowCamera.projectionMatrix);\n      shadowMatrix.multiply(shadowCamera.matrixWorldInverse); // update camera matrices and frustum\n\n      _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n\n      _frustum.setFromMatrix(_projScreenMatrix); // render shadow map\n\n\n      _renderer.setRenderTarget(shadowMap);\n\n      _renderer.clear(); // set object matrices & frustum culling\n\n\n      _renderList.length = 0;\n      projectObject(scene, shadowCamera); // render regular objects\n\n      for (var j = 0, jl = _renderList.length; j < jl; j++) {\n        var object = _renderList[j];\n\n        var geometry = _objects.update(object);\n\n        var material = object.material;\n\n        if (material instanceof THREE.MeshFaceMaterial) {\n          var groups = geometry.groups;\n          var materials = material.materials;\n\n          for (var k = 0, kl = groups.length; k < kl; k++) {\n            var group = groups[k];\n            var groupMaterial = materials[group.materialIndex];\n\n            if (groupMaterial.visible === true) {\n              _renderer.renderBufferDirect(shadowCamera, _lights, null, geometry, getDepthMaterial(object, groupMaterial), object, group);\n            }\n          }\n        } else {\n          _renderer.renderBufferDirect(shadowCamera, _lights, null, geometry, getDepthMaterial(object, material), object);\n        }\n      }\n    } // restore GL state\n\n\n    var clearColor = _renderer.getClearColor(),\n        clearAlpha = _renderer.getClearAlpha();\n\n    _renderer.setClearColor(clearColor, clearAlpha);\n\n    _state.enable(_gl.BLEND);\n\n    if (scope.cullFace === THREE.CullFaceFront) {\n      _gl.cullFace(_gl.BACK);\n    }\n\n    _renderer.resetGLState();\n\n    scope.needsUpdate = false;\n  };\n\n  function getDepthMaterial(object, material) {\n    var geometry = object.geometry;\n    var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;\n    var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\n    var depthMaterial;\n\n    if (object.customDepthMaterial) {\n      depthMaterial = object.customDepthMaterial;\n    } else if (useSkinning) {\n      depthMaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n    } else if (useMorphing) {\n      depthMaterial = _depthMaterialMorph;\n    } else {\n      depthMaterial = _depthMaterial;\n    }\n\n    depthMaterial.visible = material.visible;\n    depthMaterial.wireframe = material.wireframe;\n    depthMaterial.wireframeLinewidth = material.wireframeLinewidth;\n    return depthMaterial;\n  }\n\n  function projectObject(object, camera) {\n    if (object.visible === false) return;\n\n    if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {\n      if (object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {\n        var material = object.material;\n\n        if (material.visible === true) {\n          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n\n          _renderList.push(object);\n        }\n      }\n    }\n\n    var children = object.children;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      projectObject(children[i], camera);\n    }\n  }\n}; // File:src/renderers/webgl/WebGLState.js\n\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\n\n\nTHREE.WebGLState = function (gl, extensions, paramThreeToGL) {\n  var _this = this;\n\n  var newAttributes = new Uint8Array(16);\n  var enabledAttributes = new Uint8Array(16);\n  var capabilities = {};\n  var compressedTextureFormats = null;\n  var currentBlending = null;\n  var currentBlendEquation = null;\n  var currentBlendSrc = null;\n  var currentBlendDst = null;\n  var currentBlendEquationAlpha = null;\n  var currentBlendSrcAlpha = null;\n  var currentBlendDstAlpha = null;\n  var currentDepthFunc = null;\n  var currentDepthWrite = null;\n  var currentColorWrite = null;\n  var currentFlipSided = null;\n  var currentLineWidth = null;\n  var currentPolygonOffsetFactor = null;\n  var currentPolygonOffsetUnits = null;\n  var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  var currentTextureSlot = undefined;\n  var currentBoundTextures = {};\n\n  this.init = function () {\n    gl.clearColor(0, 0, 0, 1);\n    gl.clearDepth(1);\n    gl.clearStencil(0);\n    this.enable(gl.DEPTH_TEST);\n    gl.depthFunc(gl.LEQUAL);\n    gl.frontFace(gl.CCW);\n    gl.cullFace(gl.BACK);\n    this.enable(gl.CULL_FACE);\n    this.enable(gl.BLEND);\n    gl.blendEquation(gl.FUNC_ADD);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n  };\n\n  this.initAttributes = function () {\n    for (var i = 0, l = newAttributes.length; i < l; i++) {\n      newAttributes[i] = 0;\n    }\n  };\n\n  this.enableAttribute = function (attribute) {\n    newAttributes[attribute] = 1;\n\n    if (enabledAttributes[attribute] === 0) {\n      gl.enableVertexAttribArray(attribute);\n      enabledAttributes[attribute] = 1;\n    }\n  };\n\n  this.disableUnusedAttributes = function () {\n    for (var i = 0, l = enabledAttributes.length; i < l; i++) {\n      if (enabledAttributes[i] !== newAttributes[i]) {\n        gl.disableVertexAttribArray(i);\n        enabledAttributes[i] = 0;\n      }\n    }\n  };\n\n  this.enable = function (id) {\n    if (capabilities[id] !== true) {\n      gl.enable(id);\n      capabilities[id] = true;\n    }\n  };\n\n  this.disable = function (id) {\n    if (capabilities[id] !== false) {\n      gl.disable(id);\n      capabilities[id] = false;\n    }\n  };\n\n  this.getCompressedTextureFormats = function () {\n    if (compressedTextureFormats === null) {\n      compressedTextureFormats = [];\n\n      if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc')) {\n        var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);\n\n        for (var i = 0; i < formats.length; i++) {\n          compressedTextureFormats.push(formats[i]);\n        }\n      }\n    }\n\n    return compressedTextureFormats;\n  };\n\n  this.setBlending = function (blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha) {\n    if (blending !== currentBlending) {\n      if (blending === THREE.NoBlending) {\n        this.disable(gl.BLEND);\n      } else if (blending === THREE.AdditiveBlending) {\n        this.enable(gl.BLEND);\n        gl.blendEquation(gl.FUNC_ADD);\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n      } else if (blending === THREE.SubtractiveBlending) {\n        // TODO: Find blendFuncSeparate() combination\n        this.enable(gl.BLEND);\n        gl.blendEquation(gl.FUNC_ADD);\n        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);\n      } else if (blending === THREE.MultiplyBlending) {\n        // TODO: Find blendFuncSeparate() combination\n        this.enable(gl.BLEND);\n        gl.blendEquation(gl.FUNC_ADD);\n        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n      } else if (blending === THREE.CustomBlending) {\n        this.enable(gl.BLEND);\n      } else {\n        this.enable(gl.BLEND);\n        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      }\n\n      currentBlending = blending;\n    }\n\n    if (blending === THREE.CustomBlending) {\n      blendEquationAlpha = blendEquationAlpha || blendEquation;\n      blendSrcAlpha = blendSrcAlpha || blendSrc;\n      blendDstAlpha = blendDstAlpha || blendDst;\n\n      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {\n        gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));\n        currentBlendEquation = blendEquation;\n        currentBlendEquationAlpha = blendEquationAlpha;\n      }\n\n      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {\n        gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));\n        currentBlendSrc = blendSrc;\n        currentBlendDst = blendDst;\n        currentBlendSrcAlpha = blendSrcAlpha;\n        currentBlendDstAlpha = blendDstAlpha;\n      }\n    } else {\n      currentBlendEquation = null;\n      currentBlendSrc = null;\n      currentBlendDst = null;\n      currentBlendEquationAlpha = null;\n      currentBlendSrcAlpha = null;\n      currentBlendDstAlpha = null;\n    }\n  };\n\n  this.setDepthFunc = function (depthFunc) {\n    if (currentDepthFunc !== depthFunc) {\n      if (depthFunc) {\n        switch (depthFunc) {\n          case THREE.NeverDepth:\n            gl.depthFunc(gl.NEVER);\n            break;\n\n          case THREE.AlwaysDepth:\n            gl.depthFunc(gl.ALWAYS);\n            break;\n\n          case THREE.LessDepth:\n            gl.depthFunc(gl.LESS);\n            break;\n\n          case THREE.LessEqualDepth:\n            gl.depthFunc(gl.LEQUAL);\n            break;\n\n          case THREE.EqualDepth:\n            gl.depthFunc(gl.EQUAL);\n            break;\n\n          case THREE.GreaterEqualDepth:\n            gl.depthFunc(gl.GEQUAL);\n            break;\n\n          case THREE.GreaterDepth:\n            gl.depthFunc(gl.GREATER);\n            break;\n\n          case THREE.NotEqualDepth:\n            gl.depthFunc(gl.NOTEQUAL);\n            break;\n\n          default:\n            gl.depthFunc(gl.LEQUAL);\n        }\n      } else {\n        gl.depthFunc(gl.LEQUAL);\n      }\n\n      currentDepthFunc = depthFunc;\n    }\n  };\n\n  this.setDepthTest = function (depthTest) {\n    if (depthTest) {\n      this.enable(gl.DEPTH_TEST);\n    } else {\n      this.disable(gl.DEPTH_TEST);\n    }\n  };\n\n  this.setDepthWrite = function (depthWrite) {\n    if (currentDepthWrite !== depthWrite) {\n      gl.depthMask(depthWrite);\n      currentDepthWrite = depthWrite;\n    }\n  };\n\n  this.setColorWrite = function (colorWrite) {\n    if (currentColorWrite !== colorWrite) {\n      gl.colorMask(colorWrite, colorWrite, colorWrite, colorWrite);\n      currentColorWrite = colorWrite;\n    }\n  };\n\n  this.setFlipSided = function (flipSided) {\n    if (currentFlipSided !== flipSided) {\n      if (flipSided) {\n        gl.frontFace(gl.CW);\n      } else {\n        gl.frontFace(gl.CCW);\n      }\n\n      currentFlipSided = flipSided;\n    }\n  };\n\n  this.setLineWidth = function (width) {\n    if (width !== currentLineWidth) {\n      gl.lineWidth(width);\n      currentLineWidth = width;\n    }\n  };\n\n  this.setPolygonOffset = function (polygonOffset, factor, units) {\n    if (polygonOffset) {\n      this.enable(gl.POLYGON_OFFSET_FILL);\n    } else {\n      this.disable(gl.POLYGON_OFFSET_FILL);\n    }\n\n    if (polygonOffset && (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units)) {\n      gl.polygonOffset(factor, units);\n      currentPolygonOffsetFactor = factor;\n      currentPolygonOffsetUnits = units;\n    }\n  };\n\n  this.setScissorTest = function (scissorTest) {\n    if (scissorTest) {\n      this.enable(gl.SCISSOR_TEST);\n    } else {\n      this.disable(gl.SCISSOR_TEST);\n    }\n  }; // texture\n\n\n  this.activeTexture = function (webglSlot) {\n    if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n    if (currentTextureSlot !== webglSlot) {\n      gl.activeTexture(webglSlot);\n      currentTextureSlot = webglSlot;\n    }\n  };\n\n  this.bindTexture = function (webglType, webglTexture) {\n    if (currentTextureSlot === undefined) {\n      _this.activeTexture();\n    }\n\n    var boundTexture = currentBoundTextures[currentTextureSlot];\n\n    if (boundTexture === undefined) {\n      boundTexture = {\n        type: undefined,\n        texture: undefined\n      };\n      currentBoundTextures[currentTextureSlot] = boundTexture;\n    }\n\n    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\n      gl.bindTexture(webglType, webglTexture);\n      boundTexture.type = webglType;\n      boundTexture.texture = webglTexture;\n    }\n  };\n\n  this.compressedTexImage2D = function () {\n    try {\n      gl.compressedTexImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  this.texImage2D = function () {\n    try {\n      gl.texImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(error);\n    }\n  }; //\n\n\n  this.reset = function () {\n    for (var i = 0; i < enabledAttributes.length; i++) {\n      if (enabledAttributes[i] === 1) {\n        gl.disableVertexAttribArray(i);\n        enabledAttributes[i] = 0;\n      }\n    }\n\n    capabilities = {};\n    compressedTextureFormats = null;\n    currentBlending = null;\n    currentDepthWrite = null;\n    currentColorWrite = null;\n    currentFlipSided = null;\n  };\n}; // File:src/renderers/webgl/plugins/LensFlarePlugin.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.LensFlarePlugin = function (renderer, flares) {\n  var gl = renderer.context;\n  var state = renderer.state;\n  var vertexBuffer, elementBuffer;\n  var program, attributes, uniforms;\n  var hasVertexTexture;\n  var tempTexture, occlusionTexture;\n\n  var init = function init() {\n    var vertices = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]);\n    var faces = new Uint16Array([0, 1, 2, 0, 2, 3]); // buffers\n\n    vertexBuffer = gl.createBuffer();\n    elementBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW); // textures\n\n    tempTexture = gl.createTexture();\n    occlusionTexture = gl.createTexture();\n    state.bindTexture(gl.TEXTURE_2D, tempTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    state.bindTexture(gl.TEXTURE_2D, occlusionTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    hasVertexTexture = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;\n    var shader;\n\n    if (hasVertexTexture) {\n      shader = {\n        vertexShader: [\"uniform lowp int renderType;\", \"uniform vec3 screenPosition;\", \"uniform vec2 scale;\", \"uniform float rotation;\", \"uniform sampler2D occlusionMap;\", \"attribute vec2 position;\", \"attribute vec2 uv;\", \"varying vec2 vUV;\", \"varying float vVisibility;\", \"void main() {\", \"vUV = uv;\", \"vec2 pos = position;\", \"if( renderType == 2 ) {\", \"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\", \"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\", \"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\", \"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\", \"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\", \"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\", \"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\", \"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\", \"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\", \"vVisibility =        visibility.r / 9.0;\", \"vVisibility *= 1.0 - visibility.g / 9.0;\", \"vVisibility *=       visibility.b / 9.0;\", \"vVisibility *= 1.0 - visibility.a / 9.0;\", \"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\", \"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\", \"}\", \"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\", \"}\"].join(\"\\n\"),\n        fragmentShader: [\"uniform lowp int renderType;\", \"uniform sampler2D map;\", \"uniform float opacity;\", \"uniform vec3 color;\", \"varying vec2 vUV;\", \"varying float vVisibility;\", \"void main() {\", // pink square\n        \"if( renderType == 0 ) {\", \"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\", // restore\n        \"} else if( renderType == 1 ) {\", \"gl_FragColor = texture2D( map, vUV );\", // flare\n        \"} else {\", \"vec4 texture = texture2D( map, vUV );\", \"texture.a *= opacity * vVisibility;\", \"gl_FragColor = texture;\", \"gl_FragColor.rgb *= color;\", \"}\", \"}\"].join(\"\\n\")\n      };\n    } else {\n      shader = {\n        vertexShader: [\"uniform lowp int renderType;\", \"uniform vec3 screenPosition;\", \"uniform vec2 scale;\", \"uniform float rotation;\", \"attribute vec2 position;\", \"attribute vec2 uv;\", \"varying vec2 vUV;\", \"void main() {\", \"vUV = uv;\", \"vec2 pos = position;\", \"if( renderType == 2 ) {\", \"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\", \"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\", \"}\", \"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\", \"}\"].join(\"\\n\"),\n        fragmentShader: [\"precision mediump float;\", \"uniform lowp int renderType;\", \"uniform sampler2D map;\", \"uniform sampler2D occlusionMap;\", \"uniform float opacity;\", \"uniform vec3 color;\", \"varying vec2 vUV;\", \"void main() {\", // pink square\n        \"if( renderType == 0 ) {\", \"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\", // restore\n        \"} else if( renderType == 1 ) {\", \"gl_FragColor = texture2D( map, vUV );\", // flare\n        \"} else {\", \"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\", \"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\", \"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\", \"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\", \"visibility = ( 1.0 - visibility / 4.0 );\", \"vec4 texture = texture2D( map, vUV );\", \"texture.a *= opacity * visibility;\", \"gl_FragColor = texture;\", \"gl_FragColor.rgb *= color;\", \"}\", \"}\"].join(\"\\n\")\n      };\n    }\n\n    program = createProgram(shader);\n    attributes = {\n      vertex: gl.getAttribLocation(program, \"position\"),\n      uv: gl.getAttribLocation(program, \"uv\")\n    };\n    uniforms = {\n      renderType: gl.getUniformLocation(program, \"renderType\"),\n      map: gl.getUniformLocation(program, \"map\"),\n      occlusionMap: gl.getUniformLocation(program, \"occlusionMap\"),\n      opacity: gl.getUniformLocation(program, \"opacity\"),\n      color: gl.getUniformLocation(program, \"color\"),\n      scale: gl.getUniformLocation(program, \"scale\"),\n      rotation: gl.getUniformLocation(program, \"rotation\"),\n      screenPosition: gl.getUniformLocation(program, \"screenPosition\")\n    };\n  };\n  /*\r\n   * Render lens flares\r\n   * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n   *         reads these back and calculates occlusion.\r\n   */\n\n\n  this.render = function (scene, camera, viewportWidth, viewportHeight) {\n    if (flares.length === 0) return;\n    var tempPosition = new THREE.Vector3();\n    var invAspect = viewportHeight / viewportWidth,\n        halfViewportWidth = viewportWidth * 0.5,\n        halfViewportHeight = viewportHeight * 0.5;\n    var size = 16 / viewportHeight,\n        scale = new THREE.Vector2(size * invAspect, size);\n    var screenPosition = new THREE.Vector3(1, 1, 0),\n        screenPositionPixels = new THREE.Vector2(1, 1);\n\n    if (program === undefined) {\n      init();\n    }\n\n    gl.useProgram(program);\n    state.initAttributes();\n    state.enableAttribute(attributes.vertex);\n    state.enableAttribute(attributes.uv);\n    state.disableUnusedAttributes(); // loop through all lens flares to update their occlusion and positions\n    // setup gl and common used attribs/uniforms\n\n    gl.uniform1i(uniforms.occlusionMap, 0);\n    gl.uniform1i(uniforms.map, 1);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);\n    gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);\n    state.disable(gl.CULL_FACE);\n    gl.depthMask(false);\n\n    for (var i = 0, l = flares.length; i < l; i++) {\n      size = 16 / viewportHeight;\n      scale.set(size * invAspect, size); // calc object screen position\n\n      var flare = flares[i];\n      tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);\n      tempPosition.applyMatrix4(camera.matrixWorldInverse);\n      tempPosition.applyProjection(camera.projectionMatrix); // setup arrays for gl programs\n\n      screenPosition.copy(tempPosition);\n      screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\n      screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight; // screen cull\n\n      if (hasVertexTexture || screenPositionPixels.x > 0 && screenPositionPixels.x < viewportWidth && screenPositionPixels.y > 0 && screenPositionPixels.y < viewportHeight) {\n        // save current RGB to temp texture\n        state.activeTexture(gl.TEXTURE0);\n        state.bindTexture(gl.TEXTURE_2D, null);\n        state.activeTexture(gl.TEXTURE1);\n        state.bindTexture(gl.TEXTURE_2D, tempTexture);\n        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0); // render pink quad\n\n        gl.uniform1i(uniforms.renderType, 0);\n        gl.uniform2f(uniforms.scale, scale.x, scale.y);\n        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);\n        state.disable(gl.BLEND);\n        state.enable(gl.DEPTH_TEST);\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); // copy result to occlusionMap\n\n        state.activeTexture(gl.TEXTURE0);\n        state.bindTexture(gl.TEXTURE_2D, occlusionTexture);\n        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0); // restore graphics\n\n        gl.uniform1i(uniforms.renderType, 1);\n        state.disable(gl.DEPTH_TEST);\n        state.activeTexture(gl.TEXTURE1);\n        state.bindTexture(gl.TEXTURE_2D, tempTexture);\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); // update object positions\n\n        flare.positionScreen.copy(screenPosition);\n\n        if (flare.customUpdateCallback) {\n          flare.customUpdateCallback(flare);\n        } else {\n          flare.updateLensFlares();\n        } // render flares\n\n\n        gl.uniform1i(uniforms.renderType, 2);\n        state.enable(gl.BLEND);\n\n        for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {\n          var sprite = flare.lensFlares[j];\n\n          if (sprite.opacity > 0.001 && sprite.scale > 0.001) {\n            screenPosition.x = sprite.x;\n            screenPosition.y = sprite.y;\n            screenPosition.z = sprite.z;\n            size = sprite.size * sprite.scale / viewportHeight;\n            scale.x = size * invAspect;\n            scale.y = size;\n            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);\n            gl.uniform2f(uniforms.scale, scale.x, scale.y);\n            gl.uniform1f(uniforms.rotation, sprite.rotation);\n            gl.uniform1f(uniforms.opacity, sprite.opacity);\n            gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);\n            state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);\n            renderer.setTexture(sprite.texture, 1);\n            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n          }\n        }\n      }\n    } // restore gl\n\n\n    state.enable(gl.CULL_FACE);\n    state.enable(gl.DEPTH_TEST);\n    gl.depthMask(true);\n    renderer.resetGLState();\n  };\n\n  function createProgram(shader) {\n    var program = gl.createProgram();\n    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    var prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n    gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);\n    gl.shaderSource(vertexShader, prefix + shader.vertexShader);\n    gl.compileShader(fragmentShader);\n    gl.compileShader(vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.attachShader(program, vertexShader);\n    gl.linkProgram(program);\n    return program;\n  }\n}; // File:src/renderers/webgl/plugins/SpritePlugin.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\n\nTHREE.SpritePlugin = function (renderer, sprites) {\n  var gl = renderer.context;\n  var state = renderer.state;\n  var vertexBuffer, elementBuffer;\n  var program, attributes, uniforms;\n  var texture; // decompose matrixWorld\n\n  var spritePosition = new THREE.Vector3();\n  var spriteRotation = new THREE.Quaternion();\n  var spriteScale = new THREE.Vector3();\n\n  var init = function init() {\n    var vertices = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]);\n    var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);\n    vertexBuffer = gl.createBuffer();\n    elementBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);\n    program = createProgram();\n    attributes = {\n      position: gl.getAttribLocation(program, 'position'),\n      uv: gl.getAttribLocation(program, 'uv')\n    };\n    uniforms = {\n      uvOffset: gl.getUniformLocation(program, 'uvOffset'),\n      uvScale: gl.getUniformLocation(program, 'uvScale'),\n      rotation: gl.getUniformLocation(program, 'rotation'),\n      scale: gl.getUniformLocation(program, 'scale'),\n      color: gl.getUniformLocation(program, 'color'),\n      map: gl.getUniformLocation(program, 'map'),\n      opacity: gl.getUniformLocation(program, 'opacity'),\n      modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),\n      projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),\n      fogType: gl.getUniformLocation(program, 'fogType'),\n      fogDensity: gl.getUniformLocation(program, 'fogDensity'),\n      fogNear: gl.getUniformLocation(program, 'fogNear'),\n      fogFar: gl.getUniformLocation(program, 'fogFar'),\n      fogColor: gl.getUniformLocation(program, 'fogColor'),\n      alphaTest: gl.getUniformLocation(program, 'alphaTest')\n    };\n    var canvas = document.createElement('canvas');\n    canvas.width = 8;\n    canvas.height = 8;\n    var context = canvas.getContext('2d');\n    context.fillStyle = 'white';\n    context.fillRect(0, 0, 8, 8);\n    texture = new THREE.Texture(canvas);\n    texture.needsUpdate = true;\n  };\n\n  this.render = function (scene, camera) {\n    if (sprites.length === 0) return; // setup gl\n\n    if (program === undefined) {\n      init();\n    }\n\n    gl.useProgram(program);\n    state.initAttributes();\n    state.enableAttribute(attributes.position);\n    state.enableAttribute(attributes.uv);\n    state.disableUnusedAttributes();\n    state.disable(gl.CULL_FACE);\n    state.enable(gl.BLEND);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);\n    gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);\n    gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);\n    state.activeTexture(gl.TEXTURE0);\n    gl.uniform1i(uniforms.map, 0);\n    var oldFogType = 0;\n    var sceneFogType = 0;\n    var fog = scene.fog;\n\n    if (fog) {\n      gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);\n\n      if (fog instanceof THREE.Fog) {\n        gl.uniform1f(uniforms.fogNear, fog.near);\n        gl.uniform1f(uniforms.fogFar, fog.far);\n        gl.uniform1i(uniforms.fogType, 1);\n        oldFogType = 1;\n        sceneFogType = 1;\n      } else if (fog instanceof THREE.FogExp2) {\n        gl.uniform1f(uniforms.fogDensity, fog.density);\n        gl.uniform1i(uniforms.fogType, 2);\n        oldFogType = 2;\n        sceneFogType = 2;\n      }\n    } else {\n      gl.uniform1i(uniforms.fogType, 0);\n      oldFogType = 0;\n      sceneFogType = 0;\n    } // update positions and sort\n\n\n    for (var i = 0, l = sprites.length; i < l; i++) {\n      var sprite = sprites[i];\n      sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);\n      sprite.z = -sprite.modelViewMatrix.elements[14];\n    }\n\n    sprites.sort(painterSortStable); // render all sprites\n\n    var scale = [];\n\n    for (var i = 0, l = sprites.length; i < l; i++) {\n      var sprite = sprites[i];\n      var material = sprite.material;\n      gl.uniform1f(uniforms.alphaTest, material.alphaTest);\n      gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);\n      sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);\n      scale[0] = spriteScale.x;\n      scale[1] = spriteScale.y;\n      var fogType = 0;\n\n      if (scene.fog && material.fog) {\n        fogType = sceneFogType;\n      }\n\n      if (oldFogType !== fogType) {\n        gl.uniform1i(uniforms.fogType, fogType);\n        oldFogType = fogType;\n      }\n\n      if (material.map !== null) {\n        gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);\n        gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);\n      } else {\n        gl.uniform2f(uniforms.uvOffset, 0, 0);\n        gl.uniform2f(uniforms.uvScale, 1, 1);\n      }\n\n      gl.uniform1f(uniforms.opacity, material.opacity);\n      gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);\n      gl.uniform1f(uniforms.rotation, material.rotation);\n      gl.uniform2fv(uniforms.scale, scale);\n      state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);\n      state.setDepthTest(material.depthTest);\n      state.setDepthWrite(material.depthWrite);\n\n      if (material.map && material.map.image && material.map.image.width) {\n        renderer.setTexture(material.map, 0);\n      } else {\n        renderer.setTexture(texture, 0);\n      }\n\n      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n    } // restore gl\n\n\n    state.enable(gl.CULL_FACE);\n    renderer.resetGLState();\n  };\n\n  function createProgram() {\n    var program = gl.createProgram();\n    var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(vertexShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform float rotation;', 'uniform vec2 scale;', 'uniform vec2 uvOffset;', 'uniform vec2 uvScale;', 'attribute vec2 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', 'vUV = uvOffset + uv * uvScale;', 'vec2 alignedPosition = position * scale;', 'vec2 rotatedPosition;', 'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;', 'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;', 'vec4 finalPosition;', 'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );', 'finalPosition.xy += rotatedPosition;', 'finalPosition = projectionMatrix * finalPosition;', 'gl_Position = finalPosition;', '}'].join('\\n'));\n    gl.shaderSource(fragmentShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform vec3 color;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform int fogType;', 'uniform vec3 fogColor;', 'uniform float fogDensity;', 'uniform float fogNear;', 'uniform float fogFar;', 'uniform float alphaTest;', 'varying vec2 vUV;', 'void main() {', 'vec4 texture = texture2D( map, vUV );', 'if ( texture.a < alphaTest ) discard;', 'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );', 'if ( fogType > 0 ) {', 'float depth = gl_FragCoord.z / gl_FragCoord.w;', 'float fogFactor = 0.0;', 'if ( fogType == 1 ) {', 'fogFactor = smoothstep( fogNear, fogFar, depth );', '} else {', 'const float LOG2 = 1.442695;', 'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );', 'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );', '}', 'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );', '}', '}'].join('\\n'));\n    gl.compileShader(vertexShader);\n    gl.compileShader(fragmentShader);\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    return program;\n  }\n\n  function painterSortStable(a, b) {\n    if (a.z !== b.z) {\n      return b.z - a.z;\n    } else {\n      return b.id - a.id;\n    }\n  }\n}; // File:src/extras/GeometryUtils.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.GeometryUtils = {\n  merge: function merge(geometry1, geometry2, materialIndexOffset) {\n    console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');\n    var matrix;\n\n    if (geometry2 instanceof THREE.Mesh) {\n      geometry2.matrixAutoUpdate && geometry2.updateMatrix();\n      matrix = geometry2.matrix;\n      geometry2 = geometry2.geometry;\n    }\n\n    geometry1.merge(geometry2, matrix, materialIndexOffset);\n  },\n  center: function center(geometry) {\n    console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');\n    return geometry.center();\n  }\n}; // File:src/extras/ImageUtils.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Daosheng Mu / https://github.com/DaoshengMu/\r\n */\n\nTHREE.ImageUtils = {\n  crossOrigin: undefined,\n  loadTexture: function loadTexture(url, mapping, onLoad, onError) {\n    var loader = new THREE.ImageLoader();\n    loader.crossOrigin = this.crossOrigin;\n    var texture = new THREE.Texture(undefined, mapping);\n    loader.load(url, function (image) {\n      texture.image = image;\n      texture.needsUpdate = true;\n      if (onLoad) onLoad(texture);\n    }, undefined, function (event) {\n      if (onError) onError(event);\n    });\n    texture.sourceFile = url;\n    return texture;\n  },\n  loadTextureCube: function loadTextureCube(array, mapping, onLoad, onError) {\n    var images = [];\n    var loader = new THREE.ImageLoader();\n    loader.crossOrigin = this.crossOrigin;\n    var texture = new THREE.CubeTexture(images, mapping);\n    var loaded = 0;\n\n    var loadTexture = function loadTexture(i) {\n      loader.load(array[i], function (image) {\n        texture.images[i] = image;\n        loaded += 1;\n\n        if (loaded === 6) {\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }\n      }, undefined, onError);\n    };\n\n    for (var i = 0, il = array.length; i < il; ++i) {\n      loadTexture(i);\n    }\n\n    return texture;\n  },\n  loadCompressedTexture: function loadCompressedTexture() {\n    console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');\n  },\n  loadCompressedTextureCube: function loadCompressedTextureCube() {\n    console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');\n  },\n  getNormalMap: function getNormalMap(image, depth) {\n    // Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\n    var cross = function cross(a, b) {\n      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n    };\n\n    var subtract = function subtract(a, b) {\n      return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\n    };\n\n    var normalize = function normalize(a) {\n      var l = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n      return [a[0] / l, a[1] / l, a[2] / l];\n    };\n\n    depth = depth | 1;\n    var width = image.width;\n    var height = image.height;\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    var context = canvas.getContext('2d');\n    context.drawImage(image, 0, 0);\n    var data = context.getImageData(0, 0, width, height).data;\n    var imageData = context.createImageData(width, height);\n    var output = imageData.data;\n\n    for (var x = 0; x < width; x++) {\n      for (var y = 0; y < height; y++) {\n        var ly = y - 1 < 0 ? 0 : y - 1;\n        var uy = y + 1 > height - 1 ? height - 1 : y + 1;\n        var lx = x - 1 < 0 ? 0 : x - 1;\n        var ux = x + 1 > width - 1 ? width - 1 : x + 1;\n        var points = [];\n        var origin = [0, 0, data[(y * width + x) * 4] / 255 * depth];\n        points.push([-1, 0, data[(y * width + lx) * 4] / 255 * depth]);\n        points.push([-1, -1, data[(ly * width + lx) * 4] / 255 * depth]);\n        points.push([0, -1, data[(ly * width + x) * 4] / 255 * depth]);\n        points.push([1, -1, data[(ly * width + ux) * 4] / 255 * depth]);\n        points.push([1, 0, data[(y * width + ux) * 4] / 255 * depth]);\n        points.push([1, 1, data[(uy * width + ux) * 4] / 255 * depth]);\n        points.push([0, 1, data[(uy * width + x) * 4] / 255 * depth]);\n        points.push([-1, 1, data[(uy * width + lx) * 4] / 255 * depth]);\n        var normals = [];\n        var num_points = points.length;\n\n        for (var i = 0; i < num_points; i++) {\n          var v1 = points[i];\n          var v2 = points[(i + 1) % num_points];\n          v1 = subtract(v1, origin);\n          v2 = subtract(v2, origin);\n          normals.push(normalize(cross(v1, v2)));\n        }\n\n        var normal = [0, 0, 0];\n\n        for (var i = 0; i < normals.length; i++) {\n          normal[0] += normals[i][0];\n          normal[1] += normals[i][1];\n          normal[2] += normals[i][2];\n        }\n\n        normal[0] /= normals.length;\n        normal[1] /= normals.length;\n        normal[2] /= normals.length;\n        var idx = (y * width + x) * 4;\n        output[idx] = (normal[0] + 1.0) / 2.0 * 255 | 0;\n        output[idx + 1] = (normal[1] + 1.0) / 2.0 * 255 | 0;\n        output[idx + 2] = normal[2] * 255 | 0;\n        output[idx + 3] = 255;\n      }\n    }\n\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  },\n  generateDataTexture: function generateDataTexture(width, height, color) {\n    var size = width * height;\n    var data = new Uint8Array(3 * size);\n    var r = Math.floor(color.r * 255);\n    var g = Math.floor(color.g * 255);\n    var b = Math.floor(color.b * 255);\n\n    for (var i = 0; i < size; i++) {\n      data[i * 3] = r;\n      data[i * 3 + 1] = g;\n      data[i * 3 + 2] = b;\n    }\n\n    var texture = new THREE.DataTexture(data, width, height, THREE.RGBFormat);\n    texture.needsUpdate = true;\n    return texture;\n  }\n}; // File:src/extras/SceneUtils.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.SceneUtils = {\n  createMultiMaterialObject: function createMultiMaterialObject(geometry, materials) {\n    var group = new THREE.Group();\n\n    for (var i = 0, l = materials.length; i < l; i++) {\n      group.add(new THREE.Mesh(geometry, materials[i]));\n    }\n\n    return group;\n  },\n  detach: function detach(child, parent, scene) {\n    child.applyMatrix(parent.matrixWorld);\n    parent.remove(child);\n    scene.add(child);\n  },\n  attach: function attach(child, scene, parent) {\n    var matrixWorldInverse = new THREE.Matrix4();\n    matrixWorldInverse.getInverse(parent.matrixWorld);\n    child.applyMatrix(matrixWorldInverse);\n    scene.remove(child);\n    parent.add(child);\n  }\n}; // File:src/extras/FontUtils.js\n\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For Text operations in three.js (See TextGeometry)\r\n *\r\n * It uses techniques used in:\r\n *\r\n *\tTriangulation ported from AS3\r\n *\t\tSimple Polygon Triangulation\r\n *\t\thttp://actionsnippet.com/?p=1462\r\n *\r\n * \tA Method to triangulate shapes with holes\r\n *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\r\n *\r\n */\n\nTHREE.FontUtils = {\n  faces: {},\n  // Just for now. face[weight][style]\n  face: 'helvetiker',\n  weight: 'normal',\n  style: 'normal',\n  size: 150,\n  divisions: 10,\n  getFace: function getFace() {\n    try {\n      return this.faces[this.face.toLowerCase()][this.weight][this.style];\n    } catch (e) {\n      throw \"The font \" + this.face + \" with \" + this.weight + \" weight and \" + this.style + \" style is missing.\";\n    }\n  },\n  loadFace: function loadFace(data) {\n    var family = data.familyName.toLowerCase();\n    var ThreeFont = this;\n    ThreeFont.faces[family] = ThreeFont.faces[family] || {};\n    ThreeFont.faces[family][data.cssFontWeight] = ThreeFont.faces[family][data.cssFontWeight] || {};\n    ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;\n    ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;\n    return data;\n  },\n  drawText: function drawText(text) {\n    // RenderText\n    var i,\n        face = this.getFace(),\n        scale = this.size / face.resolution,\n        offset = 0,\n        chars = String(text).split(''),\n        length = chars.length;\n    var fontPaths = [];\n\n    for (i = 0; i < length; i++) {\n      var path = new THREE.Path();\n      var ret = this.extractGlyphPoints(chars[i], face, scale, offset, path);\n      offset += ret.offset;\n      fontPaths.push(ret.path);\n    } // get the width\n\n\n    var width = offset / 2; //\n    // for ( p = 0; p < allPts.length; p++ ) {\n    //\n    // \tallPts[ p ].x -= width;\n    //\n    // }\n    //var extract = this.extractPoints( allPts, characterPts );\n    //extract.contour = allPts;\n    //extract.paths = fontPaths;\n    //extract.offset = width;\n\n    return {\n      paths: fontPaths,\n      offset: width\n    };\n  },\n  extractGlyphPoints: function extractGlyphPoints(c, face, scale, offset, path) {\n    var pts = [];\n    var i,\n        i2,\n        divisions,\n        outline,\n        action,\n        length,\n        scaleX,\n        scaleY,\n        x,\n        y,\n        cpx,\n        cpy,\n        cpx0,\n        cpy0,\n        cpx1,\n        cpy1,\n        cpx2,\n        cpy2,\n        laste,\n        glyph = face.glyphs[c] || face.glyphs['?'];\n    if (!glyph) return;\n\n    if (glyph.o) {\n      outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n      length = outline.length;\n      scaleX = scale;\n      scaleY = scale;\n\n      for (i = 0; i < length;) {\n        action = outline[i++]; //console.log( action );\n\n        switch (action) {\n          case 'm':\n            // Move To\n            x = outline[i++] * scaleX + offset;\n            y = outline[i++] * scaleY;\n            path.moveTo(x, y);\n            break;\n\n          case 'l':\n            // Line To\n            x = outline[i++] * scaleX + offset;\n            y = outline[i++] * scaleY;\n            path.lineTo(x, y);\n            break;\n\n          case 'q':\n            // QuadraticCurveTo\n            cpx = outline[i++] * scaleX + offset;\n            cpy = outline[i++] * scaleY;\n            cpx1 = outline[i++] * scaleX + offset;\n            cpy1 = outline[i++] * scaleY;\n            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n            laste = pts[pts.length - 1];\n\n            if (laste) {\n              cpx0 = laste.x;\n              cpy0 = laste.y;\n\n              for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {\n                var t = i2 / divisions;\n                THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);\n                THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);\n              }\n            }\n\n            break;\n\n          case 'b':\n            // Cubic Bezier Curve\n            cpx = outline[i++] * scaleX + offset;\n            cpy = outline[i++] * scaleY;\n            cpx1 = outline[i++] * scaleX + offset;\n            cpy1 = outline[i++] * scaleY;\n            cpx2 = outline[i++] * scaleX + offset;\n            cpy2 = outline[i++] * scaleY;\n            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n            laste = pts[pts.length - 1];\n\n            if (laste) {\n              cpx0 = laste.x;\n              cpy0 = laste.y;\n\n              for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {\n                var t = i2 / divisions;\n                THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);\n                THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);\n              }\n            }\n\n            break;\n        }\n      }\n    }\n\n    return {\n      offset: glyph.ha * scale,\n      path: path\n    };\n  }\n};\n\nTHREE.FontUtils.generateShapes = function (text, parameters) {\n  // Parameters\n  parameters = parameters || {};\n  var size = parameters.size !== undefined ? parameters.size : 100;\n  var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;\n  var font = parameters.font !== undefined ? parameters.font : 'helvetiker';\n  var weight = parameters.weight !== undefined ? parameters.weight : 'normal';\n  var style = parameters.style !== undefined ? parameters.style : 'normal';\n  THREE.FontUtils.size = size;\n  THREE.FontUtils.divisions = curveSegments;\n  THREE.FontUtils.face = font;\n  THREE.FontUtils.weight = weight;\n  THREE.FontUtils.style = style; // Get a Font data json object\n\n  var data = THREE.FontUtils.drawText(text);\n  var paths = data.paths;\n  var shapes = [];\n\n  for (var p = 0, pl = paths.length; p < pl; p++) {\n    Array.prototype.push.apply(shapes, paths[p].toShapes());\n  }\n\n  return shapes;\n};\n/**\r\n * This code is a quick port of code written in C++ which was submitted to\r\n * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n * See original code and more information here:\r\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n *\r\n * ported to actionscript by Zevan Rosser\r\n * www.actionsnippet.com\r\n *\r\n * ported to javascript by Joshua Koo\r\n * http://www.lab4games.net/zz85/blog\r\n *\r\n */\n\n\n(function (namespace) {\n  var EPSILON = 0.0000000001; // takes in an contour array and returns\n\n  var process = function process(contour, indices) {\n    var n = contour.length;\n    if (n < 3) return null;\n    var result = [],\n        verts = [],\n        vertIndices = [];\n    /* we want a counter-clockwise polygon in verts */\n\n    var u, v, w;\n\n    if (area(contour) > 0.0) {\n      for (v = 0; v < n; v++) {\n        verts[v] = v;\n      }\n    } else {\n      for (v = 0; v < n; v++) {\n        verts[v] = n - 1 - v;\n      }\n    }\n\n    var nv = n;\n    /*  remove nv - 2 vertices, creating 1 triangle every time */\n\n    var count = 2 * nv;\n    /* error detection */\n\n    for (v = nv - 1; nv > 2;) {\n      /* if we loop, it is probably a non-simple polygon */\n      if (count-- <= 0) {\n        //** Triangulate: ERROR - probable bad polygon!\n        //throw ( \"Warning, unable to triangulate polygon!\" );\n        //return null;\n        // Sometimes warning is fine, especially polygons are triangulated in reverse.\n        console.warn('THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()');\n        if (indices) return vertIndices;\n        return result;\n      }\n      /* three consecutive vertices in current polygon, <u,v,w> */\n\n\n      u = v;\n      if (nv <= u) u = 0;\n      /* previous */\n\n      v = u + 1;\n      if (nv <= v) v = 0;\n      /* new v    */\n\n      w = v + 1;\n      if (nv <= w) w = 0;\n      /* next     */\n\n      if (snip(contour, u, v, w, nv, verts)) {\n        var a, b, c, s, t;\n        /* true names of the vertices */\n\n        a = verts[u];\n        b = verts[v];\n        c = verts[w];\n        /* output Triangle */\n\n        result.push([contour[a], contour[b], contour[c]]);\n        vertIndices.push([verts[u], verts[v], verts[w]]);\n        /* remove v from the remaining polygon */\n\n        for (s = v, t = v + 1; t < nv; s++, t++) {\n          verts[s] = verts[t];\n        }\n\n        nv--;\n        /* reset error detection counter */\n\n        count = 2 * nv;\n      }\n    }\n\n    if (indices) return vertIndices;\n    return result;\n  }; // calculate area of the contour polygon\n\n\n  var area = function area(contour) {\n    var n = contour.length;\n    var a = 0.0;\n\n    for (var p = n - 1, q = 0; q < n; p = q++) {\n      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n    }\n\n    return a * 0.5;\n  };\n\n  var snip = function snip(contour, u, v, w, n, verts) {\n    var p;\n    var ax, ay, bx, by;\n    var cx, cy, px, py;\n    ax = contour[verts[u]].x;\n    ay = contour[verts[u]].y;\n    bx = contour[verts[v]].x;\n    by = contour[verts[v]].y;\n    cx = contour[verts[w]].x;\n    cy = contour[verts[w]].y;\n    if (EPSILON > (bx - ax) * (cy - ay) - (by - ay) * (cx - ax)) return false;\n    var aX, aY, bX, bY, cX, cY;\n    var apx, apy, bpx, bpy, cpx, cpy;\n    var cCROSSap, bCROSScp, aCROSSbp;\n    aX = cx - bx;\n    aY = cy - by;\n    bX = ax - cx;\n    bY = ay - cy;\n    cX = bx - ax;\n    cY = by - ay;\n\n    for (p = 0; p < n; p++) {\n      px = contour[verts[p]].x;\n      py = contour[verts[p]].y;\n      if (px === ax && py === ay || px === bx && py === by || px === cx && py === cy) continue;\n      apx = px - ax;\n      apy = py - ay;\n      bpx = px - bx;\n      bpy = py - by;\n      cpx = px - cx;\n      cpy = py - cy; // see if p is inside triangle abc\n\n      aCROSSbp = aX * bpy - aY * bpx;\n      cCROSSap = cX * apy - cY * apx;\n      bCROSScp = bX * cpy - bY * cpx;\n      if (aCROSSbp >= -EPSILON && bCROSScp >= -EPSILON && cCROSSap >= -EPSILON) return false;\n    }\n\n    return true;\n  };\n\n  namespace.Triangulate = process;\n  namespace.Triangulate.area = area;\n  return namespace;\n})(THREE.FontUtils); // To use the typeface.js face files, hook up the API\n\n\nTHREE.typeface_js = {\n  faces: THREE.FontUtils.faces,\n  loadFace: THREE.FontUtils.loadFace\n};\nif (typeof self !== 'undefined') self._typeface_js = THREE.typeface_js; // File:src/extras/audio/Audio.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.Audio = function (listener) {\n  THREE.Object3D.call(this);\n  this.type = 'Audio';\n  this.context = listener.context;\n  this.source = this.context.createBufferSource();\n  this.source.onended = this.onEnded.bind(this);\n  this.gain = this.context.createGain();\n  this.gain.connect(this.context.destination);\n  this.panner = this.context.createPanner();\n  this.panner.connect(this.gain);\n  this.autoplay = false;\n  this.startTime = 0;\n  this.playbackRate = 1;\n  this.isPlaying = false;\n};\n\nTHREE.Audio.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Audio.prototype.constructor = THREE.Audio;\n\nTHREE.Audio.prototype.load = function (file) {\n  var scope = this;\n  var request = new XMLHttpRequest();\n  request.open('GET', file, true);\n  request.responseType = 'arraybuffer';\n\n  request.onload = function (e) {\n    scope.context.decodeAudioData(this.response, function (buffer) {\n      scope.source.buffer = buffer;\n      if (scope.autoplay) scope.play();\n    });\n  };\n\n  request.send();\n  return this;\n};\n\nTHREE.Audio.prototype.play = function () {\n  if (this.isPlaying === true) {\n    console.warn('THREE.Audio: Audio is already playing.');\n    return;\n  }\n\n  var source = this.context.createBufferSource();\n  source.buffer = this.source.buffer;\n  source.loop = this.source.loop;\n  source.onended = this.source.onended;\n  source.start(0, this.startTime);\n  source.playbackRate.value = this.playbackRate;\n  this.isPlaying = true;\n  this.source = source;\n  this.connect();\n};\n\nTHREE.Audio.prototype.pause = function () {\n  this.source.stop();\n  this.startTime = this.context.currentTime;\n};\n\nTHREE.Audio.prototype.stop = function () {\n  this.source.stop();\n  this.startTime = 0;\n};\n\nTHREE.Audio.prototype.connect = function () {\n  if (this.filter !== undefined) {\n    this.source.connect(this.filter);\n    this.filter.connect(this.panner);\n  } else {\n    this.source.connect(this.panner);\n  }\n};\n\nTHREE.Audio.prototype.disconnect = function () {\n  if (this.filter !== undefined) {\n    this.source.disconnect(this.filter);\n    this.filter.disconnect(this.panner);\n  } else {\n    this.source.disconnect(this.panner);\n  }\n};\n\nTHREE.Audio.prototype.setFilter = function (value) {\n  if (this.isPlaying === true) {\n    this.disconnect();\n    this.filter = value;\n    this.connect();\n  } else {\n    this.filter = value;\n  }\n};\n\nTHREE.Audio.prototype.getFilter = function () {\n  return this.filter;\n};\n\nTHREE.Audio.prototype.setPlaybackRate = function (value) {\n  this.playbackRate = value;\n\n  if (this.isPlaying === true) {\n    this.source.playbackRate.value = this.playbackRate;\n  }\n};\n\nTHREE.Audio.prototype.getPlaybackRate = function () {\n  return this.playbackRate;\n};\n\nTHREE.Audio.prototype.onEnded = function () {\n  this.isPlaying = false;\n};\n\nTHREE.Audio.prototype.setLoop = function (value) {\n  this.source.loop = value;\n};\n\nTHREE.Audio.prototype.getLoop = function () {\n  return this.source.loop;\n};\n\nTHREE.Audio.prototype.setRefDistance = function (value) {\n  this.panner.refDistance = value;\n};\n\nTHREE.Audio.prototype.getRefDistance = function () {\n  return this.panner.refDistance;\n};\n\nTHREE.Audio.prototype.setRolloffFactor = function (value) {\n  this.panner.rolloffFactor = value;\n};\n\nTHREE.Audio.prototype.getRolloffFactor = function () {\n  return this.panner.rolloffFactor;\n};\n\nTHREE.Audio.prototype.setVolume = function (value) {\n  this.gain.gain.value = value;\n};\n\nTHREE.Audio.prototype.getVolume = function () {\n  return this.gain.gain.value;\n};\n\nTHREE.Audio.prototype.updateMatrixWorld = function () {\n  var position = new THREE.Vector3();\n  return function updateMatrixWorld(force) {\n    THREE.Object3D.prototype.updateMatrixWorld.call(this, force);\n    position.setFromMatrixPosition(this.matrixWorld);\n    this.panner.setPosition(position.x, position.y, position.z);\n  };\n}(); // File:src/extras/audio/AudioListener.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.AudioListener = function () {\n  THREE.Object3D.call(this);\n  this.type = 'AudioListener';\n  this.context = new (window.AudioContext || window.webkitAudioContext)();\n};\n\nTHREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\n\nTHREE.AudioListener.prototype.updateMatrixWorld = function () {\n  var position = new THREE.Vector3();\n  var quaternion = new THREE.Quaternion();\n  var scale = new THREE.Vector3();\n  var orientation = new THREE.Vector3();\n  return function updateMatrixWorld(force) {\n    THREE.Object3D.prototype.updateMatrixWorld.call(this, force);\n    var listener = this.context.listener;\n    var up = this.up;\n    this.matrixWorld.decompose(position, quaternion, scale);\n    orientation.set(0, 0, -1).applyQuaternion(quaternion);\n    listener.setPosition(position.x, position.y, position.z);\n    listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);\n  };\n}(); // File:src/extras/core/Curve.js\n\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following classes subclasses THREE.Curve:\r\n *\r\n * -- 2d classes --\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n * THREE.ClosedSplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\n\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\n\n\nTHREE.Curve = function () {}; // Virtual base class method to overwrite and implement in subclasses\n//\t- t [0 .. 1]\n\n\nTHREE.Curve.prototype.getPoint = function (t) {\n  console.warn(\"THREE.Curve: Warning, getPoint() not implemented!\");\n  return null;\n}; // Get point at relative position in curve according to arc length\n// - u [0 .. 1]\n\n\nTHREE.Curve.prototype.getPointAt = function (u) {\n  var t = this.getUtoTmapping(u);\n  return this.getPoint(t);\n}; // Get sequence of points using getPoint( t )\n\n\nTHREE.Curve.prototype.getPoints = function (divisions) {\n  if (!divisions) divisions = 5;\n  var d,\n      pts = [];\n\n  for (d = 0; d <= divisions; d++) {\n    pts.push(this.getPoint(d / divisions));\n  }\n\n  return pts;\n}; // Get sequence of points using getPointAt( u )\n\n\nTHREE.Curve.prototype.getSpacedPoints = function (divisions) {\n  if (!divisions) divisions = 5;\n  var d,\n      pts = [];\n\n  for (d = 0; d <= divisions; d++) {\n    pts.push(this.getPointAt(d / divisions));\n  }\n\n  return pts;\n}; // Get total curve arc length\n\n\nTHREE.Curve.prototype.getLength = function () {\n  var lengths = this.getLengths();\n  return lengths[lengths.length - 1];\n}; // Get list of cumulative segment lengths\n\n\nTHREE.Curve.prototype.getLengths = function (divisions) {\n  if (!divisions) divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200;\n\n  if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n    //console.log( \"cached\", this.cacheArcLengths );\n    return this.cacheArcLengths;\n  }\n\n  this.needsUpdate = false;\n  var cache = [];\n  var current,\n      last = this.getPoint(0);\n  var p,\n      sum = 0;\n  cache.push(0);\n\n  for (p = 1; p <= divisions; p++) {\n    current = this.getPoint(p / divisions);\n    sum += current.distanceTo(last);\n    cache.push(sum);\n    last = current;\n  }\n\n  this.cacheArcLengths = cache;\n  return cache; // { sums: cache, sum:sum }; Sum is in the last element.\n};\n\nTHREE.Curve.prototype.updateArcLengths = function () {\n  this.needsUpdate = true;\n  this.getLengths();\n}; // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\nTHREE.Curve.prototype.getUtoTmapping = function (u, distance) {\n  var arcLengths = this.getLengths();\n  var i = 0,\n      il = arcLengths.length;\n  var targetArcLength; // The targeted u distance value to get\n\n  if (distance) {\n    targetArcLength = distance;\n  } else {\n    targetArcLength = u * arcLengths[il - 1];\n  } //var time = Date.now();\n  // binary search for the index with largest value smaller than target u distance\n\n\n  var low = 0,\n      high = il - 1,\n      comparison;\n\n  while (low <= high) {\n    i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n    comparison = arcLengths[i] - targetArcLength;\n\n    if (comparison < 0) {\n      low = i + 1;\n    } else if (comparison > 0) {\n      high = i - 1;\n    } else {\n      high = i;\n      break; // DONE\n    }\n  }\n\n  i = high; //console.log('b' , i, low, high, Date.now()- time);\n\n  if (arcLengths[i] === targetArcLength) {\n    var t = i / (il - 1);\n    return t;\n  } // we could get finer grain at lengths, or use simple interpolation between two points\n\n\n  var lengthBefore = arcLengths[i];\n  var lengthAfter = arcLengths[i + 1];\n  var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points\n\n  var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t\n\n  var t = (i + segmentFraction) / (il - 1);\n  return t;\n}; // Returns a unit vector tangent at t\n// In case any sub curve does not implement its tangent derivation,\n// 2 points a small delta apart will be used to find its gradient\n// which seems to give a reasonable approximation\n\n\nTHREE.Curve.prototype.getTangent = function (t) {\n  var delta = 0.0001;\n  var t1 = t - delta;\n  var t2 = t + delta; // Capping in case of danger\n\n  if (t1 < 0) t1 = 0;\n  if (t2 > 1) t2 = 1;\n  var pt1 = this.getPoint(t1);\n  var pt2 = this.getPoint(t2);\n  var vec = pt2.clone().sub(pt1);\n  return vec.normalize();\n};\n\nTHREE.Curve.prototype.getTangentAt = function (u) {\n  var t = this.getUtoTmapping(u);\n  return this.getTangent(t);\n};\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\n\n\nTHREE.Curve.Utils = {\n  tangentQuadraticBezier: function tangentQuadraticBezier(t, p0, p1, p2) {\n    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n  },\n  // Puay Bing, thanks for helping with this derivative!\n  tangentCubicBezier: function tangentCubicBezier(t, p0, p1, p2, p3) {\n    return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;\n  },\n  tangentSpline: function tangentSpline(t, p0, p1, p2, p3) {\n    // To check if my formulas are correct\n    var h00 = 6 * t * t - 6 * t; // derived from 2t^3 − 3t^2 + 1\n\n    var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\n    var h01 = -6 * t * t + 6 * t; // − 2t3 + 3t2\n\n    var h11 = 3 * t * t - 2 * t; // t3 − t2\n\n    return h00 + h10 + h01 + h11;\n  },\n  // Catmull-Rom\n  interpolate: function interpolate(p0, p1, p2, p3, t) {\n    var v0 = (p2 - p0) * 0.5;\n    var v1 = (p3 - p1) * 0.5;\n    var t2 = t * t;\n    var t3 = t * t2;\n    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n  }\n}; // TODO: Transformation for Curves?\n\n/**************************************************************\r\n *\t3D Curves\r\n **************************************************************/\n// A Factory method for creating new curve subclasses\n\nTHREE.Curve.create = function (constructor, getPointFunc) {\n  constructor.prototype = Object.create(THREE.Curve.prototype);\n  constructor.prototype.constructor = constructor;\n  constructor.prototype.getPoint = getPointFunc;\n  return constructor;\n}; // File:src/extras/core/CurvePath.js\n\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\n\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\n\n\nTHREE.CurvePath = function () {\n  this.curves = [];\n  this.bends = [];\n  this.autoClose = false; // Automatically closes the path\n};\n\nTHREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);\nTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\n\nTHREE.CurvePath.prototype.add = function (curve) {\n  this.curves.push(curve);\n};\n\nTHREE.CurvePath.prototype.checkConnection = function () {// TODO\n  // If the ending of curve is not connected to the starting\n  // or the next curve, then, this is not a real path\n};\n\nTHREE.CurvePath.prototype.closePath = function () {\n  // TODO Test\n  // and verify for vector3 (needs to implement equals)\n  // Add a line curve if start and end of lines are not connected\n  var startPoint = this.curves[0].getPoint(0);\n  var endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n  if (!startPoint.equals(endPoint)) {\n    this.curves.push(new THREE.LineCurve(endPoint, startPoint));\n  }\n}; // To get accurate point with reference to\n// entire path distance at time t,\n// following has to be done:\n// 1. Length of each sub path have to be known\n// 2. Locate and identify type of curve\n// 3. Get t for the curve\n// 4. Return curve.getPointAt(t')\n\n\nTHREE.CurvePath.prototype.getPoint = function (t) {\n  var d = t * this.getLength();\n  var curveLengths = this.getCurveLengths();\n  var i = 0,\n      diff,\n      curve; // To think about boundaries points.\n\n  while (i < curveLengths.length) {\n    if (curveLengths[i] >= d) {\n      diff = curveLengths[i] - d;\n      curve = this.curves[i];\n      var u = 1 - diff / curve.getLength();\n      return curve.getPointAt(u);\n    }\n\n    i++;\n  }\n\n  return null; // loop where sum != 0, sum > d , sum+1 <d\n};\n/*\r\nTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n};*/\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n// getPoint() depends on getLength\n\n\nTHREE.CurvePath.prototype.getLength = function () {\n  var lens = this.getCurveLengths();\n  return lens[lens.length - 1];\n}; // Compute lengths and cache them\n// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\nTHREE.CurvePath.prototype.getCurveLengths = function () {\n  // We use cache values if curves and cache array are same length\n  if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n    return this.cacheLengths;\n  } // Get length of sub-curve\n  // Push sums into cached array\n\n\n  var lengths = [],\n      sums = 0;\n  var i,\n      il = this.curves.length;\n\n  for (i = 0; i < il; i++) {\n    sums += this.curves[i].getLength();\n    lengths.push(sums);\n  }\n\n  this.cacheLengths = lengths;\n  return lengths;\n}; // Returns min and max coordinates\n\n\nTHREE.CurvePath.prototype.getBoundingBox = function () {\n  var points = this.getPoints();\n  var maxX, maxY, maxZ;\n  var minX, minY, minZ;\n  maxX = maxY = Number.NEGATIVE_INFINITY;\n  minX = minY = Number.POSITIVE_INFINITY;\n  var p, i, il, sum;\n  var v3 = points[0] instanceof THREE.Vector3;\n  sum = v3 ? new THREE.Vector3() : new THREE.Vector2();\n\n  for (i = 0, il = points.length; i < il; i++) {\n    p = points[i];\n    if (p.x > maxX) maxX = p.x;else if (p.x < minX) minX = p.x;\n    if (p.y > maxY) maxY = p.y;else if (p.y < minY) minY = p.y;\n\n    if (v3) {\n      if (p.z > maxZ) maxZ = p.z;else if (p.z < minZ) minZ = p.z;\n    }\n\n    sum.add(p);\n  }\n\n  var ret = {\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY\n  };\n\n  if (v3) {\n    ret.maxZ = maxZ;\n    ret.minZ = minZ;\n  }\n\n  return ret;\n};\n/**************************************************************\r\n *\tCreate Geometries Helpers\r\n **************************************************************/\n/// Generate geometry from path points (for Line or Points objects)\n\n\nTHREE.CurvePath.prototype.createPointsGeometry = function (divisions) {\n  var pts = this.getPoints(divisions, true);\n  return this.createGeometry(pts);\n}; // Generate geometry from equidistant sampling along the path\n\n\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function (divisions) {\n  var pts = this.getSpacedPoints(divisions, true);\n  return this.createGeometry(pts);\n};\n\nTHREE.CurvePath.prototype.createGeometry = function (points) {\n  var geometry = new THREE.Geometry();\n\n  for (var i = 0; i < points.length; i++) {\n    geometry.vertices.push(new THREE.Vector3(points[i].x, points[i].y, points[i].z || 0));\n  }\n\n  return geometry;\n};\n/**************************************************************\r\n *\tBend / Wrap Helper Methods\r\n **************************************************************/\n// Wrap path / Bend modifiers?\n\n\nTHREE.CurvePath.prototype.addWrapPath = function (bendpath) {\n  this.bends.push(bendpath);\n};\n\nTHREE.CurvePath.prototype.getTransformedPoints = function (segments, bends) {\n  var oldPts = this.getPoints(segments); // getPoints getSpacedPoints\n\n  var i, il;\n\n  if (!bends) {\n    bends = this.bends;\n  }\n\n  for (i = 0, il = bends.length; i < il; i++) {\n    oldPts = this.getWrapPoints(oldPts, bends[i]);\n  }\n\n  return oldPts;\n};\n\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function (segments, bends) {\n  var oldPts = this.getSpacedPoints(segments);\n  var i, il;\n\n  if (!bends) {\n    bends = this.bends;\n  }\n\n  for (i = 0, il = bends.length; i < il; i++) {\n    oldPts = this.getWrapPoints(oldPts, bends[i]);\n  }\n\n  return oldPts;\n}; // This returns getPoints() bend/wrapped around the contour of a path.\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\n\n\nTHREE.CurvePath.prototype.getWrapPoints = function (oldPts, path) {\n  var bounds = this.getBoundingBox();\n  var i, il, p, oldX, oldY, xNorm;\n\n  for (i = 0, il = oldPts.length; i < il; i++) {\n    p = oldPts[i];\n    oldX = p.x;\n    oldY = p.y;\n    xNorm = oldX / bounds.maxX; // If using actual distance, for length > path, requires line extrusions\n    //xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\n\n    xNorm = path.getUtoTmapping(xNorm, oldX); // check for out of bounds?\n\n    var pathPt = path.getPoint(xNorm);\n    var normal = path.getTangent(xNorm);\n    normal.set(-normal.y, normal.x).multiplyScalar(oldY);\n    p.x = pathPt.x + normal.x;\n    p.y = pathPt.y + normal.y;\n  }\n\n  return oldPts;\n}; // File:src/extras/core/Path.js\n\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\n\n\nTHREE.Path = function (points) {\n  THREE.CurvePath.call(this);\n  this.actions = [];\n\n  if (points) {\n    this.fromPoints(points);\n  }\n};\n\nTHREE.Path.prototype = Object.create(THREE.CurvePath.prototype);\nTHREE.Path.prototype.constructor = THREE.Path;\nTHREE.PathActions = {\n  MOVE_TO: 'moveTo',\n  LINE_TO: 'lineTo',\n  QUADRATIC_CURVE_TO: 'quadraticCurveTo',\n  // Bezier quadratic curve\n  BEZIER_CURVE_TO: 'bezierCurveTo',\n  // Bezier cubic curve\n  CSPLINE_THRU: 'splineThru',\n  // Catmull-Rom spline\n  ARC: 'arc',\n  // Circle\n  ELLIPSE: 'ellipse'\n}; // TODO Clean up PATH API\n// Create path using straight lines to connect all points\n// - vectors: array of Vector2\n\nTHREE.Path.prototype.fromPoints = function (vectors) {\n  this.moveTo(vectors[0].x, vectors[0].y);\n\n  for (var v = 1, vlen = vectors.length; v < vlen; v++) {\n    this.lineTo(vectors[v].x, vectors[v].y);\n  }\n}; // startPath() endPath()?\n\n\nTHREE.Path.prototype.moveTo = function (x, y) {\n  var args = Array.prototype.slice.call(arguments);\n  this.actions.push({\n    action: THREE.PathActions.MOVE_TO,\n    args: args\n  });\n};\n\nTHREE.Path.prototype.lineTo = function (x, y) {\n  var args = Array.prototype.slice.call(arguments);\n  var lastargs = this.actions[this.actions.length - 1].args;\n  var x0 = lastargs[lastargs.length - 2];\n  var y0 = lastargs[lastargs.length - 1];\n  var curve = new THREE.LineCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(x, y));\n  this.curves.push(curve);\n  this.actions.push({\n    action: THREE.PathActions.LINE_TO,\n    args: args\n  });\n};\n\nTHREE.Path.prototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {\n  var args = Array.prototype.slice.call(arguments);\n  var lastargs = this.actions[this.actions.length - 1].args;\n  var x0 = lastargs[lastargs.length - 2];\n  var y0 = lastargs[lastargs.length - 1];\n  var curve = new THREE.QuadraticBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));\n  this.curves.push(curve);\n  this.actions.push({\n    action: THREE.PathActions.QUADRATIC_CURVE_TO,\n    args: args\n  });\n};\n\nTHREE.Path.prototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n  var args = Array.prototype.slice.call(arguments);\n  var lastargs = this.actions[this.actions.length - 1].args;\n  var x0 = lastargs[lastargs.length - 2];\n  var y0 = lastargs[lastargs.length - 1];\n  var curve = new THREE.CubicBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));\n  this.curves.push(curve);\n  this.actions.push({\n    action: THREE.PathActions.BEZIER_CURVE_TO,\n    args: args\n  });\n};\n\nTHREE.Path.prototype.splineThru = function (pts\n/*Array of Vector*/\n) {\n  var args = Array.prototype.slice.call(arguments);\n  var lastargs = this.actions[this.actions.length - 1].args;\n  var x0 = lastargs[lastargs.length - 2];\n  var y0 = lastargs[lastargs.length - 1]; //---\n\n  var npts = [new THREE.Vector2(x0, y0)];\n  Array.prototype.push.apply(npts, pts);\n  var curve = new THREE.SplineCurve(npts);\n  this.curves.push(curve);\n  this.actions.push({\n    action: THREE.PathActions.CSPLINE_THRU,\n    args: args\n  });\n}; // FUTURE: Change the API or follow canvas API?\n\n\nTHREE.Path.prototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n  var lastargs = this.actions[this.actions.length - 1].args;\n  var x0 = lastargs[lastargs.length - 2];\n  var y0 = lastargs[lastargs.length - 1];\n  this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n};\n\nTHREE.Path.prototype.absarc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n  this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n};\n\nTHREE.Path.prototype.ellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n  var lastargs = this.actions[this.actions.length - 1].args;\n  var x0 = lastargs[lastargs.length - 2];\n  var y0 = lastargs[lastargs.length - 1];\n  this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n};\n\nTHREE.Path.prototype.absellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n  var args = [aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation || 0 // aRotation is optional.\n  ];\n  var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n  this.curves.push(curve);\n  var lastPoint = curve.getPoint(1);\n  args.push(lastPoint.x);\n  args.push(lastPoint.y);\n  this.actions.push({\n    action: THREE.PathActions.ELLIPSE,\n    args: args\n  });\n};\n\nTHREE.Path.prototype.getSpacedPoints = function (divisions, closedPath) {\n  if (!divisions) divisions = 40;\n  var points = [];\n\n  for (var i = 0; i < divisions; i++) {\n    points.push(this.getPoint(i / divisions)); //if( !this.getPoint( i / divisions ) ) throw \"DIE\";\n  } // if ( closedPath ) {\n  //\n  // \tpoints.push( points[ 0 ] );\n  //\n  // }\n\n\n  return points;\n};\n/* Return an array of vectors based on contour of the path */\n\n\nTHREE.Path.prototype.getPoints = function (divisions, closedPath) {\n  if (this.useSpacedPoints) {\n    return this.getSpacedPoints(divisions, closedPath);\n  }\n\n  divisions = divisions || 12;\n  var points = [];\n  var i, il, item, action, args;\n  var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0, laste, j, t, tx, ty;\n\n  for (i = 0, il = this.actions.length; i < il; i++) {\n    item = this.actions[i];\n    action = item.action;\n    args = item.args;\n\n    switch (action) {\n      case THREE.PathActions.MOVE_TO:\n        points.push(new THREE.Vector2(args[0], args[1]));\n        break;\n\n      case THREE.PathActions.LINE_TO:\n        points.push(new THREE.Vector2(args[0], args[1]));\n        break;\n\n      case THREE.PathActions.QUADRATIC_CURVE_TO:\n        cpx = args[2];\n        cpy = args[3];\n        cpx1 = args[0];\n        cpy1 = args[1];\n\n        if (points.length > 0) {\n          laste = points[points.length - 1];\n          cpx0 = laste.x;\n          cpy0 = laste.y;\n        } else {\n          laste = this.actions[i - 1].args;\n          cpx0 = laste[laste.length - 2];\n          cpy0 = laste[laste.length - 1];\n        }\n\n        for (j = 1; j <= divisions; j++) {\n          t = j / divisions;\n          tx = THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);\n          ty = THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);\n          points.push(new THREE.Vector2(tx, ty));\n        }\n\n        break;\n\n      case THREE.PathActions.BEZIER_CURVE_TO:\n        cpx = args[4];\n        cpy = args[5];\n        cpx1 = args[0];\n        cpy1 = args[1];\n        cpx2 = args[2];\n        cpy2 = args[3];\n\n        if (points.length > 0) {\n          laste = points[points.length - 1];\n          cpx0 = laste.x;\n          cpy0 = laste.y;\n        } else {\n          laste = this.actions[i - 1].args;\n          cpx0 = laste[laste.length - 2];\n          cpy0 = laste[laste.length - 1];\n        }\n\n        for (j = 1; j <= divisions; j++) {\n          t = j / divisions;\n          tx = THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);\n          ty = THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);\n          points.push(new THREE.Vector2(tx, ty));\n        }\n\n        break;\n\n      case THREE.PathActions.CSPLINE_THRU:\n        laste = this.actions[i - 1].args;\n        var last = new THREE.Vector2(laste[laste.length - 2], laste[laste.length - 1]);\n        var spts = [last];\n        var n = divisions * args[0].length;\n        spts = spts.concat(args[0]);\n        var spline = new THREE.SplineCurve(spts);\n\n        for (j = 1; j <= n; j++) {\n          points.push(spline.getPointAt(j / n));\n        }\n\n        break;\n\n      case THREE.PathActions.ARC:\n        var aX = args[0],\n            aY = args[1],\n            aRadius = args[2],\n            aStartAngle = args[3],\n            aEndAngle = args[4],\n            aClockwise = !!args[5];\n        var deltaAngle = aEndAngle - aStartAngle;\n        var angle;\n        var tdivisions = divisions * 2;\n\n        for (j = 1; j <= tdivisions; j++) {\n          t = j / tdivisions;\n\n          if (!aClockwise) {\n            t = 1 - t;\n          }\n\n          angle = aStartAngle + t * deltaAngle;\n          tx = aX + aRadius * Math.cos(angle);\n          ty = aY + aRadius * Math.sin(angle); //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n          points.push(new THREE.Vector2(tx, ty));\n        } //console.log(points);\n\n\n        break;\n\n      case THREE.PathActions.ELLIPSE:\n        var aX = args[0],\n            aY = args[1],\n            xRadius = args[2],\n            yRadius = args[3],\n            aStartAngle = args[4],\n            aEndAngle = args[5],\n            aClockwise = !!args[6],\n            aRotation = args[7];\n        var deltaAngle = aEndAngle - aStartAngle;\n        var angle;\n        var tdivisions = divisions * 2;\n        var cos, sin;\n\n        if (aRotation !== 0) {\n          cos = Math.cos(aRotation);\n          sin = Math.sin(aRotation);\n        }\n\n        for (j = 1; j <= tdivisions; j++) {\n          t = j / tdivisions;\n\n          if (!aClockwise) {\n            t = 1 - t;\n          }\n\n          angle = aStartAngle + t * deltaAngle;\n          tx = aX + xRadius * Math.cos(angle);\n          ty = aY + yRadius * Math.sin(angle);\n\n          if (aRotation !== 0) {\n            var x = tx,\n                y = ty; // Rotate the point about the center of the ellipse.\n\n            tx = (x - aX) * cos - (y - aY) * sin + aX;\n            ty = (x - aX) * sin + (y - aY) * cos + aY;\n          } //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\n          points.push(new THREE.Vector2(tx, ty));\n        } //console.log(points);\n\n\n        break;\n    } // end switch\n\n  } // Normalize to remove the closing point by default.\n\n\n  var lastPoint = points[points.length - 1];\n  var EPSILON = 0.0000000001;\n  if (Math.abs(lastPoint.x - points[0].x) < EPSILON && Math.abs(lastPoint.y - points[0].y) < EPSILON) points.splice(points.length - 1, 1);\n\n  if (closedPath) {\n    points.push(points[0]);\n  }\n\n  return points;\n}; //\n// Breaks path into shapes\n//\n//\tAssumptions (if parameter isCCW==true the opposite holds):\n//\t- solid shapes are defined clockwise (CW)\n//\t- holes are defined counterclockwise (CCW)\n//\n//\tIf parameter noHoles==true:\n//  - all subPaths are regarded as solid shapes\n//  - definition order CW/CCW has no relevance\n//\n\n\nTHREE.Path.prototype.toShapes = function (isCCW, noHoles) {\n  function extractSubpaths(inActions) {\n    var i, il, item, action, args;\n    var subPaths = [],\n        lastPath = new THREE.Path();\n\n    for (i = 0, il = inActions.length; i < il; i++) {\n      item = inActions[i];\n      args = item.args;\n      action = item.action;\n\n      if (action === THREE.PathActions.MOVE_TO) {\n        if (lastPath.actions.length !== 0) {\n          subPaths.push(lastPath);\n          lastPath = new THREE.Path();\n        }\n      }\n\n      lastPath[action].apply(lastPath, args);\n    }\n\n    if (lastPath.actions.length !== 0) {\n      subPaths.push(lastPath);\n    } // console.log(subPaths);\n\n\n    return subPaths;\n  }\n\n  function toShapesNoHoles(inSubpaths) {\n    var shapes = [];\n\n    for (var i = 0, il = inSubpaths.length; i < il; i++) {\n      var tmpPath = inSubpaths[i];\n      var tmpShape = new THREE.Shape();\n      tmpShape.actions = tmpPath.actions;\n      tmpShape.curves = tmpPath.curves;\n      shapes.push(tmpShape);\n    } //console.log(\"shape\", shapes);\n\n\n    return shapes;\n  }\n\n  function isPointInsidePolygon(inPt, inPolygon) {\n    var EPSILON = 0.0000000001;\n    var polyLen = inPolygon.length; // inPt on polygon contour => immediate success    or\n    // toggling of inside/outside at every single! intersection point of an edge\n    //  with the horizontal line through inPt, left of inPt\n    //  not counting lowerY endpoints of edges and whole edges on that line\n\n    var inside = false;\n\n    for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {\n      var edgeLowPt = inPolygon[p];\n      var edgeHighPt = inPolygon[q];\n      var edgeDx = edgeHighPt.x - edgeLowPt.x;\n      var edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n      if (Math.abs(edgeDy) > EPSILON) {\n        // not parallel\n        if (edgeDy < 0) {\n          edgeLowPt = inPolygon[q];\n          edgeDx = -edgeDx;\n          edgeHighPt = inPolygon[p];\n          edgeDy = -edgeDy;\n        }\n\n        if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;\n\n        if (inPt.y === edgeLowPt.y) {\n          if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?\n          // continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n        } else {\n          var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\n          if (perpEdge === 0) return true; // inPt is on contour ?\n\n          if (perpEdge < 0) continue;\n          inside = !inside; // true intersection left of inPt\n        }\n      } else {\n        // parallel or collinear\n        if (inPt.y !== edgeLowPt.y) continue; // parallel\n        // edge lies on the same horizontal line as inPt\n\n        if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !\n        // continue;\n      }\n    }\n\n    return inside;\n  }\n\n  var subPaths = extractSubpaths(this.actions);\n  if (subPaths.length === 0) return [];\n  if (noHoles === true) return toShapesNoHoles(subPaths);\n  var solid,\n      tmpPath,\n      tmpShape,\n      shapes = [];\n\n  if (subPaths.length === 1) {\n    tmpPath = subPaths[0];\n    tmpShape = new THREE.Shape();\n    tmpShape.actions = tmpPath.actions;\n    tmpShape.curves = tmpPath.curves;\n    shapes.push(tmpShape);\n    return shapes;\n  }\n\n  var holesFirst = !THREE.Shape.Utils.isClockWise(subPaths[0].getPoints());\n  holesFirst = isCCW ? !holesFirst : holesFirst; // console.log(\"Holes first\", holesFirst);\n\n  var betterShapeHoles = [];\n  var newShapes = [];\n  var newShapeHoles = [];\n  var mainIdx = 0;\n  var tmpPoints;\n  newShapes[mainIdx] = undefined;\n  newShapeHoles[mainIdx] = [];\n  var i, il;\n\n  for (i = 0, il = subPaths.length; i < il; i++) {\n    tmpPath = subPaths[i];\n    tmpPoints = tmpPath.getPoints();\n    solid = THREE.Shape.Utils.isClockWise(tmpPoints);\n    solid = isCCW ? !solid : solid;\n\n    if (solid) {\n      if (!holesFirst && newShapes[mainIdx]) mainIdx++;\n      newShapes[mainIdx] = {\n        s: new THREE.Shape(),\n        p: tmpPoints\n      };\n      newShapes[mainIdx].s.actions = tmpPath.actions;\n      newShapes[mainIdx].s.curves = tmpPath.curves;\n      if (holesFirst) mainIdx++;\n      newShapeHoles[mainIdx] = []; //console.log('cw', i);\n    } else {\n      newShapeHoles[mainIdx].push({\n        h: tmpPath,\n        p: tmpPoints[0]\n      }); //console.log('ccw', i);\n    }\n  } // only Holes? -> probably all Shapes with wrong orientation\n\n\n  if (!newShapes[0]) return toShapesNoHoles(subPaths);\n\n  if (newShapes.length > 1) {\n    var ambiguous = false;\n    var toChange = [];\n\n    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n      betterShapeHoles[sIdx] = [];\n    }\n\n    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n      var sho = newShapeHoles[sIdx];\n\n      for (var hIdx = 0; hIdx < sho.length; hIdx++) {\n        var ho = sho[hIdx];\n        var hole_unassigned = true;\n\n        for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {\n          if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {\n            if (sIdx !== s2Idx) toChange.push({\n              froms: sIdx,\n              tos: s2Idx,\n              hole: hIdx\n            });\n\n            if (hole_unassigned) {\n              hole_unassigned = false;\n              betterShapeHoles[s2Idx].push(ho);\n            } else {\n              ambiguous = true;\n            }\n          }\n        }\n\n        if (hole_unassigned) {\n          betterShapeHoles[sIdx].push(ho);\n        }\n      }\n    } // console.log(\"ambiguous: \", ambiguous);\n\n\n    if (toChange.length > 0) {\n      // console.log(\"to change: \", toChange);\n      if (!ambiguous) newShapeHoles = betterShapeHoles;\n    }\n  }\n\n  var tmpHoles, j, jl;\n\n  for (i = 0, il = newShapes.length; i < il; i++) {\n    tmpShape = newShapes[i].s;\n    shapes.push(tmpShape);\n    tmpHoles = newShapeHoles[i];\n\n    for (j = 0, jl = tmpHoles.length; j < jl; j++) {\n      tmpShape.holes.push(tmpHoles[j].h);\n    }\n  } //console.log(\"shape\", shapes);\n\n\n  return shapes;\n}; // File:src/extras/core/Shape.js\n\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\n\nTHREE.Shape = function () {\n  THREE.Path.apply(this, arguments);\n  this.holes = [];\n};\n\nTHREE.Shape.prototype = Object.create(THREE.Path.prototype);\nTHREE.Shape.prototype.constructor = THREE.Shape; // Convenience method to return ExtrudeGeometry\n\nTHREE.Shape.prototype.extrude = function (options) {\n  var extruded = new THREE.ExtrudeGeometry(this, options);\n  return extruded;\n}; // Convenience method to return ShapeGeometry\n\n\nTHREE.Shape.prototype.makeGeometry = function (options) {\n  var geometry = new THREE.ShapeGeometry(this, options);\n  return geometry;\n}; // Get points of holes\n\n\nTHREE.Shape.prototype.getPointsHoles = function (divisions) {\n  var i,\n      il = this.holes.length,\n      holesPts = [];\n\n  for (i = 0; i < il; i++) {\n    holesPts[i] = this.holes[i].getTransformedPoints(divisions, this.bends);\n  }\n\n  return holesPts;\n}; // Get points of holes (spaced by regular distance)\n\n\nTHREE.Shape.prototype.getSpacedPointsHoles = function (divisions) {\n  var i,\n      il = this.holes.length,\n      holesPts = [];\n\n  for (i = 0; i < il; i++) {\n    holesPts[i] = this.holes[i].getTransformedSpacedPoints(divisions, this.bends);\n  }\n\n  return holesPts;\n}; // Get points of shape and holes (keypoints based on segments parameter)\n\n\nTHREE.Shape.prototype.extractAllPoints = function (divisions) {\n  return {\n    shape: this.getTransformedPoints(divisions),\n    holes: this.getPointsHoles(divisions)\n  };\n};\n\nTHREE.Shape.prototype.extractPoints = function (divisions) {\n  if (this.useSpacedPoints) {\n    return this.extractAllSpacedPoints(divisions);\n  }\n\n  return this.extractAllPoints(divisions);\n}; //\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\n//\n// \treturn {\n//\n// \t\tshape: this.transform( bend, divisions ),\n// \t\tholes: this.getPointsHoles( divisions, bend )\n//\n// \t};\n//\n// };\n// Get points of shape and holes (spaced by regular distance)\n\n\nTHREE.Shape.prototype.extractAllSpacedPoints = function (divisions) {\n  return {\n    shape: this.getTransformedSpacedPoints(divisions),\n    holes: this.getSpacedPointsHoles(divisions)\n  };\n};\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\n\n\nTHREE.Shape.Utils = {\n  triangulateShape: function triangulateShape(contour, holes) {\n    function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {\n      // inOtherPt needs to be collinear to the inSegment\n      if (inSegPt1.x !== inSegPt2.x) {\n        if (inSegPt1.x < inSegPt2.x) {\n          return inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x;\n        } else {\n          return inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x;\n        }\n      } else {\n        if (inSegPt1.y < inSegPt2.y) {\n          return inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y;\n        } else {\n          return inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y;\n        }\n      }\n    }\n\n    function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {\n      var EPSILON = 0.0000000001;\n      var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,\n          seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n      var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,\n          seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n      var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n      var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n      var limit = seg1dy * seg2dx - seg1dx * seg2dy;\n      var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n      if (Math.abs(limit) > EPSILON) {\n        // not parallel\n        var perpSeg2;\n\n        if (limit > 0) {\n          if (perpSeg1 < 0 || perpSeg1 > limit) return [];\n          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n          if (perpSeg2 < 0 || perpSeg2 > limit) return [];\n        } else {\n          if (perpSeg1 > 0 || perpSeg1 < limit) return [];\n          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n          if (perpSeg2 > 0 || perpSeg2 < limit) return [];\n        } // i.e. to reduce rounding errors\n        // intersection at endpoint of segment#1?\n\n\n        if (perpSeg2 === 0) {\n          if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit)) return [];\n          return [inSeg1Pt1];\n        }\n\n        if (perpSeg2 === limit) {\n          if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit)) return [];\n          return [inSeg1Pt2];\n        } // intersection at endpoint of segment#2?\n\n\n        if (perpSeg1 === 0) return [inSeg2Pt1];\n        if (perpSeg1 === limit) return [inSeg2Pt2]; // return real intersection point\n\n        var factorSeg1 = perpSeg2 / limit;\n        return [{\n          x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n          y: inSeg1Pt1.y + factorSeg1 * seg1dy\n        }];\n      } else {\n        // parallel or collinear\n        if (perpSeg1 !== 0 || seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy) return []; // they are collinear or degenerate\n\n        var seg1Pt = seg1dx === 0 && seg1dy === 0; // segment1 is just a point?\n\n        var seg2Pt = seg2dx === 0 && seg2dy === 0; // segment2 is just a point?\n        // both segments are points\n\n        if (seg1Pt && seg2Pt) {\n          if (inSeg1Pt1.x !== inSeg2Pt1.x || inSeg1Pt1.y !== inSeg2Pt1.y) return []; // they are distinct  points\n\n          return [inSeg1Pt1]; // they are the same point\n        } // segment#1  is a single point\n\n\n        if (seg1Pt) {\n          if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1)) return []; // but not in segment#2\n\n          return [inSeg1Pt1];\n        } // segment#2  is a single point\n\n\n        if (seg2Pt) {\n          if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1)) return []; // but not in segment#1\n\n          return [inSeg2Pt1];\n        } // they are collinear segments, which might overlap\n\n\n        var seg1min, seg1max, seg1minVal, seg1maxVal;\n        var seg2min, seg2max, seg2minVal, seg2maxVal;\n\n        if (seg1dx !== 0) {\n          // the segments are NOT on a vertical line\n          if (inSeg1Pt1.x < inSeg1Pt2.x) {\n            seg1min = inSeg1Pt1;\n            seg1minVal = inSeg1Pt1.x;\n            seg1max = inSeg1Pt2;\n            seg1maxVal = inSeg1Pt2.x;\n          } else {\n            seg1min = inSeg1Pt2;\n            seg1minVal = inSeg1Pt2.x;\n            seg1max = inSeg1Pt1;\n            seg1maxVal = inSeg1Pt1.x;\n          }\n\n          if (inSeg2Pt1.x < inSeg2Pt2.x) {\n            seg2min = inSeg2Pt1;\n            seg2minVal = inSeg2Pt1.x;\n            seg2max = inSeg2Pt2;\n            seg2maxVal = inSeg2Pt2.x;\n          } else {\n            seg2min = inSeg2Pt2;\n            seg2minVal = inSeg2Pt2.x;\n            seg2max = inSeg2Pt1;\n            seg2maxVal = inSeg2Pt1.x;\n          }\n        } else {\n          // the segments are on a vertical line\n          if (inSeg1Pt1.y < inSeg1Pt2.y) {\n            seg1min = inSeg1Pt1;\n            seg1minVal = inSeg1Pt1.y;\n            seg1max = inSeg1Pt2;\n            seg1maxVal = inSeg1Pt2.y;\n          } else {\n            seg1min = inSeg1Pt2;\n            seg1minVal = inSeg1Pt2.y;\n            seg1max = inSeg1Pt1;\n            seg1maxVal = inSeg1Pt1.y;\n          }\n\n          if (inSeg2Pt1.y < inSeg2Pt2.y) {\n            seg2min = inSeg2Pt1;\n            seg2minVal = inSeg2Pt1.y;\n            seg2max = inSeg2Pt2;\n            seg2maxVal = inSeg2Pt2.y;\n          } else {\n            seg2min = inSeg2Pt2;\n            seg2minVal = inSeg2Pt2.y;\n            seg2max = inSeg2Pt1;\n            seg2maxVal = inSeg2Pt1.y;\n          }\n        }\n\n        if (seg1minVal <= seg2minVal) {\n          if (seg1maxVal < seg2minVal) return [];\n\n          if (seg1maxVal === seg2minVal) {\n            if (inExcludeAdjacentSegs) return [];\n            return [seg2min];\n          }\n\n          if (seg1maxVal <= seg2maxVal) return [seg2min, seg1max];\n          return [seg2min, seg2max];\n        } else {\n          if (seg1minVal > seg2maxVal) return [];\n\n          if (seg1minVal === seg2maxVal) {\n            if (inExcludeAdjacentSegs) return [];\n            return [seg1min];\n          }\n\n          if (seg1maxVal <= seg2maxVal) return [seg1min, seg1max];\n          return [seg1min, seg2max];\n        }\n      }\n    }\n\n    function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {\n      // The order of legs is important\n      var EPSILON = 0.0000000001; // translation of all points, so that Vertex is at (0,0)\n\n      var legFromPtX = inLegFromPt.x - inVertex.x,\n          legFromPtY = inLegFromPt.y - inVertex.y;\n      var legToPtX = inLegToPt.x - inVertex.x,\n          legToPtY = inLegToPt.y - inVertex.y;\n      var otherPtX = inOtherPt.x - inVertex.x,\n          otherPtY = inOtherPt.y - inVertex.y; // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\n      var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;\n      var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n      if (Math.abs(from2toAngle) > EPSILON) {\n        // angle != 180 deg.\n        var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX; // console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n        if (from2toAngle > 0) {\n          // main angle < 180 deg.\n          return from2otherAngle >= 0 && other2toAngle >= 0;\n        } else {\n          // main angle > 180 deg.\n          return from2otherAngle >= 0 || other2toAngle >= 0;\n        }\n      } else {\n        // angle == 180 deg.\n        // console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n        return from2otherAngle > 0;\n      }\n    }\n\n    function removeHoles(contour, holes) {\n      var shape = contour.concat(); // work on this shape\n\n      var hole;\n\n      function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {\n        // Check if hole point lies within angle around shape point\n        var lastShapeIdx = shape.length - 1;\n        var prevShapeIdx = inShapeIdx - 1;\n        if (prevShapeIdx < 0) prevShapeIdx = lastShapeIdx;\n        var nextShapeIdx = inShapeIdx + 1;\n        if (nextShapeIdx > lastShapeIdx) nextShapeIdx = 0;\n        var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);\n\n        if (!insideAngle) {\n          // console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n          return false;\n        } // Check if shape point lies within angle around hole point\n\n\n        var lastHoleIdx = hole.length - 1;\n        var prevHoleIdx = inHoleIdx - 1;\n        if (prevHoleIdx < 0) prevHoleIdx = lastHoleIdx;\n        var nextHoleIdx = inHoleIdx + 1;\n        if (nextHoleIdx > lastHoleIdx) nextHoleIdx = 0;\n        insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);\n\n        if (!insideAngle) {\n          // console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n          return false;\n        }\n\n        return true;\n      }\n\n      function intersectsShapeEdge(inShapePt, inHolePt) {\n        // checks for intersections with shape edges\n        var sIdx, nextIdx, intersection;\n\n        for (sIdx = 0; sIdx < shape.length; sIdx++) {\n          nextIdx = sIdx + 1;\n          nextIdx %= shape.length;\n          intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);\n          if (intersection.length > 0) return true;\n        }\n\n        return false;\n      }\n\n      var indepHoles = [];\n\n      function intersectsHoleEdge(inShapePt, inHolePt) {\n        // checks for intersections with hole edges\n        var ihIdx, chkHole, hIdx, nextIdx, intersection;\n\n        for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {\n          chkHole = holes[indepHoles[ihIdx]];\n\n          for (hIdx = 0; hIdx < chkHole.length; hIdx++) {\n            nextIdx = hIdx + 1;\n            nextIdx %= chkHole.length;\n            intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);\n            if (intersection.length > 0) return true;\n          }\n        }\n\n        return false;\n      }\n\n      var holeIndex,\n          shapeIndex,\n          shapePt,\n          holePt,\n          holeIdx,\n          cutKey,\n          failedCuts = [],\n          tmpShape1,\n          tmpShape2,\n          tmpHole1,\n          tmpHole2;\n\n      for (var h = 0, hl = holes.length; h < hl; h++) {\n        indepHoles.push(h);\n      }\n\n      var minShapeIndex = 0;\n      var counter = indepHoles.length * 2;\n\n      while (indepHoles.length > 0) {\n        counter--;\n\n        if (counter < 0) {\n          console.log(\"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\");\n          break;\n        } // search for shape-vertex and hole-vertex,\n        // which can be connected without intersections\n\n\n        for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {\n          shapePt = shape[shapeIndex];\n          holeIndex = -1; // search for hole which can be reached without intersections\n\n          for (var h = 0; h < indepHoles.length; h++) {\n            holeIdx = indepHoles[h]; // prevent multiple checks\n\n            cutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n            if (failedCuts[cutKey] !== undefined) continue;\n            hole = holes[holeIdx];\n\n            for (var h2 = 0; h2 < hole.length; h2++) {\n              holePt = hole[h2];\n              if (!isCutLineInsideAngles(shapeIndex, h2)) continue;\n              if (intersectsShapeEdge(shapePt, holePt)) continue;\n              if (intersectsHoleEdge(shapePt, holePt)) continue;\n              holeIndex = h2;\n              indepHoles.splice(h, 1);\n              tmpShape1 = shape.slice(0, shapeIndex + 1);\n              tmpShape2 = shape.slice(shapeIndex);\n              tmpHole1 = hole.slice(holeIndex);\n              tmpHole2 = hole.slice(0, holeIndex + 1);\n              shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);\n              minShapeIndex = shapeIndex; // Debug only, to show the selected cuts\n              // glob_CutLines.push( [ shapePt, holePt ] );\n\n              break;\n            }\n\n            if (holeIndex >= 0) break; // hole-vertex found\n\n            failedCuts[cutKey] = true; // remember failure\n          }\n\n          if (holeIndex >= 0) break; // hole-vertex found\n        }\n      }\n\n      return shape;\n      /* shape with no holes */\n    }\n\n    var i,\n        il,\n        f,\n        face,\n        key,\n        index,\n        allPointsMap = {}; // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n    var allpoints = contour.concat();\n\n    for (var h = 0, hl = holes.length; h < hl; h++) {\n      Array.prototype.push.apply(allpoints, holes[h]);\n    } //console.log( \"allpoints\",allpoints, allpoints.length );\n    // prepare all points map\n\n\n    for (i = 0, il = allpoints.length; i < il; i++) {\n      key = allpoints[i].x + \":\" + allpoints[i].y;\n\n      if (allPointsMap[key] !== undefined) {\n        console.warn(\"THREE.Shape: Duplicate point\", key);\n      }\n\n      allPointsMap[key] = i;\n    } // remove holes by cutting paths to holes and adding them to the shape\n\n\n    var shapeWithoutHoles = removeHoles(contour, holes);\n    var triangles = THREE.FontUtils.Triangulate(shapeWithoutHoles, false); // True returns indices for points of spooled shape\n    //console.log( \"triangles\",triangles, triangles.length );\n    // check all face vertices against all points map\n\n    for (i = 0, il = triangles.length; i < il; i++) {\n      face = triangles[i];\n\n      for (f = 0; f < 3; f++) {\n        key = face[f].x + \":\" + face[f].y;\n        index = allPointsMap[key];\n\n        if (index !== undefined) {\n          face[f] = index;\n        }\n      }\n    }\n\n    return triangles.concat();\n  },\n  isClockWise: function isClockWise(pts) {\n    return THREE.FontUtils.Triangulate.area(pts) < 0;\n  },\n  // Bezier Curves formulas obtained from\n  // http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n  // Quad Bezier Functions\n  b2p0: function b2p0(t, p) {\n    var k = 1 - t;\n    return k * k * p;\n  },\n  b2p1: function b2p1(t, p) {\n    return 2 * (1 - t) * t * p;\n  },\n  b2p2: function b2p2(t, p) {\n    return t * t * p;\n  },\n  b2: function b2(t, p0, p1, p2) {\n    return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);\n  },\n  // Cubic Bezier Functions\n  b3p0: function b3p0(t, p) {\n    var k = 1 - t;\n    return k * k * k * p;\n  },\n  b3p1: function b3p1(t, p) {\n    var k = 1 - t;\n    return 3 * k * k * t * p;\n  },\n  b3p2: function b3p2(t, p) {\n    var k = 1 - t;\n    return 3 * k * t * t * p;\n  },\n  b3p3: function b3p3(t, p) {\n    return t * t * t * p;\n  },\n  b3: function b3(t, p0, p1, p2, p3) {\n    return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);\n  }\n}; // File:src/extras/curves/LineCurve.js\n\n/**************************************************************\r\n *\tLine\r\n **************************************************************/\n\nTHREE.LineCurve = function (v1, v2) {\n  this.v1 = v1;\n  this.v2 = v2;\n};\n\nTHREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\n\nTHREE.LineCurve.prototype.getPoint = function (t) {\n  var point = this.v2.clone().sub(this.v1);\n  point.multiplyScalar(t).add(this.v1);\n  return point;\n}; // Line curve is linear, so we can overwrite default getPointAt\n\n\nTHREE.LineCurve.prototype.getPointAt = function (u) {\n  return this.getPoint(u);\n};\n\nTHREE.LineCurve.prototype.getTangent = function (t) {\n  var tangent = this.v2.clone().sub(this.v1);\n  return tangent.normalize();\n}; // File:src/extras/curves/QuadraticBezierCurve.js\n\n/**************************************************************\r\n *\tQuadratic Bezier curve\r\n **************************************************************/\n\n\nTHREE.QuadraticBezierCurve = function (v0, v1, v2) {\n  this.v0 = v0;\n  this.v1 = v1;\n  this.v2 = v2;\n};\n\nTHREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\n\nTHREE.QuadraticBezierCurve.prototype.getPoint = function (t) {\n  var vector = new THREE.Vector2();\n  vector.x = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);\n  vector.y = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);\n  return vector;\n};\n\nTHREE.QuadraticBezierCurve.prototype.getTangent = function (t) {\n  var vector = new THREE.Vector2();\n  vector.x = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x);\n  vector.y = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y); // returns unit vector\n\n  return vector.normalize();\n}; // File:src/extras/curves/CubicBezierCurve.js\n\n/**************************************************************\r\n *\tCubic Bezier curve\r\n **************************************************************/\n\n\nTHREE.CubicBezierCurve = function (v0, v1, v2, v3) {\n  this.v0 = v0;\n  this.v1 = v1;\n  this.v2 = v2;\n  this.v3 = v3;\n};\n\nTHREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\n\nTHREE.CubicBezierCurve.prototype.getPoint = function (t) {\n  var tx, ty;\n  tx = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);\n  ty = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);\n  return new THREE.Vector2(tx, ty);\n};\n\nTHREE.CubicBezierCurve.prototype.getTangent = function (t) {\n  var tx, ty;\n  tx = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);\n  ty = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);\n  var tangent = new THREE.Vector2(tx, ty);\n  tangent.normalize();\n  return tangent;\n}; // File:src/extras/curves/SplineCurve.js\n\n/**************************************************************\r\n *\tSpline curve\r\n **************************************************************/\n\n\nTHREE.SplineCurve = function (points\n/* array of Vector2 */\n) {\n  this.points = points == undefined ? [] : points;\n};\n\nTHREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\n\nTHREE.SplineCurve.prototype.getPoint = function (t) {\n  var points = this.points;\n  var point = (points.length - 1) * t;\n  var intPoint = Math.floor(point);\n  var weight = point - intPoint;\n  var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n  var point1 = points[intPoint];\n  var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n  var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n  var vector = new THREE.Vector2();\n  vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);\n  vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);\n  return vector;\n}; // File:src/extras/curves/EllipseCurve.js\n\n/**************************************************************\r\n *\tEllipse curve\r\n **************************************************************/\n\n\nTHREE.EllipseCurve = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n  this.aX = aX;\n  this.aY = aY;\n  this.xRadius = xRadius;\n  this.yRadius = yRadius;\n  this.aStartAngle = aStartAngle;\n  this.aEndAngle = aEndAngle;\n  this.aClockwise = aClockwise;\n  this.aRotation = aRotation || 0;\n};\n\nTHREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\n\nTHREE.EllipseCurve.prototype.getPoint = function (t) {\n  var deltaAngle = this.aEndAngle - this.aStartAngle;\n  if (deltaAngle < 0) deltaAngle += Math.PI * 2;\n  if (deltaAngle > Math.PI * 2) deltaAngle -= Math.PI * 2;\n  var angle;\n\n  if (this.aClockwise === true) {\n    angle = this.aEndAngle + (1 - t) * (Math.PI * 2 - deltaAngle);\n  } else {\n    angle = this.aStartAngle + t * deltaAngle;\n  }\n\n  var x = this.aX + this.xRadius * Math.cos(angle);\n  var y = this.aY + this.yRadius * Math.sin(angle);\n\n  if (this.aRotation !== 0) {\n    var cos = Math.cos(this.aRotation);\n    var sin = Math.sin(this.aRotation);\n    var tx = x,\n        ty = y; // Rotate the point about the center of the ellipse.\n\n    x = (tx - this.aX) * cos - (ty - this.aY) * sin + this.aX;\n    y = (tx - this.aX) * sin + (ty - this.aY) * cos + this.aY;\n  }\n\n  return new THREE.Vector2(x, y);\n}; // File:src/extras/curves/ArcCurve.js\n\n/**************************************************************\r\n *\tArc curve\r\n **************************************************************/\n\n\nTHREE.ArcCurve = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n  THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n};\n\nTHREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve; // File:src/extras/curves/LineCurve3.js\n\n/**************************************************************\r\n *\tLine3D\r\n **************************************************************/\n\nTHREE.LineCurve3 = THREE.Curve.create(function (v1, v2) {\n  this.v1 = v1;\n  this.v2 = v2;\n}, function (t) {\n  var vector = new THREE.Vector3();\n  vector.subVectors(this.v2, this.v1); // diff\n\n  vector.multiplyScalar(t);\n  vector.add(this.v1);\n  return vector;\n}); // File:src/extras/curves/QuadraticBezierCurve3.js\n\n/**************************************************************\r\n *\tQuadratic Bezier 3D curve\r\n **************************************************************/\n\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(function (v0, v1, v2) {\n  this.v0 = v0;\n  this.v1 = v1;\n  this.v2 = v2;\n}, function (t) {\n  var vector = new THREE.Vector3();\n  vector.x = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);\n  vector.y = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);\n  vector.z = THREE.Shape.Utils.b2(t, this.v0.z, this.v1.z, this.v2.z);\n  return vector;\n}); // File:src/extras/curves/CubicBezierCurve3.js\n\n/**************************************************************\r\n *\tCubic Bezier 3D curve\r\n **************************************************************/\n\nTHREE.CubicBezierCurve3 = THREE.Curve.create(function (v0, v1, v2, v3) {\n  this.v0 = v0;\n  this.v1 = v1;\n  this.v2 = v2;\n  this.v3 = v3;\n}, function (t) {\n  var vector = new THREE.Vector3();\n  vector.x = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);\n  vector.y = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);\n  vector.z = THREE.Shape.Utils.b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z);\n  return vector;\n}); // File:src/extras/curves/SplineCurve3.js\n\n/**************************************************************\r\n *\tSpline 3D curve\r\n **************************************************************/\n\nTHREE.SplineCurve3 = THREE.Curve.create(function (points\n/* array of Vector3 */\n) {\n  console.warn('THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3');\n  this.points = points == undefined ? [] : points;\n}, function (t) {\n  var points = this.points;\n  var point = (points.length - 1) * t;\n  var intPoint = Math.floor(point);\n  var weight = point - intPoint;\n  var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];\n  var point1 = points[intPoint];\n  var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n  var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n  var vector = new THREE.Vector3();\n  vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);\n  vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);\n  vector.z = THREE.Curve.Utils.interpolate(point0.z, point1.z, point2.z, point3.z, weight);\n  return vector;\n}); // File:src/extras/curves/CatmullRomCurve3.js\n\n/**\r\n * @author zz85 https://github.com/zz85\r\n *\r\n * Centripetal CatmullRom Curve - which is useful for avoiding\r\n * cusps and self-intersections in non-uniform catmull rom curves.\r\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n *\r\n * curve.type accepts centripetal(default), chordal and catmullrom\r\n * curve.tension is used for catmullrom which defaults to 0.5\r\n */\n\nTHREE.CatmullRomCurve3 = function () {\n  var tmp = new THREE.Vector3(),\n      px = new CubicPoly(),\n      py = new CubicPoly(),\n      pz = new CubicPoly();\n  /*\r\n  Based on an optimized c++ solution in\r\n   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n   - http://ideone.com/NoEbVM\r\n  \n  This CubicPoly class could be used for reusing some variables and calculations,\r\n  but for three.js curve use, it could be possible inlined and flatten into a single function call\r\n  which can be placed in CurveUtils.\r\n  */\n\n  function CubicPoly() {}\n  /*\r\n   * Compute coefficients for a cubic polynomial\r\n   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n   * such that\r\n   *   p(0) = x0, p(1) = x1\r\n   *  and\r\n   *   p'(0) = t0, p'(1) = t1.\r\n   */\n\n\n  CubicPoly.prototype.init = function (x0, x1, t0, t1) {\n    this.c0 = x0;\n    this.c1 = t0;\n    this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\n    this.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n  };\n\n  CubicPoly.prototype.initNonuniformCatmullRom = function (x0, x1, x2, x3, dt0, dt1, dt2) {\n    // compute tangents when parameterized in [t1,t2]\n    var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\n    var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]\n\n    t1 *= dt1;\n    t2 *= dt1; // initCubicPoly\n\n    this.init(x1, x2, t1, t2);\n  }; // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\n\n  CubicPoly.prototype.initCatmullRom = function (x0, x1, x2, x3, tension) {\n    this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\n  };\n\n  CubicPoly.prototype.calc = function (t) {\n    var t2 = t * t;\n    var t3 = t2 * t;\n    return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n  }; // Subclass Three.js curve\n\n\n  return THREE.Curve.create(function (p\n  /* array of Vector3 */\n  ) {\n    this.points = p || [];\n  }, function (t) {\n    var points = this.points,\n        point,\n        intPoint,\n        weight,\n        l;\n    l = points.length;\n    if (l < 2) console.log('duh, you need at least 2 points');\n    point = (l - 1) * t;\n    intPoint = Math.floor(point);\n    weight = point - intPoint;\n\n    if (weight === 0 && intPoint === l - 1) {\n      intPoint = l - 2;\n      weight = 1;\n    }\n\n    var p0, p1, p2, p3;\n\n    if (intPoint === 0) {\n      // extrapolate first point\n      tmp.subVectors(points[0], points[1]).add(points[0]);\n      p0 = tmp;\n    } else {\n      p0 = points[intPoint - 1];\n    }\n\n    p1 = points[intPoint];\n    p2 = points[intPoint + 1];\n\n    if (intPoint + 2 < l) {\n      p3 = points[intPoint + 2];\n    } else {\n      // extrapolate last point\n      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 2]);\n      p3 = tmp;\n    }\n\n    if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {\n      // init Centripetal / Chordal Catmull-Rom\n      var pow = this.type === 'chordal' ? 0.5 : 0.25;\n      var dt0 = Math.pow(p0.distanceToSquared(p1), pow);\n      var dt1 = Math.pow(p1.distanceToSquared(p2), pow);\n      var dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points\n\n      if (dt1 < 1e-4) dt1 = 1.0;\n      if (dt0 < 1e-4) dt0 = dt1;\n      if (dt2 < 1e-4) dt2 = dt1;\n      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\n      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\n      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\n    } else if (this.type === 'catmullrom') {\n      var tension = this.tension !== undefined ? this.tension : 0.5;\n      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);\n      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);\n      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);\n    }\n\n    var v = new THREE.Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));\n    return v;\n  });\n}(); // File:src/extras/curves/ClosedSplineCurve3.js\n\n/**************************************************************\r\n *\tClosed Spline 3D curve\r\n **************************************************************/\n\n\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(function (points\n/* array of Vector3 */\n) {\n  this.points = points == undefined ? [] : points;\n}, function (t) {\n  var points = this.points;\n  var point = (points.length - 0) * t; // This needs to be from 0-length +1\n\n  var intPoint = Math.floor(point);\n  var weight = point - intPoint;\n  intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;\n  var point0 = points[(intPoint - 1) % points.length];\n  var point1 = points[intPoint % points.length];\n  var point2 = points[(intPoint + 1) % points.length];\n  var point3 = points[(intPoint + 2) % points.length];\n  var vector = new THREE.Vector3();\n  vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);\n  vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);\n  vector.z = THREE.Curve.Utils.interpolate(point0.z, point1.z, point2.z, point3.z, weight);\n  return vector;\n}); // File:src/extras/animation/AnimationHandler.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n */\n\nTHREE.AnimationHandler = {\n  LINEAR: 0,\n  CATMULLROM: 1,\n  CATMULLROM_FORWARD: 2,\n  //\n  add: function add() {\n    console.warn('THREE.AnimationHandler.add() has been deprecated.');\n  },\n  get: function get() {\n    console.warn('THREE.AnimationHandler.get() has been deprecated.');\n  },\n  remove: function remove() {\n    console.warn('THREE.AnimationHandler.remove() has been deprecated.');\n  },\n  //\n  animations: [],\n  init: function init(data) {\n    if (data.initialized === true) return data; // loop through all keys\n\n    for (var h = 0; h < data.hierarchy.length; h++) {\n      for (var k = 0; k < data.hierarchy[h].keys.length; k++) {\n        // remove minus times\n        if (data.hierarchy[h].keys[k].time < 0) {\n          data.hierarchy[h].keys[k].time = 0;\n        } // create quaternions\n\n\n        if (data.hierarchy[h].keys[k].rot !== undefined && !(data.hierarchy[h].keys[k].rot instanceof THREE.Quaternion)) {\n          var quat = data.hierarchy[h].keys[k].rot;\n          data.hierarchy[h].keys[k].rot = new THREE.Quaternion().fromArray(quat);\n        }\n      } // prepare morph target keys\n\n\n      if (data.hierarchy[h].keys.length && data.hierarchy[h].keys[0].morphTargets !== undefined) {\n        // get all used\n        var usedMorphTargets = {};\n\n        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {\n          for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {\n            var morphTargetName = data.hierarchy[h].keys[k].morphTargets[m];\n            usedMorphTargets[morphTargetName] = -1;\n          }\n        }\n\n        data.hierarchy[h].usedMorphTargets = usedMorphTargets; // set all used on all frames\n\n        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {\n          var influences = {};\n\n          for (var morphTargetName in usedMorphTargets) {\n            for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {\n              if (data.hierarchy[h].keys[k].morphTargets[m] === morphTargetName) {\n                influences[morphTargetName] = data.hierarchy[h].keys[k].morphTargetsInfluences[m];\n                break;\n              }\n            }\n\n            if (m === data.hierarchy[h].keys[k].morphTargets.length) {\n              influences[morphTargetName] = 0;\n            }\n          }\n\n          data.hierarchy[h].keys[k].morphTargetsInfluences = influences;\n        }\n      } // remove all keys that are on the same time\n\n\n      for (var k = 1; k < data.hierarchy[h].keys.length; k++) {\n        if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {\n          data.hierarchy[h].keys.splice(k, 1);\n          k--;\n        }\n      } // set index\n\n\n      for (var k = 0; k < data.hierarchy[h].keys.length; k++) {\n        data.hierarchy[h].keys[k].index = k;\n      }\n    }\n\n    data.initialized = true;\n    return data;\n  },\n  parse: function parse(root) {\n    var parseRecurseHierarchy = function parseRecurseHierarchy(root, hierarchy) {\n      hierarchy.push(root);\n\n      for (var c = 0; c < root.children.length; c++) {\n        parseRecurseHierarchy(root.children[c], hierarchy);\n      }\n    }; // setup hierarchy\n\n\n    var hierarchy = [];\n\n    if (root instanceof THREE.SkinnedMesh) {\n      for (var b = 0; b < root.skeleton.bones.length; b++) {\n        hierarchy.push(root.skeleton.bones[b]);\n      }\n    } else {\n      parseRecurseHierarchy(root, hierarchy);\n    }\n\n    return hierarchy;\n  },\n  play: function play(animation) {\n    if (this.animations.indexOf(animation) === -1) {\n      this.animations.push(animation);\n    }\n  },\n  stop: function stop(animation) {\n    var index = this.animations.indexOf(animation);\n\n    if (index !== -1) {\n      this.animations.splice(index, 1);\n    }\n  },\n  update: function update(deltaTimeMS) {\n    for (var i = 0; i < this.animations.length; i++) {\n      this.animations[i].resetBlendWeights();\n    }\n\n    for (var i = 0; i < this.animations.length; i++) {\n      this.animations[i].update(deltaTimeMS);\n    }\n  }\n}; // File:src/extras/animation/Animation.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.Animation = function (root, data) {\n  this.root = root;\n  this.data = THREE.AnimationHandler.init(data);\n  this.hierarchy = THREE.AnimationHandler.parse(root);\n  this.currentTime = 0;\n  this.timeScale = 1;\n  this.isPlaying = false;\n  this.loop = true;\n  this.weight = 0;\n  this.interpolationType = THREE.AnimationHandler.LINEAR;\n};\n\nTHREE.Animation.prototype = {\n  constructor: THREE.Animation,\n  keyTypes: [\"pos\", \"rot\", \"scl\"],\n  play: function play(startTime, weight) {\n    this.currentTime = startTime !== undefined ? startTime : 0;\n    this.weight = weight !== undefined ? weight : 1;\n    this.isPlaying = true;\n    this.reset();\n    THREE.AnimationHandler.play(this);\n  },\n  stop: function stop() {\n    this.isPlaying = false;\n    THREE.AnimationHandler.stop(this);\n  },\n  reset: function reset() {\n    for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {\n      var object = this.hierarchy[h];\n\n      if (object.animationCache === undefined) {\n        object.animationCache = {\n          animations: {},\n          blending: {\n            positionWeight: 0.0,\n            quaternionWeight: 0.0,\n            scaleWeight: 0.0\n          }\n        };\n      }\n\n      var name = this.data.name;\n      var animations = object.animationCache.animations;\n      var animationCache = animations[name];\n\n      if (animationCache === undefined) {\n        animationCache = {\n          prevKey: {\n            pos: 0,\n            rot: 0,\n            scl: 0\n          },\n          nextKey: {\n            pos: 0,\n            rot: 0,\n            scl: 0\n          },\n          originalMatrix: object.matrix\n        };\n        animations[name] = animationCache;\n      } // Get keys to match our current time\n\n\n      for (var t = 0; t < 3; t++) {\n        var type = this.keyTypes[t];\n        var prevKey = this.data.hierarchy[h].keys[0];\n        var nextKey = this.getNextKeyWith(type, h, 1);\n\n        while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {\n          prevKey = nextKey;\n          nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);\n        }\n\n        animationCache.prevKey[type] = prevKey;\n        animationCache.nextKey[type] = nextKey;\n      }\n    }\n  },\n  resetBlendWeights: function resetBlendWeights() {\n    for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {\n      var object = this.hierarchy[h];\n      var animationCache = object.animationCache;\n\n      if (animationCache !== undefined) {\n        var blending = animationCache.blending;\n        blending.positionWeight = 0.0;\n        blending.quaternionWeight = 0.0;\n        blending.scaleWeight = 0.0;\n      }\n    }\n  },\n  update: function () {\n    var points = [];\n    var target = new THREE.Vector3();\n    var newVector = new THREE.Vector3();\n    var newQuat = new THREE.Quaternion(); // Catmull-Rom spline\n\n    var interpolateCatmullRom = function interpolateCatmullRom(points, scale) {\n      var c = [],\n          v3 = [],\n          point,\n          intPoint,\n          weight,\n          w2,\n          w3,\n          pa,\n          pb,\n          pc,\n          pd;\n      point = (points.length - 1) * scale;\n      intPoint = Math.floor(point);\n      weight = point - intPoint;\n      c[0] = intPoint === 0 ? intPoint : intPoint - 1;\n      c[1] = intPoint;\n      c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\n      c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\n      pa = points[c[0]];\n      pb = points[c[1]];\n      pc = points[c[2]];\n      pd = points[c[3]];\n      w2 = weight * weight;\n      w3 = weight * w2;\n      v3[0] = interpolate(pa[0], pb[0], pc[0], pd[0], weight, w2, w3);\n      v3[1] = interpolate(pa[1], pb[1], pc[1], pd[1], weight, w2, w3);\n      v3[2] = interpolate(pa[2], pb[2], pc[2], pd[2], weight, w2, w3);\n      return v3;\n    };\n\n    var interpolate = function interpolate(p0, p1, p2, p3, t, t2, t3) {\n      var v0 = (p2 - p0) * 0.5,\n          v1 = (p3 - p1) * 0.5;\n      return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n    };\n\n    return function (delta) {\n      if (this.isPlaying === false) return;\n      this.currentTime += delta * this.timeScale;\n      if (this.weight === 0) return; //\n\n      var duration = this.data.length;\n\n      if (this.currentTime > duration || this.currentTime < 0) {\n        if (this.loop) {\n          this.currentTime %= duration;\n          if (this.currentTime < 0) this.currentTime += duration;\n          this.reset();\n        } else {\n          this.stop();\n        }\n      }\n\n      for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {\n        var object = this.hierarchy[h];\n        var animationCache = object.animationCache.animations[this.data.name];\n        var blending = object.animationCache.blending; // loop through pos/rot/scl\n\n        for (var t = 0; t < 3; t++) {\n          // get keys\n          var type = this.keyTypes[t];\n          var prevKey = animationCache.prevKey[type];\n          var nextKey = animationCache.nextKey[type];\n\n          if (this.timeScale > 0 && nextKey.time <= this.currentTime || this.timeScale < 0 && prevKey.time >= this.currentTime) {\n            prevKey = this.data.hierarchy[h].keys[0];\n            nextKey = this.getNextKeyWith(type, h, 1);\n\n            while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {\n              prevKey = nextKey;\n              nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);\n            }\n\n            animationCache.prevKey[type] = prevKey;\n            animationCache.nextKey[type] = nextKey;\n          }\n\n          var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);\n          var prevXYZ = prevKey[type];\n          var nextXYZ = nextKey[type];\n          if (scale < 0) scale = 0;\n          if (scale > 1) scale = 1; // interpolate\n\n          if (type === \"pos\") {\n            if (this.interpolationType === THREE.AnimationHandler.LINEAR) {\n              newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;\n              newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;\n              newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale; // blend\n\n              var proportionalWeight = this.weight / (this.weight + blending.positionWeight);\n              object.position.lerp(newVector, proportionalWeight);\n              blending.positionWeight += this.weight;\n            } else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {\n              points[0] = this.getPrevKeyWith(\"pos\", h, prevKey.index - 1)[\"pos\"];\n              points[1] = prevXYZ;\n              points[2] = nextXYZ;\n              points[3] = this.getNextKeyWith(\"pos\", h, nextKey.index + 1)[\"pos\"];\n              scale = scale * 0.33 + 0.33;\n              var currentPoint = interpolateCatmullRom(points, scale);\n              var proportionalWeight = this.weight / (this.weight + blending.positionWeight);\n              blending.positionWeight += this.weight; // blend\n\n              var vector = object.position;\n              vector.x = vector.x + (currentPoint[0] - vector.x) * proportionalWeight;\n              vector.y = vector.y + (currentPoint[1] - vector.y) * proportionalWeight;\n              vector.z = vector.z + (currentPoint[2] - vector.z) * proportionalWeight;\n\n              if (this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {\n                var forwardPoint = interpolateCatmullRom(points, scale * 1.01);\n                target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);\n                target.sub(vector);\n                target.y = 0;\n                target.normalize();\n                var angle = Math.atan2(target.x, target.z);\n                object.rotation.set(0, angle, 0);\n              }\n            }\n          } else if (type === \"rot\") {\n            THREE.Quaternion.slerp(prevXYZ, nextXYZ, newQuat, scale); // Avoid paying the cost of an additional slerp if we don't have to\n\n            if (blending.quaternionWeight === 0) {\n              object.quaternion.copy(newQuat);\n              blending.quaternionWeight = this.weight;\n            } else {\n              var proportionalWeight = this.weight / (this.weight + blending.quaternionWeight);\n              THREE.Quaternion.slerp(object.quaternion, newQuat, object.quaternion, proportionalWeight);\n              blending.quaternionWeight += this.weight;\n            }\n          } else if (type === \"scl\") {\n            newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;\n            newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;\n            newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;\n            var proportionalWeight = this.weight / (this.weight + blending.scaleWeight);\n            object.scale.lerp(newVector, proportionalWeight);\n            blending.scaleWeight += this.weight;\n          }\n        }\n      }\n\n      return true;\n    };\n  }(),\n  getNextKeyWith: function getNextKeyWith(type, h, key) {\n    var keys = this.data.hierarchy[h].keys;\n\n    if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {\n      key = key < keys.length - 1 ? key : keys.length - 1;\n    } else {\n      key = key % keys.length;\n    }\n\n    for (; key < keys.length; key++) {\n      if (keys[key][type] !== undefined) {\n        return keys[key];\n      }\n    }\n\n    return this.data.hierarchy[h].keys[0];\n  },\n  getPrevKeyWith: function getPrevKeyWith(type, h, key) {\n    var keys = this.data.hierarchy[h].keys;\n\n    if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {\n      key = key > 0 ? key : 0;\n    } else {\n      key = key >= 0 ? key : key + keys.length;\n    }\n\n    for (; key >= 0; key--) {\n      if (keys[key][type] !== undefined) {\n        return keys[key];\n      }\n    }\n\n    return this.data.hierarchy[h].keys[keys.length - 1];\n  }\n}; // File:src/extras/animation/KeyFrameAnimation.js\n\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author khang duong\r\n * @author erik kitson\r\n */\n\nTHREE.KeyFrameAnimation = function (data) {\n  this.root = data.node;\n  this.data = THREE.AnimationHandler.init(data);\n  this.hierarchy = THREE.AnimationHandler.parse(this.root);\n  this.currentTime = 0;\n  this.timeScale = 0.001;\n  this.isPlaying = false;\n  this.isPaused = true;\n  this.loop = true; // initialize to first keyframes\n\n  for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {\n    var keys = this.data.hierarchy[h].keys,\n        sids = this.data.hierarchy[h].sids,\n        obj = this.hierarchy[h];\n\n    if (keys.length && sids) {\n      for (var s = 0; s < sids.length; s++) {\n        var sid = sids[s],\n            next = this.getNextKeyWith(sid, h, 0);\n\n        if (next) {\n          next.apply(sid);\n        }\n      }\n\n      obj.matrixAutoUpdate = false;\n      this.data.hierarchy[h].node.updateMatrix();\n      obj.matrixWorldNeedsUpdate = true;\n    }\n  }\n};\n\nTHREE.KeyFrameAnimation.prototype = {\n  constructor: THREE.KeyFrameAnimation,\n  play: function play(startTime) {\n    this.currentTime = startTime !== undefined ? startTime : 0;\n\n    if (this.isPlaying === false) {\n      this.isPlaying = true; // reset key cache\n\n      var h,\n          hl = this.hierarchy.length,\n          object,\n          node;\n\n      for (h = 0; h < hl; h++) {\n        object = this.hierarchy[h];\n        node = this.data.hierarchy[h];\n\n        if (node.animationCache === undefined) {\n          node.animationCache = {};\n          node.animationCache.prevKey = null;\n          node.animationCache.nextKey = null;\n          node.animationCache.originalMatrix = object.matrix;\n        }\n\n        var keys = this.data.hierarchy[h].keys;\n\n        if (keys.length) {\n          node.animationCache.prevKey = keys[0];\n          node.animationCache.nextKey = keys[1];\n          this.startTime = Math.min(keys[0].time, this.startTime);\n          this.endTime = Math.max(keys[keys.length - 1].time, this.endTime);\n        }\n      }\n\n      this.update(0);\n    }\n\n    this.isPaused = false;\n    THREE.AnimationHandler.play(this);\n  },\n  stop: function stop() {\n    this.isPlaying = false;\n    this.isPaused = false;\n    THREE.AnimationHandler.stop(this); // reset JIT matrix and remove cache\n\n    for (var h = 0; h < this.data.hierarchy.length; h++) {\n      var obj = this.hierarchy[h];\n      var node = this.data.hierarchy[h];\n\n      if (node.animationCache !== undefined) {\n        var original = node.animationCache.originalMatrix;\n        original.copy(obj.matrix);\n        obj.matrix = original;\n        delete node.animationCache;\n      }\n    }\n  },\n  update: function update(delta) {\n    if (this.isPlaying === false) return;\n    this.currentTime += delta * this.timeScale; //\n\n    var duration = this.data.length;\n\n    if (this.loop === true && this.currentTime > duration) {\n      this.currentTime %= duration;\n    }\n\n    this.currentTime = Math.min(this.currentTime, duration);\n\n    for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {\n      var object = this.hierarchy[h];\n      var node = this.data.hierarchy[h];\n      var keys = node.keys,\n          animationCache = node.animationCache;\n\n      if (keys.length) {\n        var prevKey = animationCache.prevKey;\n        var nextKey = animationCache.nextKey;\n\n        if (nextKey.time <= this.currentTime) {\n          while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {\n            prevKey = nextKey;\n            nextKey = keys[prevKey.index + 1];\n          }\n\n          animationCache.prevKey = prevKey;\n          animationCache.nextKey = nextKey;\n        }\n\n        if (nextKey.time >= this.currentTime) {\n          prevKey.interpolate(nextKey, this.currentTime);\n        } else {\n          prevKey.interpolate(nextKey, nextKey.time);\n        }\n\n        this.data.hierarchy[h].node.updateMatrix();\n        object.matrixWorldNeedsUpdate = true;\n      }\n    }\n  },\n  getNextKeyWith: function getNextKeyWith(sid, h, key) {\n    var keys = this.data.hierarchy[h].keys;\n    key = key % keys.length;\n\n    for (; key < keys.length; key++) {\n      if (keys[key].hasTarget(sid)) {\n        return keys[key];\n      }\n    }\n\n    return keys[0];\n  },\n  getPrevKeyWith: function getPrevKeyWith(sid, h, key) {\n    var keys = this.data.hierarchy[h].keys;\n    key = key >= 0 ? key : key + keys.length;\n\n    for (; key >= 0; key--) {\n      if (keys[key].hasTarget(sid)) {\n        return keys[key];\n      }\n    }\n\n    return keys[keys.length - 1];\n  }\n}; // File:src/extras/animation/MorphAnimation.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com\r\n * @author willy-vvu / http://willy-vvu.github.io\r\n */\n\nTHREE.MorphAnimation = function (mesh) {\n  this.mesh = mesh;\n  this.frames = mesh.morphTargetInfluences.length;\n  this.currentTime = 0;\n  this.duration = 1000;\n  this.loop = true;\n  this.lastFrame = 0;\n  this.currentFrame = 0;\n  this.isPlaying = false;\n};\n\nTHREE.MorphAnimation.prototype = {\n  constructor: THREE.MorphAnimation,\n  play: function play() {\n    this.isPlaying = true;\n  },\n  pause: function pause() {\n    this.isPlaying = false;\n  },\n  update: function update(delta) {\n    if (this.isPlaying === false) return;\n    this.currentTime += delta;\n\n    if (this.loop === true && this.currentTime > this.duration) {\n      this.currentTime %= this.duration;\n    }\n\n    this.currentTime = Math.min(this.currentTime, this.duration);\n    var frameTime = this.duration / this.frames;\n    var frame = Math.floor(this.currentTime / frameTime);\n    var influences = this.mesh.morphTargetInfluences;\n\n    if (frame !== this.currentFrame) {\n      influences[this.lastFrame] = 0;\n      influences[this.currentFrame] = 1;\n      influences[frame] = 0;\n      this.lastFrame = this.currentFrame;\n      this.currentFrame = frame;\n    }\n\n    var mix = this.currentTime % frameTime / frameTime;\n    influences[frame] = mix;\n    influences[this.lastFrame] = 1 - mix;\n  }\n}; // File:src/extras/geometries/BoxGeometry.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\n\nTHREE.BoxGeometry = function (width, height, depth, widthSegments, heightSegments, depthSegments) {\n  THREE.Geometry.call(this);\n  this.type = 'BoxGeometry';\n  this.parameters = {\n    width: width,\n    height: height,\n    depth: depth,\n    widthSegments: widthSegments,\n    heightSegments: heightSegments,\n    depthSegments: depthSegments\n  };\n  this.widthSegments = widthSegments || 1;\n  this.heightSegments = heightSegments || 1;\n  this.depthSegments = depthSegments || 1;\n  var scope = this;\n  var width_half = width / 2;\n  var height_half = height / 2;\n  var depth_half = depth / 2;\n  buildPlane('z', 'y', -1, -1, depth, height, width_half, 0); // px\n\n  buildPlane('z', 'y', 1, -1, depth, height, -width_half, 1); // nx\n\n  buildPlane('x', 'z', 1, 1, width, depth, height_half, 2); // py\n\n  buildPlane('x', 'z', 1, -1, width, depth, -height_half, 3); // ny\n\n  buildPlane('x', 'y', 1, -1, width, height, depth_half, 4); // pz\n\n  buildPlane('x', 'y', -1, -1, width, height, -depth_half, 5); // nz\n\n  function buildPlane(u, v, udir, vdir, width, height, depth, materialIndex) {\n    var w,\n        ix,\n        iy,\n        gridX = scope.widthSegments,\n        gridY = scope.heightSegments,\n        width_half = width / 2,\n        height_half = height / 2,\n        offset = scope.vertices.length;\n\n    if (u === 'x' && v === 'y' || u === 'y' && v === 'x') {\n      w = 'z';\n    } else if (u === 'x' && v === 'z' || u === 'z' && v === 'x') {\n      w = 'y';\n      gridY = scope.depthSegments;\n    } else if (u === 'z' && v === 'y' || u === 'y' && v === 'z') {\n      w = 'x';\n      gridX = scope.depthSegments;\n    }\n\n    var gridX1 = gridX + 1,\n        gridY1 = gridY + 1,\n        segment_width = width / gridX,\n        segment_height = height / gridY,\n        normal = new THREE.Vector3();\n    normal[w] = depth > 0 ? 1 : -1;\n\n    for (iy = 0; iy < gridY1; iy++) {\n      for (ix = 0; ix < gridX1; ix++) {\n        var vector = new THREE.Vector3();\n        vector[u] = (ix * segment_width - width_half) * udir;\n        vector[v] = (iy * segment_height - height_half) * vdir;\n        vector[w] = depth;\n        scope.vertices.push(vector);\n      }\n    }\n\n    for (iy = 0; iy < gridY; iy++) {\n      for (ix = 0; ix < gridX; ix++) {\n        var a = ix + gridX1 * iy;\n        var b = ix + gridX1 * (iy + 1);\n        var c = ix + 1 + gridX1 * (iy + 1);\n        var d = ix + 1 + gridX1 * iy;\n        var uva = new THREE.Vector2(ix / gridX, 1 - iy / gridY);\n        var uvb = new THREE.Vector2(ix / gridX, 1 - (iy + 1) / gridY);\n        var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iy + 1) / gridY);\n        var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iy / gridY);\n        var face = new THREE.Face3(a + offset, b + offset, d + offset);\n        face.normal.copy(normal);\n        face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());\n        face.materialIndex = materialIndex;\n        scope.faces.push(face);\n        scope.faceVertexUvs[0].push([uva, uvb, uvd]);\n        face = new THREE.Face3(b + offset, c + offset, d + offset);\n        face.normal.copy(normal);\n        face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());\n        face.materialIndex = materialIndex;\n        scope.faces.push(face);\n        scope.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);\n      }\n    }\n  }\n\n  this.mergeVertices();\n};\n\nTHREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\n\nTHREE.BoxGeometry.prototype.clone = function () {\n  var geometry = new THREE.BoxGeometry(this.parameters.width, this.parameters.height, this.parameters.depth, this.parameters.widthSegments, this.parameters.heightSegments, this.parameters.depthSegments);\n  return geometry;\n};\n\nTHREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility\n// File:src/extras/geometries/CircleGeometry.js\n\n/**\r\n * @author hughes\r\n */\n\nTHREE.CircleGeometry = function (radius, segments, thetaStart, thetaLength) {\n  THREE.Geometry.call(this);\n  this.type = 'CircleGeometry';\n  this.parameters = {\n    radius: radius,\n    segments: segments,\n    thetaStart: thetaStart,\n    thetaLength: thetaLength\n  };\n  radius = radius || 50;\n  segments = segments !== undefined ? Math.max(3, segments) : 8;\n  thetaStart = thetaStart !== undefined ? thetaStart : 0;\n  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n  var i,\n      uvs = [],\n      center = new THREE.Vector3(),\n      centerUV = new THREE.Vector2(0.5, 0.5);\n  this.vertices.push(center);\n  uvs.push(centerUV);\n\n  for (i = 0; i <= segments; i++) {\n    var vertex = new THREE.Vector3();\n    var segment = thetaStart + i / segments * thetaLength;\n    vertex.x = radius * Math.cos(segment);\n    vertex.y = radius * Math.sin(segment);\n    this.vertices.push(vertex);\n    uvs.push(new THREE.Vector2((vertex.x / radius + 1) / 2, (vertex.y / radius + 1) / 2));\n  }\n\n  var n = new THREE.Vector3(0, 0, 1);\n\n  for (i = 1; i <= segments; i++) {\n    this.faces.push(new THREE.Face3(i, i + 1, 0, [n.clone(), n.clone(), n.clone()]));\n    this.faceVertexUvs[0].push([uvs[i].clone(), uvs[i + 1].clone(), centerUV.clone()]);\n  }\n\n  this.computeFaceNormals();\n  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);\n};\n\nTHREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\n\nTHREE.CircleGeometry.prototype.clone = function () {\n  var geometry = new THREE.CircleGeometry(this.parameters.radius, this.parameters.segments, this.parameters.thetaStart, this.parameters.thetaLength);\n  return geometry;\n}; // File:src/extras/geometries/CircleBufferGeometry.js\n\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\n\n\nTHREE.CircleBufferGeometry = function (radius, segments, thetaStart, thetaLength) {\n  THREE.BufferGeometry.call(this);\n  this.type = 'CircleBufferGeometry';\n  this.parameters = {\n    radius: radius,\n    segments: segments,\n    thetaStart: thetaStart,\n    thetaLength: thetaLength\n  };\n  radius = radius || 50;\n  segments = segments !== undefined ? Math.max(3, segments) : 8;\n  thetaStart = thetaStart !== undefined ? thetaStart : 0;\n  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n  var vertices = segments + 2;\n  var positions = new Float32Array(vertices * 3);\n  var normals = new Float32Array(vertices * 3);\n  var uvs = new Float32Array(vertices * 2); // center data is already zero, but need to set a few extras\n\n  normals[3] = 1.0;\n  uvs[0] = 0.5;\n  uvs[1] = 0.5;\n\n  for (var s = 0, i = 3, ii = 2; s <= segments; s++, i += 3, ii += 2) {\n    var segment = thetaStart + s / segments * thetaLength;\n    positions[i] = radius * Math.cos(segment);\n    positions[i + 1] = radius * Math.sin(segment);\n    normals[i + 2] = 1; // normal z\n\n    uvs[ii] = (positions[i] / radius + 1) / 2;\n    uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;\n  }\n\n  var indices = [];\n\n  for (var i = 1; i <= segments; i++) {\n    indices.push(i);\n    indices.push(i + 1);\n    indices.push(0);\n  }\n\n  this.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));\n  this.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n  this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n  this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));\n  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);\n};\n\nTHREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\n\nTHREE.CircleBufferGeometry.prototype.clone = function () {\n  var geometry = new THREE.CircleBufferGeometry(this.parameters.radius, this.parameters.segments, this.parameters.thetaStart, this.parameters.thetaLength);\n  geometry.copy(this);\n  return geometry;\n}; // File:src/extras/geometries/CylinderGeometry.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.CylinderGeometry = function (radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {\n  THREE.Geometry.call(this);\n  this.type = 'CylinderGeometry';\n  this.parameters = {\n    radiusTop: radiusTop,\n    radiusBottom: radiusBottom,\n    height: height,\n    radialSegments: radialSegments,\n    heightSegments: heightSegments,\n    openEnded: openEnded,\n    thetaStart: thetaStart,\n    thetaLength: thetaLength\n  };\n  radiusTop = radiusTop !== undefined ? radiusTop : 20;\n  radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n  height = height !== undefined ? height : 100;\n  radialSegments = radialSegments || 8;\n  heightSegments = heightSegments || 1;\n  openEnded = openEnded !== undefined ? openEnded : false;\n  thetaStart = thetaStart !== undefined ? thetaStart : 0;\n  thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\n  var heightHalf = height / 2;\n  var x,\n      y,\n      vertices = [],\n      uvs = [];\n\n  for (y = 0; y <= heightSegments; y++) {\n    var verticesRow = [];\n    var uvsRow = [];\n    var v = y / heightSegments;\n    var radius = v * (radiusBottom - radiusTop) + radiusTop;\n\n    for (x = 0; x <= radialSegments; x++) {\n      var u = x / radialSegments;\n      var vertex = new THREE.Vector3();\n      vertex.x = radius * Math.sin(u * thetaLength + thetaStart);\n      vertex.y = -v * height + heightHalf;\n      vertex.z = radius * Math.cos(u * thetaLength + thetaStart);\n      this.vertices.push(vertex);\n      verticesRow.push(this.vertices.length - 1);\n      uvsRow.push(new THREE.Vector2(u, 1 - v));\n    }\n\n    vertices.push(verticesRow);\n    uvs.push(uvsRow);\n  }\n\n  var tanTheta = (radiusBottom - radiusTop) / height;\n  var na, nb;\n\n  for (x = 0; x < radialSegments; x++) {\n    if (radiusTop !== 0) {\n      na = this.vertices[vertices[0][x]].clone();\n      nb = this.vertices[vertices[0][x + 1]].clone();\n    } else {\n      na = this.vertices[vertices[1][x]].clone();\n      nb = this.vertices[vertices[1][x + 1]].clone();\n    }\n\n    na.setY(Math.sqrt(na.x * na.x + na.z * na.z) * tanTheta).normalize();\n    nb.setY(Math.sqrt(nb.x * nb.x + nb.z * nb.z) * tanTheta).normalize();\n\n    for (y = 0; y < heightSegments; y++) {\n      var v1 = vertices[y][x];\n      var v2 = vertices[y + 1][x];\n      var v3 = vertices[y + 1][x + 1];\n      var v4 = vertices[y][x + 1];\n      var n1 = na.clone();\n      var n2 = na.clone();\n      var n3 = nb.clone();\n      var n4 = nb.clone();\n      var uv1 = uvs[y][x].clone();\n      var uv2 = uvs[y + 1][x].clone();\n      var uv3 = uvs[y + 1][x + 1].clone();\n      var uv4 = uvs[y][x + 1].clone();\n      this.faces.push(new THREE.Face3(v1, v2, v4, [n1, n2, n4]));\n      this.faceVertexUvs[0].push([uv1, uv2, uv4]);\n      this.faces.push(new THREE.Face3(v2, v3, v4, [n2.clone(), n3, n4.clone()]));\n      this.faceVertexUvs[0].push([uv2.clone(), uv3, uv4.clone()]);\n    }\n  } // top cap\n\n\n  if (openEnded === false && radiusTop > 0) {\n    this.vertices.push(new THREE.Vector3(0, heightHalf, 0));\n\n    for (x = 0; x < radialSegments; x++) {\n      var v1 = vertices[0][x];\n      var v2 = vertices[0][x + 1];\n      var v3 = this.vertices.length - 1;\n      var n1 = new THREE.Vector3(0, 1, 0);\n      var n2 = new THREE.Vector3(0, 1, 0);\n      var n3 = new THREE.Vector3(0, 1, 0);\n      var uv1 = uvs[0][x].clone();\n      var uv2 = uvs[0][x + 1].clone();\n      var uv3 = new THREE.Vector2(uv2.x, 0);\n      this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3], undefined, 1));\n      this.faceVertexUvs[0].push([uv1, uv2, uv3]);\n    }\n  } // bottom cap\n\n\n  if (openEnded === false && radiusBottom > 0) {\n    this.vertices.push(new THREE.Vector3(0, -heightHalf, 0));\n\n    for (x = 0; x < radialSegments; x++) {\n      var v1 = vertices[heightSegments][x + 1];\n      var v2 = vertices[heightSegments][x];\n      var v3 = this.vertices.length - 1;\n      var n1 = new THREE.Vector3(0, -1, 0);\n      var n2 = new THREE.Vector3(0, -1, 0);\n      var n3 = new THREE.Vector3(0, -1, 0);\n      var uv1 = uvs[heightSegments][x + 1].clone();\n      var uv2 = uvs[heightSegments][x].clone();\n      var uv3 = new THREE.Vector2(uv2.x, 1);\n      this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3], undefined, 2));\n      this.faceVertexUvs[0].push([uv1, uv2, uv3]);\n    }\n  }\n\n  this.computeFaceNormals();\n};\n\nTHREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\n\nTHREE.CylinderGeometry.prototype.clone = function () {\n  var geometry = new THREE.CylinderGeometry(this.parameters.radiusTop, this.parameters.radiusBottom, this.parameters.height, this.parameters.radialSegments, this.parameters.heightSegments, this.parameters.openEnded, this.parameters.thetaStart, this.parameters.thetaLength);\n  return geometry;\n}; // File:src/extras/geometries/EdgesGeometry.js\n\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\n\n\nTHREE.EdgesGeometry = function (geometry, thresholdAngle) {\n  THREE.BufferGeometry.call(this);\n  thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;\n  var thresholdDot = Math.cos(THREE.Math.degToRad(thresholdAngle));\n  var edge = [0, 0],\n      hash = {};\n\n  var sortFunction = function sortFunction(a, b) {\n    return a - b;\n  };\n\n  var keys = ['a', 'b', 'c'];\n  var geometry2;\n\n  if (geometry instanceof THREE.BufferGeometry) {\n    geometry2 = new THREE.Geometry();\n    geometry2.fromBufferGeometry(geometry);\n  } else {\n    geometry2 = geometry.clone();\n  }\n\n  geometry2.mergeVertices();\n  geometry2.computeFaceNormals();\n  var vertices = geometry2.vertices;\n  var faces = geometry2.faces;\n\n  for (var i = 0, l = faces.length; i < l; i++) {\n    var face = faces[i];\n\n    for (var j = 0; j < 3; j++) {\n      edge[0] = face[keys[j]];\n      edge[1] = face[keys[(j + 1) % 3]];\n      edge.sort(sortFunction);\n      var key = edge.toString();\n\n      if (hash[key] === undefined) {\n        hash[key] = {\n          vert1: edge[0],\n          vert2: edge[1],\n          face1: i,\n          face2: undefined\n        };\n      } else {\n        hash[key].face2 = i;\n      }\n    }\n  }\n\n  var coords = [];\n\n  for (var key in hash) {\n    var h = hash[key];\n\n    if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {\n      var vertex = vertices[h.vert1];\n      coords.push(vertex.x);\n      coords.push(vertex.y);\n      coords.push(vertex.z);\n      vertex = vertices[h.vert2];\n      coords.push(vertex.x);\n      coords.push(vertex.y);\n      coords.push(vertex.z);\n    }\n  }\n\n  this.addAttribute('position', new THREE.BufferAttribute(new Float32Array(coords), 3));\n};\n\nTHREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry; // File:src/extras/geometries/ExtrudeGeometry.js\n\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n *  amount: <int>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\n\nTHREE.ExtrudeGeometry = function (shapes, options) {\n  if (typeof shapes === \"undefined\") {\n    shapes = [];\n    return;\n  }\n\n  THREE.Geometry.call(this);\n  this.type = 'ExtrudeGeometry';\n  shapes = Array.isArray(shapes) ? shapes : [shapes];\n  this.addShapeList(shapes, options);\n  this.computeFaceNormals(); // can't really use automatic vertex normals\n  // as then front and back sides get smoothed too\n  // should do separate smoothing just for sides\n  //this.computeVertexNormals();\n  //console.log( \"took\", ( Date.now() - startTime ) );\n};\n\nTHREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\n\nTHREE.ExtrudeGeometry.prototype.addShapeList = function (shapes, options) {\n  var sl = shapes.length;\n\n  for (var s = 0; s < sl; s++) {\n    var shape = shapes[s];\n    this.addShape(shape, options);\n  }\n};\n\nTHREE.ExtrudeGeometry.prototype.addShape = function (shape, options) {\n  var amount = options.amount !== undefined ? options.amount : 100;\n  var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\n  var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\n  var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n  var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n  var steps = options.steps !== undefined ? options.steps : 1;\n  var extrudePath = options.extrudePath;\n  var extrudePts,\n      extrudeByPath = false; // Use default WorldUVGenerator if no UV generators are specified.\n\n  var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n  var splineTube, binormal, normal, position2;\n\n  if (extrudePath) {\n    extrudePts = extrudePath.getSpacedPoints(steps);\n    extrudeByPath = true;\n    bevelEnabled = false; // bevels not supported for path extrusion\n    // SETUP TNB variables\n    // Reuse TNB from TubeGeomtry for now.\n    // TODO1 - have a .isClosed in spline?\n\n    splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n    binormal = new THREE.Vector3();\n    normal = new THREE.Vector3();\n    position2 = new THREE.Vector3();\n  } // Safeguards if bevels are not enabled\n\n\n  if (!bevelEnabled) {\n    bevelSegments = 0;\n    bevelThickness = 0;\n    bevelSize = 0;\n  } // Variables initialization\n\n\n  var ahole, h, hl; // looping of holes\n\n  var scope = this;\n  var shapesOffset = this.vertices.length;\n  var shapePoints = shape.extractPoints(curveSegments);\n  var vertices = shapePoints.shape;\n  var holes = shapePoints.holes;\n  var reverse = !THREE.Shape.Utils.isClockWise(vertices);\n\n  if (reverse) {\n    vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n    for (h = 0, hl = holes.length; h < hl; h++) {\n      ahole = holes[h];\n\n      if (THREE.Shape.Utils.isClockWise(ahole)) {\n        holes[h] = ahole.reverse();\n      }\n    }\n\n    reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n  }\n\n  var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);\n  /* Vertices */\n\n  var contour = vertices; // vertices has all points but contour has only points of circumference\n\n  for (h = 0, hl = holes.length; h < hl; h++) {\n    ahole = holes[h];\n    vertices = vertices.concat(ahole);\n  }\n\n  function scalePt2(pt, vec, size) {\n    if (!vec) console.error(\"THREE.ExtrudeGeometry: vec does not exist\");\n    return vec.clone().multiplyScalar(size).add(pt);\n  }\n\n  var b,\n      bs,\n      t,\n      z,\n      vert,\n      vlen = vertices.length,\n      face,\n      flen = faces.length; // Find directions for point movement\n\n  function getBevelVec(inPt, inPrev, inNext) {\n    var EPSILON = 0.0000000001; // computes for inPt the corresponding point inPt' on a new contour\n    //   shifted by 1 unit (length of normalized vector) to the left\n    // if we walk along contour clockwise, this new contour is outside the old one\n    //\n    // inPt' is the intersection of the two lines parallel to the two\n    //  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n    var v_trans_x,\n        v_trans_y,\n        shrink_by = 1; // resulting translation vector for inPt\n    // good reading for geometry algorithms (here: line-line intersection)\n    // http://geomalgorithms.com/a05-_intersect-1.html\n\n    var v_prev_x = inPt.x - inPrev.x,\n        v_prev_y = inPt.y - inPrev.y;\n    var v_next_x = inNext.x - inPt.x,\n        v_next_y = inNext.y - inPt.y;\n    var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges\n\n    var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n\n    if (Math.abs(collinear0) > EPSILON) {\n      // not collinear\n      // length of vectors for normalizing\n      var v_prev_len = Math.sqrt(v_prev_lensq);\n      var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left\n\n      var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n      var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n      var ptNextShift_x = inNext.x - v_next_y / v_next_len;\n      var ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point\n\n      var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point\n\n      v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n      v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly\n      //  but prevent crazy spikes\n\n      var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n\n      if (v_trans_lensq <= 2) {\n        return new THREE.Vector2(v_trans_x, v_trans_y);\n      } else {\n        shrink_by = Math.sqrt(v_trans_lensq / 2);\n      }\n    } else {\n      // handle special case of collinear edges\n      var direction_eq = false; // assumes: opposite\n\n      if (v_prev_x > EPSILON) {\n        if (v_next_x > EPSILON) {\n          direction_eq = true;\n        }\n      } else {\n        if (v_prev_x < -EPSILON) {\n          if (v_next_x < -EPSILON) {\n            direction_eq = true;\n          }\n        } else {\n          if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n            direction_eq = true;\n          }\n        }\n      }\n\n      if (direction_eq) {\n        // console.log(\"Warning: lines are a straight sequence\");\n        v_trans_x = -v_prev_y;\n        v_trans_y = v_prev_x;\n        shrink_by = Math.sqrt(v_prev_lensq);\n      } else {\n        // console.log(\"Warning: lines are a straight spike\");\n        v_trans_x = v_prev_x;\n        v_trans_y = v_prev_y;\n        shrink_by = Math.sqrt(v_prev_lensq / 2);\n      }\n    }\n\n    return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n  }\n\n  var contourMovements = [];\n\n  for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n    if (j === il) j = 0;\n    if (k === il) k = 0; //  (j)---(i)---(k)\n    // console.log('i,j,k', i, j , k)\n\n    contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n  }\n\n  var holesMovements = [],\n      oneHoleMovements,\n      verticesMovements = contourMovements.concat();\n\n  for (h = 0, hl = holes.length; h < hl; h++) {\n    ahole = holes[h];\n    oneHoleMovements = [];\n\n    for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n      if (j === il) j = 0;\n      if (k === il) k = 0; //  (j)---(i)---(k)\n\n      oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n    }\n\n    holesMovements.push(oneHoleMovements);\n    verticesMovements = verticesMovements.concat(oneHoleMovements);\n  } // Loop bevelSegments, 1 for the front, 1 for the back\n\n\n  for (b = 0; b < bevelSegments; b++) {\n    //for ( b = bevelSegments; b > 0; b -- ) {\n    t = b / bevelSegments;\n    z = bevelThickness * (1 - t); //z = bevelThickness * t;\n\n    bs = bevelSize * Math.sin(t * Math.PI / 2); // curved\n    //bs = bevelSize * t; // linear\n    // contract shape\n\n    for (i = 0, il = contour.length; i < il; i++) {\n      vert = scalePt2(contour[i], contourMovements[i], bs);\n      v(vert.x, vert.y, -z);\n    } // expand holes\n\n\n    for (h = 0, hl = holes.length; h < hl; h++) {\n      ahole = holes[h];\n      oneHoleMovements = holesMovements[h];\n\n      for (i = 0, il = ahole.length; i < il; i++) {\n        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n        v(vert.x, vert.y, -z);\n      }\n    }\n  }\n\n  bs = bevelSize; // Back facing vertices\n\n  for (i = 0; i < vlen; i++) {\n    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n    if (!extrudeByPath) {\n      v(vert.x, vert.y, 0);\n    } else {\n      // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n      normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n      binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n      position2.copy(extrudePts[0]).add(normal).add(binormal);\n      v(position2.x, position2.y, position2.z);\n    }\n  } // Add stepped vertices...\n  // Including front facing vertices\n\n\n  var s;\n\n  for (s = 1; s <= steps; s++) {\n    for (i = 0; i < vlen; i++) {\n      vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n      if (!extrudeByPath) {\n        v(vert.x, vert.y, amount / steps * s);\n      } else {\n        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n        normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n        position2.copy(extrudePts[s]).add(normal).add(binormal);\n        v(position2.x, position2.y, position2.z);\n      }\n    }\n  } // Add bevel segments planes\n  //for ( b = 1; b <= bevelSegments; b ++ ) {\n\n\n  for (b = bevelSegments - 1; b >= 0; b--) {\n    t = b / bevelSegments;\n    z = bevelThickness * (1 - t); //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\n    bs = bevelSize * Math.sin(t * Math.PI / 2); // contract shape\n\n    for (i = 0, il = contour.length; i < il; i++) {\n      vert = scalePt2(contour[i], contourMovements[i], bs);\n      v(vert.x, vert.y, amount + z);\n    } // expand holes\n\n\n    for (h = 0, hl = holes.length; h < hl; h++) {\n      ahole = holes[h];\n      oneHoleMovements = holesMovements[h];\n\n      for (i = 0, il = ahole.length; i < il; i++) {\n        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\n        if (!extrudeByPath) {\n          v(vert.x, vert.y, amount + z);\n        } else {\n          v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n        }\n      }\n    }\n  }\n  /* Faces */\n  // Top and bottom faces\n\n\n  buildLidFaces(); // Sides faces\n\n  buildSideFaces(); /////  Internal functions\n\n  function buildLidFaces() {\n    if (bevelEnabled) {\n      var layer = 0; // steps + 1\n\n      var offset = vlen * layer; // Bottom faces\n\n      for (i = 0; i < flen; i++) {\n        face = faces[i];\n        f3(face[2] + offset, face[1] + offset, face[0] + offset);\n      }\n\n      layer = steps + bevelSegments * 2;\n      offset = vlen * layer; // Top faces\n\n      for (i = 0; i < flen; i++) {\n        face = faces[i];\n        f3(face[0] + offset, face[1] + offset, face[2] + offset);\n      }\n    } else {\n      // Bottom faces\n      for (i = 0; i < flen; i++) {\n        face = faces[i];\n        f3(face[2], face[1], face[0]);\n      } // Top faces\n\n\n      for (i = 0; i < flen; i++) {\n        face = faces[i];\n        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\n      }\n    }\n  } // Create faces for the z-sides of the shape\n\n\n  function buildSideFaces() {\n    var layeroffset = 0;\n    sidewalls(contour, layeroffset);\n    layeroffset += contour.length;\n\n    for (h = 0, hl = holes.length; h < hl; h++) {\n      ahole = holes[h];\n      sidewalls(ahole, layeroffset); //, true\n\n      layeroffset += ahole.length;\n    }\n  }\n\n  function sidewalls(contour, layeroffset) {\n    var j, k;\n    i = contour.length;\n\n    while (--i >= 0) {\n      j = i;\n      k = i - 1;\n      if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);\n\n      var s = 0,\n          sl = steps + bevelSegments * 2;\n\n      for (s = 0; s < sl; s++) {\n        var slen1 = vlen * s;\n        var slen2 = vlen * (s + 1);\n        var a = layeroffset + j + slen1,\n            b = layeroffset + k + slen1,\n            c = layeroffset + k + slen2,\n            d = layeroffset + j + slen2;\n        f4(a, b, c, d, contour, s, sl, j, k);\n      }\n    }\n  }\n\n  function v(x, y, z) {\n    scope.vertices.push(new THREE.Vector3(x, y, z));\n  }\n\n  function f3(a, b, c) {\n    a += shapesOffset;\n    b += shapesOffset;\n    c += shapesOffset;\n    scope.faces.push(new THREE.Face3(a, b, c));\n    var uvs = uvgen.generateTopUV(scope, a, b, c);\n    scope.faceVertexUvs[0].push(uvs);\n  }\n\n  function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {\n    a += shapesOffset;\n    b += shapesOffset;\n    c += shapesOffset;\n    d += shapesOffset;\n    scope.faces.push(new THREE.Face3(a, b, d));\n    scope.faces.push(new THREE.Face3(b, c, d));\n    var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);\n    scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);\n    scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]]);\n  }\n};\n\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n  generateTopUV: function generateTopUV(geometry, indexA, indexB, indexC) {\n    var vertices = geometry.vertices;\n    var a = vertices[indexA];\n    var b = vertices[indexB];\n    var c = vertices[indexC];\n    return [new THREE.Vector2(a.x, a.y), new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y)];\n  },\n  generateSideWallUV: function generateSideWallUV(geometry, indexA, indexB, indexC, indexD) {\n    var vertices = geometry.vertices;\n    var a = vertices[indexA];\n    var b = vertices[indexB];\n    var c = vertices[indexC];\n    var d = vertices[indexD];\n\n    if (Math.abs(a.y - b.y) < 0.01) {\n      return [new THREE.Vector2(a.x, 1 - a.z), new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z)];\n    } else {\n      return [new THREE.Vector2(a.y, 1 - a.z), new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z)];\n    }\n  }\n}; // File:src/extras/geometries/ShapeGeometry.js\n\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *\tmaterial: <int> // material index for front and back faces\r\n *\tuvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\n\nTHREE.ShapeGeometry = function (shapes, options) {\n  THREE.Geometry.call(this);\n  this.type = 'ShapeGeometry';\n  if (Array.isArray(shapes) === false) shapes = [shapes];\n  this.addShapeList(shapes, options);\n  this.computeFaceNormals();\n};\n\nTHREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\n\nTHREE.ShapeGeometry.prototype.addShapeList = function (shapes, options) {\n  for (var i = 0, l = shapes.length; i < l; i++) {\n    this.addShape(shapes[i], options);\n  }\n\n  return this;\n};\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\n\n\nTHREE.ShapeGeometry.prototype.addShape = function (shape, options) {\n  if (options === undefined) options = {};\n  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n  var material = options.material;\n  var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator; //\n\n  var i, l, hole;\n  var shapesOffset = this.vertices.length;\n  var shapePoints = shape.extractPoints(curveSegments);\n  var vertices = shapePoints.shape;\n  var holes = shapePoints.holes;\n  var reverse = !THREE.Shape.Utils.isClockWise(vertices);\n\n  if (reverse) {\n    vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n    for (i = 0, l = holes.length; i < l; i++) {\n      hole = holes[i];\n\n      if (THREE.Shape.Utils.isClockWise(hole)) {\n        holes[i] = hole.reverse();\n      }\n    }\n\n    reverse = false;\n  }\n\n  var faces = THREE.Shape.Utils.triangulateShape(vertices, holes); // Vertices\n\n  for (i = 0, l = holes.length; i < l; i++) {\n    hole = holes[i];\n    vertices = vertices.concat(hole);\n  } //\n\n\n  var vert,\n      vlen = vertices.length;\n  var face,\n      flen = faces.length;\n\n  for (i = 0; i < vlen; i++) {\n    vert = vertices[i];\n    this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));\n  }\n\n  for (i = 0; i < flen; i++) {\n    face = faces[i];\n    var a = face[0] + shapesOffset;\n    var b = face[1] + shapesOffset;\n    var c = face[2] + shapesOffset;\n    this.faces.push(new THREE.Face3(a, b, c, null, null, material));\n    this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));\n  }\n}; // File:src/extras/geometries/LatheGeometry.js\n\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n */\n// points - to create a closed torus, one must use a set of points \n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2*PI) range of the lathed section\n//    2*pi is a closed lathe, less than 2PI is a portion.\n\n\nTHREE.LatheGeometry = function (points, segments, phiStart, phiLength) {\n  THREE.Geometry.call(this);\n  this.type = 'LatheGeometry';\n  this.parameters = {\n    points: points,\n    segments: segments,\n    phiStart: phiStart,\n    phiLength: phiLength\n  };\n  segments = segments || 12;\n  phiStart = phiStart || 0;\n  phiLength = phiLength || 2 * Math.PI;\n  var inversePointLength = 1.0 / (points.length - 1);\n  var inverseSegments = 1.0 / segments;\n\n  for (var i = 0, il = segments; i <= il; i++) {\n    var phi = phiStart + i * inverseSegments * phiLength;\n    var c = Math.cos(phi),\n        s = Math.sin(phi);\n\n    for (var j = 0, jl = points.length; j < jl; j++) {\n      var pt = points[j];\n      var vertex = new THREE.Vector3();\n      vertex.x = c * pt.x - s * pt.y;\n      vertex.y = s * pt.x + c * pt.y;\n      vertex.z = pt.z;\n      this.vertices.push(vertex);\n    }\n  }\n\n  var np = points.length;\n\n  for (var i = 0, il = segments; i < il; i++) {\n    for (var j = 0, jl = points.length - 1; j < jl; j++) {\n      var base = j + np * i;\n      var a = base;\n      var b = base + np;\n      var c = base + 1 + np;\n      var d = base + 1;\n      var u0 = i * inverseSegments;\n      var v0 = j * inversePointLength;\n      var u1 = u0 + inverseSegments;\n      var v1 = v0 + inversePointLength;\n      this.faces.push(new THREE.Face3(a, b, d));\n      this.faceVertexUvs[0].push([new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1)]);\n      this.faces.push(new THREE.Face3(b, c, d));\n      this.faceVertexUvs[0].push([new THREE.Vector2(u1, v0), new THREE.Vector2(u1, v1), new THREE.Vector2(u0, v1)]);\n    }\n  }\n\n  this.mergeVertices();\n  this.computeFaceNormals();\n  this.computeVertexNormals();\n};\n\nTHREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry; // File:src/extras/geometries/PlaneGeometry.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\n\nTHREE.PlaneGeometry = function (width, height, widthSegments, heightSegments) {\n  THREE.Geometry.call(this);\n  this.type = 'PlaneGeometry';\n  this.parameters = {\n    width: width,\n    height: height,\n    widthSegments: widthSegments,\n    heightSegments: heightSegments\n  };\n  this.fromBufferGeometry(new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments));\n};\n\nTHREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\n\nTHREE.PlaneGeometry.prototype.clone = function () {\n  var geometry = new THREE.PlaneGeometry(this.parameters.width, this.parameters.height, this.parameters.widthSegments, this.parameters.heightSegments);\n  return geometry;\n}; // File:src/extras/geometries/PlaneBufferGeometry.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\n\n\nTHREE.PlaneBufferGeometry = function (width, height, widthSegments, heightSegments) {\n  THREE.BufferGeometry.call(this);\n  this.type = 'PlaneBufferGeometry';\n  this.parameters = {\n    width: width,\n    height: height,\n    widthSegments: widthSegments,\n    heightSegments: heightSegments\n  };\n  var width_half = width / 2;\n  var height_half = height / 2;\n  var gridX = Math.floor(widthSegments) || 1;\n  var gridY = Math.floor(heightSegments) || 1;\n  var gridX1 = gridX + 1;\n  var gridY1 = gridY + 1;\n  var segment_width = width / gridX;\n  var segment_height = height / gridY;\n  var vertices = new Float32Array(gridX1 * gridY1 * 3);\n  var normals = new Float32Array(gridX1 * gridY1 * 3);\n  var uvs = new Float32Array(gridX1 * gridY1 * 2);\n  var offset = 0;\n  var offset2 = 0;\n\n  for (var iy = 0; iy < gridY1; iy++) {\n    var y = iy * segment_height - height_half;\n\n    for (var ix = 0; ix < gridX1; ix++) {\n      var x = ix * segment_width - width_half;\n      vertices[offset] = x;\n      vertices[offset + 1] = -y;\n      normals[offset + 2] = 1;\n      uvs[offset2] = ix / gridX;\n      uvs[offset2 + 1] = 1 - iy / gridY;\n      offset += 3;\n      offset2 += 2;\n    }\n  }\n\n  offset = 0;\n  var indices = new (vertices.length / 3 > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);\n\n  for (var iy = 0; iy < gridY; iy++) {\n    for (var ix = 0; ix < gridX; ix++) {\n      var a = ix + gridX1 * iy;\n      var b = ix + gridX1 * (iy + 1);\n      var c = ix + 1 + gridX1 * (iy + 1);\n      var d = ix + 1 + gridX1 * iy;\n      indices[offset] = a;\n      indices[offset + 1] = b;\n      indices[offset + 2] = d;\n      indices[offset + 3] = b;\n      indices[offset + 4] = c;\n      indices[offset + 5] = d;\n      offset += 6;\n    }\n  }\n\n  this.setIndex(new THREE.BufferAttribute(indices, 1));\n  this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n  this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n  this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));\n};\n\nTHREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\n\nTHREE.PlaneBufferGeometry.prototype.clone = function () {\n  var geometry = new THREE.PlaneBufferGeometry(this.parameters.width, this.parameters.height, this.parameters.widthSegments, this.parameters.heightSegments);\n  geometry.copy(this);\n  return geometry;\n}; // File:src/extras/geometries/RingGeometry.js\n\n/**\r\n * @author Kaleb Murphy\r\n */\n\n\nTHREE.RingGeometry = function (innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {\n  THREE.Geometry.call(this);\n  this.type = 'RingGeometry';\n  this.parameters = {\n    innerRadius: innerRadius,\n    outerRadius: outerRadius,\n    thetaSegments: thetaSegments,\n    phiSegments: phiSegments,\n    thetaStart: thetaStart,\n    thetaLength: thetaLength\n  };\n  innerRadius = innerRadius || 0;\n  outerRadius = outerRadius || 50;\n  thetaStart = thetaStart !== undefined ? thetaStart : 0;\n  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n  thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;\n  phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 8;\n  var i,\n      o,\n      uvs = [],\n      radius = innerRadius,\n      radiusStep = (outerRadius - innerRadius) / phiSegments;\n\n  for (i = 0; i < phiSegments + 1; i++) {\n    // concentric circles inside ring\n    for (o = 0; o < thetaSegments + 1; o++) {\n      // number of segments per circle\n      var vertex = new THREE.Vector3();\n      var segment = thetaStart + o / thetaSegments * thetaLength;\n      vertex.x = radius * Math.cos(segment);\n      vertex.y = radius * Math.sin(segment);\n      this.vertices.push(vertex);\n      uvs.push(new THREE.Vector2((vertex.x / outerRadius + 1) / 2, (vertex.y / outerRadius + 1) / 2));\n    }\n\n    radius += radiusStep;\n  }\n\n  var n = new THREE.Vector3(0, 0, 1);\n\n  for (i = 0; i < phiSegments; i++) {\n    // concentric circles inside ring\n    var thetaSegment = i * (thetaSegments + 1);\n\n    for (o = 0; o < thetaSegments; o++) {\n      // number of segments per circle\n      var segment = o + thetaSegment;\n      var v1 = segment;\n      var v2 = segment + thetaSegments + 1;\n      var v3 = segment + thetaSegments + 2;\n      this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));\n      this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);\n      v1 = segment;\n      v2 = segment + thetaSegments + 2;\n      v3 = segment + 1;\n      this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));\n      this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);\n    }\n  }\n\n  this.computeFaceNormals();\n  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);\n};\n\nTHREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\n\nTHREE.RingGeometry.prototype.clone = function () {\n  var geometry = new THREE.RingGeometry(this.parameters.innerRadius, this.parameters.outerRadius, this.parameters.thetaSegments, this.parameters.phiSegments, this.parameters.thetaStart, this.parameters.thetaLength);\n  return geometry;\n}; // File:src/extras/geometries/SphereGeometry.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.SphereGeometry = function (radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {\n  THREE.Geometry.call(this);\n  this.type = 'SphereGeometry';\n  this.parameters = {\n    radius: radius,\n    widthSegments: widthSegments,\n    heightSegments: heightSegments,\n    phiStart: phiStart,\n    phiLength: phiLength,\n    thetaStart: thetaStart,\n    thetaLength: thetaLength\n  };\n  this.fromBufferGeometry(new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));\n};\n\nTHREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\n\nTHREE.SphereGeometry.prototype.clone = function () {\n  var geometry = new THREE.SphereGeometry(this.parameters.radius, this.parameters.widthSegments, this.parameters.heightSegments, this.parameters.phiStart, this.parameters.phiLength, this.parameters.thetaStart, this.parameters.thetaLength);\n  return geometry;\n}; // File:src/extras/geometries/SphereBufferGeometry.js\n\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n * based on THREE.SphereGeometry\r\n */\n\n\nTHREE.SphereBufferGeometry = function (radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {\n  THREE.BufferGeometry.call(this);\n  this.type = 'SphereBufferGeometry';\n  this.parameters = {\n    radius: radius,\n    widthSegments: widthSegments,\n    heightSegments: heightSegments,\n    phiStart: phiStart,\n    phiLength: phiLength,\n    thetaStart: thetaStart,\n    thetaLength: thetaLength\n  };\n  radius = radius || 50;\n  widthSegments = Math.max(3, Math.floor(widthSegments) || 8);\n  heightSegments = Math.max(2, Math.floor(heightSegments) || 6);\n  phiStart = phiStart !== undefined ? phiStart : 0;\n  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n  thetaStart = thetaStart !== undefined ? thetaStart : 0;\n  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n  var thetaEnd = thetaStart + thetaLength;\n  var vertexCount = (widthSegments + 1) * (heightSegments + 1);\n  var positions = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);\n  var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);\n  var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);\n  var index = 0,\n      vertices = [],\n      normal = new THREE.Vector3();\n\n  for (var y = 0; y <= heightSegments; y++) {\n    var verticesRow = [];\n    var v = y / heightSegments;\n\n    for (var x = 0; x <= widthSegments; x++) {\n      var u = x / widthSegments;\n      var px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n      var py = radius * Math.cos(thetaStart + v * thetaLength);\n      var pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n      normal.set(px, py, pz).normalize();\n      positions.setXYZ(index, px, py, pz);\n      normals.setXYZ(index, normal.x, normal.y, normal.z);\n      uvs.setXY(index, u, 1 - v);\n      verticesRow.push(index);\n      index++;\n    }\n\n    vertices.push(verticesRow);\n  }\n\n  var indices = [];\n\n  for (var y = 0; y < heightSegments; y++) {\n    for (var x = 0; x < widthSegments; x++) {\n      var v1 = vertices[y][x + 1];\n      var v2 = vertices[y][x];\n      var v3 = vertices[y + 1][x];\n      var v4 = vertices[y + 1][x + 1];\n      if (y !== 0 || thetaStart > 0) indices.push(v1, v2, v4);\n      if (y !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(v2, v3, v4);\n    }\n  }\n\n  this.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));\n  this.addAttribute('position', positions);\n  this.addAttribute('normal', normals);\n  this.addAttribute('uv', uvs);\n  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);\n};\n\nTHREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\n\nTHREE.SphereBufferGeometry.prototype.clone = function () {\n  var geometry = new THREE.SphereBufferGeometry(this.parameters.radius, this.parameters.widthSegments, this.parameters.heightSegments, this.parameters.phiStart, this.parameters.phiLength, this.parameters.thetaStart, this.parameters.thetaLength);\n  geometry.copy(this);\n  return geometry;\n}; // File:src/extras/geometries/TextGeometry.js\n\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For creating 3D text geometry in three.js\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  size: \t\t\t<float>, \t// size of the text\r\n *  height: \t\t<float>, \t// thickness to extrude text\r\n *  curveSegments: \t<int>,\t\t// number of points on the curves\r\n *\r\n *  font: \t\t\t<string>,\t\t// font name\r\n *  weight: \t\t<string>,\t\t// font weight (normal, bold)\r\n *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\r\n *\r\n *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\r\n *  bevelThickness: <float>, \t\t// how deep into text bevel goes\r\n *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\r\n *  }\r\n *\r\n */\n\n/*\tUsage Examples\r\n\r\n\t// TextGeometry wrapper\r\n\r\n\tvar text3d = new TextGeometry( text, options );\r\n\r\n\t// Complete manner\r\n\r\n\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\r\n\tvar text3d = new ExtrudeGeometry( textShapes, options );\r\n\r\n*/\n\n\nTHREE.TextGeometry = function (text, parameters) {\n  parameters = parameters || {};\n  var textShapes = THREE.FontUtils.generateShapes(text, parameters); // translate parameters to ExtrudeGeometry API\n\n  parameters.amount = parameters.height !== undefined ? parameters.height : 50; // defaults\n\n  if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;\n  if (parameters.bevelSize === undefined) parameters.bevelSize = 8;\n  if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;\n  THREE.ExtrudeGeometry.call(this, textShapes, parameters);\n  this.type = 'TextGeometry';\n};\n\nTHREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry; // File:src/extras/geometries/TorusGeometry.js\n\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\n\nTHREE.TorusGeometry = function (radius, tube, radialSegments, tubularSegments, arc) {\n  THREE.Geometry.call(this);\n  this.type = 'TorusGeometry';\n  this.parameters = {\n    radius: radius,\n    tube: tube,\n    radialSegments: radialSegments,\n    tubularSegments: tubularSegments,\n    arc: arc\n  };\n  radius = radius || 100;\n  tube = tube || 40;\n  radialSegments = radialSegments || 8;\n  tubularSegments = tubularSegments || 6;\n  arc = arc || Math.PI * 2;\n  var center = new THREE.Vector3(),\n      uvs = [],\n      normals = [];\n\n  for (var j = 0; j <= radialSegments; j++) {\n    for (var i = 0; i <= tubularSegments; i++) {\n      var u = i / tubularSegments * arc;\n      var v = j / radialSegments * Math.PI * 2;\n      center.x = radius * Math.cos(u);\n      center.y = radius * Math.sin(u);\n      var vertex = new THREE.Vector3();\n      vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n      vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n      vertex.z = tube * Math.sin(v);\n      this.vertices.push(vertex);\n      uvs.push(new THREE.Vector2(i / tubularSegments, j / radialSegments));\n      normals.push(vertex.clone().sub(center).normalize());\n    }\n  }\n\n  for (var j = 1; j <= radialSegments; j++) {\n    for (var i = 1; i <= tubularSegments; i++) {\n      var a = (tubularSegments + 1) * j + i - 1;\n      var b = (tubularSegments + 1) * (j - 1) + i - 1;\n      var c = (tubularSegments + 1) * (j - 1) + i;\n      var d = (tubularSegments + 1) * j + i;\n      var face = new THREE.Face3(a, b, d, [normals[a].clone(), normals[b].clone(), normals[d].clone()]);\n      this.faces.push(face);\n      this.faceVertexUvs[0].push([uvs[a].clone(), uvs[b].clone(), uvs[d].clone()]);\n      face = new THREE.Face3(b, c, d, [normals[b].clone(), normals[c].clone(), normals[d].clone()]);\n      this.faces.push(face);\n      this.faceVertexUvs[0].push([uvs[b].clone(), uvs[c].clone(), uvs[d].clone()]);\n    }\n  }\n\n  this.computeFaceNormals();\n};\n\nTHREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\n\nTHREE.TorusGeometry.prototype.clone = function () {\n  var geometry = new THREE.TorusGeometry(this.parameters.radius, this.parameters.tube, this.parameters.radialSegments, this.parameters.tubularSegments, this.parameters.arc);\n  return geometry;\n}; // File:src/extras/geometries/TorusKnotGeometry.js\n\n/**\r\n * @author oosmoxiecode\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n */\n\n\nTHREE.TorusKnotGeometry = function (radius, tube, radialSegments, tubularSegments, p, q, heightScale) {\n  THREE.Geometry.call(this);\n  this.type = 'TorusKnotGeometry';\n  this.parameters = {\n    radius: radius,\n    tube: tube,\n    radialSegments: radialSegments,\n    tubularSegments: tubularSegments,\n    p: p,\n    q: q,\n    heightScale: heightScale\n  };\n  radius = radius || 100;\n  tube = tube || 40;\n  radialSegments = radialSegments || 64;\n  tubularSegments = tubularSegments || 8;\n  p = p || 2;\n  q = q || 3;\n  heightScale = heightScale || 1;\n  var grid = new Array(radialSegments);\n  var tang = new THREE.Vector3();\n  var n = new THREE.Vector3();\n  var bitan = new THREE.Vector3();\n\n  for (var i = 0; i < radialSegments; ++i) {\n    grid[i] = new Array(tubularSegments);\n    var u = i / radialSegments * 2 * p * Math.PI;\n    var p1 = getPos(u, q, p, radius, heightScale);\n    var p2 = getPos(u + 0.01, q, p, radius, heightScale);\n    tang.subVectors(p2, p1);\n    n.addVectors(p2, p1);\n    bitan.crossVectors(tang, n);\n    n.crossVectors(bitan, tang);\n    bitan.normalize();\n    n.normalize();\n\n    for (var j = 0; j < tubularSegments; ++j) {\n      var v = j / tubularSegments * 2 * Math.PI;\n      var cx = -tube * Math.cos(v); // TODO: Hack: Negating it so it faces outside.\n\n      var cy = tube * Math.sin(v);\n      var pos = new THREE.Vector3();\n      pos.x = p1.x + cx * n.x + cy * bitan.x;\n      pos.y = p1.y + cx * n.y + cy * bitan.y;\n      pos.z = p1.z + cx * n.z + cy * bitan.z;\n      grid[i][j] = this.vertices.push(pos) - 1;\n    }\n  }\n\n  for (var i = 0; i < radialSegments; ++i) {\n    for (var j = 0; j < tubularSegments; ++j) {\n      var ip = (i + 1) % radialSegments;\n      var jp = (j + 1) % tubularSegments;\n      var a = grid[i][j];\n      var b = grid[ip][j];\n      var c = grid[ip][jp];\n      var d = grid[i][jp];\n      var uva = new THREE.Vector2(i / radialSegments, j / tubularSegments);\n      var uvb = new THREE.Vector2((i + 1) / radialSegments, j / tubularSegments);\n      var uvc = new THREE.Vector2((i + 1) / radialSegments, (j + 1) / tubularSegments);\n      var uvd = new THREE.Vector2(i / radialSegments, (j + 1) / tubularSegments);\n      this.faces.push(new THREE.Face3(a, b, d));\n      this.faceVertexUvs[0].push([uva, uvb, uvd]);\n      this.faces.push(new THREE.Face3(b, c, d));\n      this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);\n    }\n  }\n\n  this.computeFaceNormals();\n  this.computeVertexNormals();\n\n  function getPos(u, in_q, in_p, radius, heightScale) {\n    var cu = Math.cos(u);\n    var su = Math.sin(u);\n    var quOverP = in_q / in_p * u;\n    var cs = Math.cos(quOverP);\n    var tx = radius * (2 + cs) * 0.5 * cu;\n    var ty = radius * (2 + cs) * su * 0.5;\n    var tz = heightScale * radius * Math.sin(quOverP) * 0.5;\n    return new THREE.Vector3(tx, ty, tz);\n  }\n};\n\nTHREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\n\nTHREE.TorusKnotGeometry.prototype.clone = function () {\n  var geometry = new THREE.TorusKnotGeometry(this.parameters.radius, this.parameters.tube, this.parameters.radialSegments, this.parameters.tubularSegments, this.parameters.p, this.parameters.q, this.parameters.heightScale);\n  return geometry;\n}; // File:src/extras/geometries/TubeGeometry.js\n\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n * @author jonobr1 / https://github.com/jonobr1\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\n\n\nTHREE.TubeGeometry = function (path, segments, radius, radialSegments, closed, taper) {\n  THREE.Geometry.call(this);\n  this.type = 'TubeGeometry';\n  this.parameters = {\n    path: path,\n    segments: segments,\n    radius: radius,\n    radialSegments: radialSegments,\n    closed: closed\n  };\n  segments = segments || 64;\n  radius = radius || 1;\n  radialSegments = radialSegments || 8;\n  closed = closed || false;\n  taper = taper || THREE.TubeGeometry.NoTaper;\n  var grid = [];\n  var scope = this,\n      tangent,\n      normal,\n      binormal,\n      numpoints = segments + 1,\n      u,\n      v,\n      r,\n      cx,\n      cy,\n      pos,\n      pos2 = new THREE.Vector3(),\n      i,\n      j,\n      ip,\n      jp,\n      a,\n      b,\n      c,\n      d,\n      uva,\n      uvb,\n      uvc,\n      uvd;\n  var frames = new THREE.TubeGeometry.FrenetFrames(path, segments, closed),\n      tangents = frames.tangents,\n      normals = frames.normals,\n      binormals = frames.binormals; // proxy internals\n\n  this.tangents = tangents;\n  this.normals = normals;\n  this.binormals = binormals;\n\n  function vert(x, y, z) {\n    return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;\n  } // construct the grid\n\n\n  for (i = 0; i < numpoints; i++) {\n    grid[i] = [];\n    u = i / (numpoints - 1);\n    pos = path.getPointAt(u);\n    tangent = tangents[i];\n    normal = normals[i];\n    binormal = binormals[i];\n    r = radius * taper(u);\n\n    for (j = 0; j < radialSegments; j++) {\n      v = j / radialSegments * 2 * Math.PI;\n      cx = -r * Math.cos(v); // TODO: Hack: Negating it so it faces outside.\n\n      cy = r * Math.sin(v);\n      pos2.copy(pos);\n      pos2.x += cx * normal.x + cy * binormal.x;\n      pos2.y += cx * normal.y + cy * binormal.y;\n      pos2.z += cx * normal.z + cy * binormal.z;\n      grid[i][j] = vert(pos2.x, pos2.y, pos2.z);\n    }\n  } // construct the mesh\n\n\n  for (i = 0; i < segments; i++) {\n    for (j = 0; j < radialSegments; j++) {\n      ip = closed ? (i + 1) % segments : i + 1;\n      jp = (j + 1) % radialSegments;\n      a = grid[i][j]; // *** NOT NECESSARILY PLANAR ! ***\n\n      b = grid[ip][j];\n      c = grid[ip][jp];\n      d = grid[i][jp];\n      uva = new THREE.Vector2(i / segments, j / radialSegments);\n      uvb = new THREE.Vector2((i + 1) / segments, j / radialSegments);\n      uvc = new THREE.Vector2((i + 1) / segments, (j + 1) / radialSegments);\n      uvd = new THREE.Vector2(i / segments, (j + 1) / radialSegments);\n      this.faces.push(new THREE.Face3(a, b, d));\n      this.faceVertexUvs[0].push([uva, uvb, uvd]);\n      this.faces.push(new THREE.Face3(b, c, d));\n      this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);\n    }\n  }\n\n  this.computeFaceNormals();\n  this.computeVertexNormals();\n};\n\nTHREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\n\nTHREE.TubeGeometry.NoTaper = function (u) {\n  return 1;\n};\n\nTHREE.TubeGeometry.SinusoidalTaper = function (u) {\n  return Math.sin(Math.PI * u);\n}; // For computing of Frenet frames, exposing the tangents, normals and binormals the spline\n\n\nTHREE.TubeGeometry.FrenetFrames = function (path, segments, closed) {\n  var normal = new THREE.Vector3(),\n      tangents = [],\n      normals = [],\n      binormals = [],\n      vec = new THREE.Vector3(),\n      mat = new THREE.Matrix4(),\n      numpoints = segments + 1,\n      theta,\n      epsilon = 0.0001,\n      smallest,\n      tx,\n      ty,\n      tz,\n      i,\n      u; // expose internals\n\n  this.tangents = tangents;\n  this.normals = normals;\n  this.binormals = binormals; // compute the tangent vectors for each segment on the path\n\n  for (i = 0; i < numpoints; i++) {\n    u = i / (numpoints - 1);\n    tangents[i] = path.getTangentAt(u);\n    tangents[i].normalize();\n  }\n\n  initialNormal3();\n  /*\r\n  function initialNormal1(lastBinormal) {\r\n  \t// fixed start binormal. Has dangers of 0 vectors\r\n  \tnormals[ 0 ] = new THREE.Vector3();\r\n  \tbinormals[ 0 ] = new THREE.Vector3();\r\n  \tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n  \tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n  \tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n  }\r\n  \n  function initialNormal2() {\r\n  \n  \t// This uses the Frenet-Serret formula for deriving binormal\r\n  \tvar t2 = path.getTangentAt( epsilon );\r\n  \n  \tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n  \tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n  \n  \tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n  \tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n  \n  }\r\n  */\n\n  function initialNormal3() {\n    // select an initial normal vector perpendicular to the first tangent vector,\n    // and in the direction of the smallest tangent xyz component\n    normals[0] = new THREE.Vector3();\n    binormals[0] = new THREE.Vector3();\n    smallest = Number.MAX_VALUE;\n    tx = Math.abs(tangents[0].x);\n    ty = Math.abs(tangents[0].y);\n    tz = Math.abs(tangents[0].z);\n\n    if (tx <= smallest) {\n      smallest = tx;\n      normal.set(1, 0, 0);\n    }\n\n    if (ty <= smallest) {\n      smallest = ty;\n      normal.set(0, 1, 0);\n    }\n\n    if (tz <= smallest) {\n      normal.set(0, 0, 1);\n    }\n\n    vec.crossVectors(tangents[0], normal).normalize();\n    normals[0].crossVectors(tangents[0], vec);\n    binormals[0].crossVectors(tangents[0], normals[0]);\n  } // compute the slowly-varying normal and binormal vectors for each segment on the path\n\n\n  for (i = 1; i < numpoints; i++) {\n    normals[i] = normals[i - 1].clone();\n    binormals[i] = binormals[i - 1].clone();\n    vec.crossVectors(tangents[i - 1], tangents[i]);\n\n    if (vec.length() > epsilon) {\n      vec.normalize();\n      theta = Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\n\n      normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n    }\n\n    binormals[i].crossVectors(tangents[i], normals[i]);\n  } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\n  if (closed) {\n    theta = Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));\n    theta /= numpoints - 1;\n\n    if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {\n      theta = -theta;\n    }\n\n    for (i = 1; i < numpoints; i++) {\n      // twist a little...\n      normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n      binormals[i].crossVectors(tangents[i], normals[i]);\n    }\n  }\n}; // File:src/extras/geometries/PolyhedronGeometry.js\n\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\n\n\nTHREE.PolyhedronGeometry = function (vertices, indices, radius, detail) {\n  THREE.Geometry.call(this);\n  this.type = 'PolyhedronGeometry';\n  this.parameters = {\n    vertices: vertices,\n    indices: indices,\n    radius: radius,\n    detail: detail\n  };\n  radius = radius || 1;\n  detail = detail || 0;\n  var that = this;\n\n  for (var i = 0, l = vertices.length; i < l; i += 3) {\n    prepare(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));\n  }\n\n  var p = this.vertices;\n  var faces = [];\n\n  for (var i = 0, j = 0, l = indices.length; i < l; i += 3, j++) {\n    var v1 = p[indices[i]];\n    var v2 = p[indices[i + 1]];\n    var v3 = p[indices[i + 2]];\n    faces[j] = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()], undefined, j);\n  }\n\n  var centroid = new THREE.Vector3();\n\n  for (var i = 0, l = faces.length; i < l; i++) {\n    subdivide(faces[i], detail);\n  } // Handle case when face straddles the seam\n\n\n  for (var i = 0, l = this.faceVertexUvs[0].length; i < l; i++) {\n    var uvs = this.faceVertexUvs[0][i];\n    var x0 = uvs[0].x;\n    var x1 = uvs[1].x;\n    var x2 = uvs[2].x;\n    var max = Math.max(x0, Math.max(x1, x2));\n    var min = Math.min(x0, Math.min(x1, x2));\n\n    if (max > 0.9 && min < 0.1) {\n      // 0.9 is somewhat arbitrary\n      if (x0 < 0.2) uvs[0].x += 1;\n      if (x1 < 0.2) uvs[1].x += 1;\n      if (x2 < 0.2) uvs[2].x += 1;\n    }\n  } // Apply radius\n\n\n  for (var i = 0, l = this.vertices.length; i < l; i++) {\n    this.vertices[i].multiplyScalar(radius);\n  } // Merge vertices\n\n\n  this.mergeVertices();\n  this.computeFaceNormals();\n  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius); // Project vector onto sphere's surface\n\n  function prepare(vector) {\n    var vertex = vector.normalize().clone();\n    vertex.index = that.vertices.push(vertex) - 1; // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n    var u = azimuth(vector) / 2 / Math.PI + 0.5;\n    var v = inclination(vector) / Math.PI + 0.5;\n    vertex.uv = new THREE.Vector2(u, 1 - v);\n    return vertex;\n  } // Approximate a curved face with recursively sub-divided triangles.\n\n\n  function make(v1, v2, v3, materialIndex) {\n    var face = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()], undefined, materialIndex);\n    that.faces.push(face);\n    centroid.copy(v1).add(v2).add(v3).divideScalar(3);\n    var azi = azimuth(centroid);\n    that.faceVertexUvs[0].push([correctUV(v1.uv, v1, azi), correctUV(v2.uv, v2, azi), correctUV(v3.uv, v3, azi)]);\n  } // Analytically subdivide a face to the required detail level.\n\n\n  function subdivide(face, detail) {\n    var cols = Math.pow(2, detail);\n    var a = prepare(that.vertices[face.a]);\n    var b = prepare(that.vertices[face.b]);\n    var c = prepare(that.vertices[face.c]);\n    var v = [];\n    var materialIndex = face.materialIndex; // Construct all of the vertices for this subdivision.\n\n    for (var i = 0; i <= cols; i++) {\n      v[i] = [];\n      var aj = prepare(a.clone().lerp(c, i / cols));\n      var bj = prepare(b.clone().lerp(c, i / cols));\n      var rows = cols - i;\n\n      for (var j = 0; j <= rows; j++) {\n        if (j === 0 && i === cols) {\n          v[i][j] = aj;\n        } else {\n          v[i][j] = prepare(aj.clone().lerp(bj, j / rows));\n        }\n      }\n    } // Construct all of the faces.\n\n\n    for (var i = 0; i < cols; i++) {\n      for (var j = 0; j < 2 * (cols - i) - 1; j++) {\n        var k = Math.floor(j / 2);\n\n        if (j % 2 === 0) {\n          make(v[i][k + 1], v[i + 1][k], v[i][k], materialIndex);\n        } else {\n          make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k], materialIndex);\n        }\n      }\n    }\n  } // Angle around the Y axis, counter-clockwise when looking from above.\n\n\n  function azimuth(vector) {\n    return Math.atan2(vector.z, -vector.x);\n  } // Angle above the XZ plane.\n\n\n  function inclination(vector) {\n    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n  } // Texture fixing helper. Spheres have some odd behaviours.\n\n\n  function correctUV(uv, vector, azimuth) {\n    if (azimuth < 0 && uv.x === 1) uv = new THREE.Vector2(uv.x - 1, uv.y);\n    if (vector.x === 0 && vector.z === 0) uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);\n    return uv.clone();\n  }\n};\n\nTHREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\n\nTHREE.PolyhedronGeometry.prototype.clone = function () {\n  var geometry = new THREE.PolyhedronGeometry(this.parameters.vertices, this.parameters.indices, this.parameters.radius, this.parameters.detail);\n  return geometry.copy(this);\n};\n\nTHREE.PolyhedronGeometry.prototype.copy = function (source) {\n  THREE.Geometry.prototype.copy.call(this, source);\n  return this;\n}; // File:src/extras/geometries/DodecahedronGeometry.js\n\n/**\r\n * @author Abe Pazos / https://hamoid.com\r\n */\n\n\nTHREE.DodecahedronGeometry = function (radius, detail) {\n  var t = (1 + Math.sqrt(5)) / 2;\n  var r = 1 / t;\n  var vertices = [// (±1, ±1, ±1)\n  -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)\n  0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)\n  -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)\n  -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];\n  var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];\n  THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);\n  this.type = 'DodecahedronGeometry';\n  this.parameters = {\n    radius: radius,\n    detail: detail\n  };\n};\n\nTHREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\n\nTHREE.DodecahedronGeometry.prototype.clone = function () {\n  var geometry = new THREE.DodecahedronGeometry(this.parameters.radius, this.parameters.detail);\n  geometry.copy(this);\n  return geometry;\n}; // File:src/extras/geometries/IcosahedronGeometry.js\n\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\n\n\nTHREE.IcosahedronGeometry = function (radius, detail) {\n  var t = (1 + Math.sqrt(5)) / 2;\n  var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];\n  var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];\n  THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);\n  this.type = 'IcosahedronGeometry';\n  this.parameters = {\n    radius: radius,\n    detail: detail\n  };\n};\n\nTHREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\n\nTHREE.IcosahedronGeometry.prototype.clone = function () {\n  var geometry = new THREE.IcosahedronGeometry(this.parameters.radius, this.parameters.detail);\n  geometry.copy(this);\n  return geometry;\n}; // File:src/extras/geometries/OctahedronGeometry.js\n\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\n\n\nTHREE.OctahedronGeometry = function (radius, detail) {\n  var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];\n  var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];\n  THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);\n  this.type = 'OctahedronGeometry';\n  this.parameters = {\n    radius: radius,\n    detail: detail\n  };\n};\n\nTHREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\n\nTHREE.OctahedronGeometry.prototype.clone = function () {\n  var geometry = new THREE.OctahedronGeometry(this.parameters.radius, this.parameters.detail);\n  geometry.copy(this);\n  return geometry;\n}; // File:src/extras/geometries/TetrahedronGeometry.js\n\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\n\n\nTHREE.TetrahedronGeometry = function (radius, detail) {\n  var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];\n  var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];\n  THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);\n  this.type = 'TetrahedronGeometry';\n  this.parameters = {\n    radius: radius,\n    detail: detail\n  };\n};\n\nTHREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\n\nTHREE.TetrahedronGeometry.prototype.clone = function () {\n  var geometry = new THREE.TetrahedronGeometry(this.parameters.radius, this.parameters.detail);\n  geometry.copy(this);\n  return geometry;\n}; // File:src/extras/geometries/ParametricGeometry.js\n\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n *\r\n */\n\n\nTHREE.ParametricGeometry = function (func, slices, stacks) {\n  THREE.Geometry.call(this);\n  this.type = 'ParametricGeometry';\n  this.parameters = {\n    func: func,\n    slices: slices,\n    stacks: stacks\n  };\n  var verts = this.vertices;\n  var faces = this.faces;\n  var uvs = this.faceVertexUvs[0];\n  var i, j, p;\n  var u, v;\n  var sliceCount = slices + 1;\n\n  for (i = 0; i <= stacks; i++) {\n    v = i / stacks;\n\n    for (j = 0; j <= slices; j++) {\n      u = j / slices;\n      p = func(u, v);\n      verts.push(p);\n    }\n  }\n\n  var a, b, c, d;\n  var uva, uvb, uvc, uvd;\n\n  for (i = 0; i < stacks; i++) {\n    for (j = 0; j < slices; j++) {\n      a = i * sliceCount + j;\n      b = i * sliceCount + j + 1;\n      c = (i + 1) * sliceCount + j + 1;\n      d = (i + 1) * sliceCount + j;\n      uva = new THREE.Vector2(j / slices, i / stacks);\n      uvb = new THREE.Vector2((j + 1) / slices, i / stacks);\n      uvc = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);\n      uvd = new THREE.Vector2(j / slices, (i + 1) / stacks);\n      faces.push(new THREE.Face3(a, b, d));\n      uvs.push([uva, uvb, uvd]);\n      faces.push(new THREE.Face3(b, c, d));\n      uvs.push([uvb.clone(), uvc, uvd.clone()]);\n    }\n  } // console.log(this);\n  // magic bullet\n  // var diff = this.mergeVertices();\n  // console.log('removed ', diff, ' vertices by merging');\n\n\n  this.computeFaceNormals();\n  this.computeVertexNormals();\n};\n\nTHREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry; // File:src/extras/geometries/WireframeGeometry.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.WireframeGeometry = function (geometry) {\n  THREE.BufferGeometry.call(this);\n  var edge = [0, 0],\n      hash = {};\n\n  var sortFunction = function sortFunction(a, b) {\n    return a - b;\n  };\n\n  var keys = ['a', 'b', 'c'];\n\n  if (geometry instanceof THREE.Geometry) {\n    var vertices = geometry.vertices;\n    var faces = geometry.faces;\n    var numEdges = 0; // allocate maximal size\n\n    var edges = new Uint32Array(6 * faces.length);\n\n    for (var i = 0, l = faces.length; i < l; i++) {\n      var face = faces[i];\n\n      for (var j = 0; j < 3; j++) {\n        edge[0] = face[keys[j]];\n        edge[1] = face[keys[(j + 1) % 3]];\n        edge.sort(sortFunction);\n        var key = edge.toString();\n\n        if (hash[key] === undefined) {\n          edges[2 * numEdges] = edge[0];\n          edges[2 * numEdges + 1] = edge[1];\n          hash[key] = true;\n          numEdges++;\n        }\n      }\n    }\n\n    var coords = new Float32Array(numEdges * 2 * 3);\n\n    for (var i = 0, l = numEdges; i < l; i++) {\n      for (var j = 0; j < 2; j++) {\n        var vertex = vertices[edges[2 * i + j]];\n        var index = 6 * i + 3 * j;\n        coords[index + 0] = vertex.x;\n        coords[index + 1] = vertex.y;\n        coords[index + 2] = vertex.z;\n      }\n    }\n\n    this.addAttribute('position', new THREE.BufferAttribute(coords, 3));\n  } else if (geometry instanceof THREE.BufferGeometry) {\n    if (geometry.index !== null) {\n      // Indexed BufferGeometry\n      var indices = geometry.index.array;\n      var vertices = geometry.attributes.position;\n      var drawcalls = geometry.drawcalls;\n      var numEdges = 0;\n\n      if (drawcalls.length === 0) {\n        geometry.addDrawCall(0, indices.length);\n      } // allocate maximal size\n\n\n      var edges = new Uint32Array(2 * indices.length);\n\n      for (var o = 0, ol = drawcalls.length; o < ol; ++o) {\n        var drawcall = drawcalls[o];\n        var start = drawcall.start;\n        var count = drawcall.count;\n\n        for (var i = start, il = start + count; i < il; i += 3) {\n          for (var j = 0; j < 3; j++) {\n            edge[0] = indices[i + j];\n            edge[1] = indices[i + (j + 1) % 3];\n            edge.sort(sortFunction);\n            var key = edge.toString();\n\n            if (hash[key] === undefined) {\n              edges[2 * numEdges] = edge[0];\n              edges[2 * numEdges + 1] = edge[1];\n              hash[key] = true;\n              numEdges++;\n            }\n          }\n        }\n      }\n\n      var coords = new Float32Array(numEdges * 2 * 3);\n\n      for (var i = 0, l = numEdges; i < l; i++) {\n        for (var j = 0; j < 2; j++) {\n          var index = 6 * i + 3 * j;\n          var index2 = edges[2 * i + j];\n          coords[index + 0] = vertices.getX(index2);\n          coords[index + 1] = vertices.getY(index2);\n          coords[index + 2] = vertices.getZ(index2);\n        }\n      }\n\n      this.addAttribute('position', new THREE.BufferAttribute(coords, 3));\n    } else {\n      // non-indexed BufferGeometry\n      var vertices = geometry.attributes.position.array;\n      var numEdges = vertices.length / 3;\n      var numTris = numEdges / 3;\n      var coords = new Float32Array(numEdges * 2 * 3);\n\n      for (var i = 0, l = numTris; i < l; i++) {\n        for (var j = 0; j < 3; j++) {\n          var index = 18 * i + 6 * j;\n          var index1 = 9 * i + 3 * j;\n          coords[index + 0] = vertices[index1];\n          coords[index + 1] = vertices[index1 + 1];\n          coords[index + 2] = vertices[index1 + 2];\n          var index2 = 9 * i + 3 * ((j + 1) % 3);\n          coords[index + 3] = vertices[index2];\n          coords[index + 4] = vertices[index2 + 1];\n          coords[index + 5] = vertices[index2 + 2];\n        }\n      }\n\n      this.addAttribute('position', new THREE.BufferAttribute(coords, 3));\n    }\n  }\n};\n\nTHREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry; // File:src/extras/helpers/AxisHelper.js\n\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.AxisHelper = function (size) {\n  size = size || 1;\n  var vertices = new Float32Array([0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size]);\n  var colors = new Float32Array([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1]);\n  var geometry = new THREE.BufferGeometry();\n  geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n  geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));\n  var material = new THREE.LineBasicMaterial({\n    vertexColors: THREE.VertexColors\n  });\n  THREE.LineSegments.call(this, geometry, material);\n};\n\nTHREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype);\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper; // File:src/extras/helpers/ArrowHelper.js\n\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / http://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  color - color in hex value\r\n *  headLength - Number\r\n *  headWidth - Number\r\n */\n\nTHREE.ArrowHelper = function () {\n  var lineGeometry = new THREE.Geometry();\n  lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));\n  var coneGeometry = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);\n  coneGeometry.translate(0, -0.5, 0);\n  return function ArrowHelper(dir, origin, length, color, headLength, headWidth) {\n    // dir is assumed to be normalized\n    THREE.Object3D.call(this);\n    if (color === undefined) color = 0xffff00;\n    if (length === undefined) length = 1;\n    if (headLength === undefined) headLength = 0.2 * length;\n    if (headWidth === undefined) headWidth = 0.2 * headLength;\n    this.position.copy(origin);\n\n    if (headLength < length) {\n      this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({\n        color: color\n      }));\n      this.line.matrixAutoUpdate = false;\n      this.add(this.line);\n    }\n\n    this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({\n      color: color\n    }));\n    this.cone.matrixAutoUpdate = false;\n    this.add(this.cone);\n    this.setDirection(dir);\n    this.setLength(length, headLength, headWidth);\n  };\n}();\n\nTHREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\n\nTHREE.ArrowHelper.prototype.setDirection = function () {\n  var axis = new THREE.Vector3();\n  var radians;\n  return function setDirection(dir) {\n    // dir is assumed to be normalized\n    if (dir.y > 0.99999) {\n      this.quaternion.set(0, 0, 0, 1);\n    } else if (dir.y < -0.99999) {\n      this.quaternion.set(1, 0, 0, 0);\n    } else {\n      axis.set(dir.z, 0, -dir.x).normalize();\n      radians = Math.acos(dir.y);\n      this.quaternion.setFromAxisAngle(axis, radians);\n    }\n  };\n}();\n\nTHREE.ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {\n  if (headLength === undefined) headLength = 0.2 * length;\n  if (headWidth === undefined) headWidth = 0.2 * headLength;\n\n  if (headLength < length) {\n    this.line.scale.set(1, length - headLength, 1);\n    this.line.updateMatrix();\n  }\n\n  this.cone.scale.set(headWidth, headLength, headWidth);\n  this.cone.position.y = length;\n  this.cone.updateMatrix();\n};\n\nTHREE.ArrowHelper.prototype.setColor = function (color) {\n  if (this.line !== undefined) this.line.material.color.set(color);\n  this.cone.material.color.set(color);\n}; // File:src/extras/helpers/BoxHelper.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.BoxHelper = function (object) {\n  var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n  var positions = new Float32Array(8 * 3);\n  var geometry = new THREE.BufferGeometry();\n  geometry.setIndex(new THREE.BufferAttribute(indices, 1));\n  geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n  THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({\n    color: 0xffff00\n  }));\n\n  if (object !== undefined) {\n    this.update(object);\n  }\n};\n\nTHREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype);\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\n\nTHREE.BoxHelper.prototype.update = function () {\n  var box = new THREE.Box3();\n  return function (object) {\n    box.setFromObject(object);\n    if (box.empty()) return;\n    var min = box.min;\n    var max = box.max;\n    /*\r\n      5____4\r\n    1/___0/|\r\n    | 6__|_7\r\n    2/___3/\r\n    \t\t0: max.x, max.y, max.z\r\n    1: min.x, max.y, max.z\r\n    2: min.x, min.y, max.z\r\n    3: max.x, min.y, max.z\r\n    4: max.x, max.y, min.z\r\n    5: min.x, max.y, min.z\r\n    6: min.x, min.y, min.z\r\n    7: max.x, min.y, min.z\r\n    */\n\n    var position = this.geometry.attributes.position;\n    var array = position.array;\n    array[0] = max.x;\n    array[1] = max.y;\n    array[2] = max.z;\n    array[3] = min.x;\n    array[4] = max.y;\n    array[5] = max.z;\n    array[6] = min.x;\n    array[7] = min.y;\n    array[8] = max.z;\n    array[9] = max.x;\n    array[10] = min.y;\n    array[11] = max.z;\n    array[12] = max.x;\n    array[13] = max.y;\n    array[14] = min.z;\n    array[15] = min.x;\n    array[16] = max.y;\n    array[17] = min.z;\n    array[18] = min.x;\n    array[19] = min.y;\n    array[20] = min.z;\n    array[21] = max.x;\n    array[22] = min.y;\n    array[23] = min.z;\n    position.needsUpdate = true;\n    this.geometry.computeBoundingSphere();\n  };\n}(); // File:src/extras/helpers/BoundingBoxHelper.js\n\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\n// a helper to show the world-axis-aligned bounding box for an object\n\n\nTHREE.BoundingBoxHelper = function (object, hex) {\n  var color = hex !== undefined ? hex : 0x888888;\n  this.object = object;\n  this.box = new THREE.Box3();\n  THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({\n    color: color,\n    wireframe: true\n  }));\n};\n\nTHREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\n\nTHREE.BoundingBoxHelper.prototype.update = function () {\n  this.box.setFromObject(this.object);\n  this.box.size(this.scale);\n  this.box.center(this.position);\n}; // File:src/extras/helpers/CameraHelper.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows frustum, line of sight and up of the camera\r\n *\t- suitable for fast updates\r\n * \t- based on frustum visualization in lightgl.js shadowmap example\r\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\n\n\nTHREE.CameraHelper = function (camera) {\n  var geometry = new THREE.Geometry();\n  var material = new THREE.LineBasicMaterial({\n    color: 0xffffff,\n    vertexColors: THREE.FaceColors\n  });\n  var pointMap = {}; // colors\n\n  var hexFrustum = 0xffaa00;\n  var hexCone = 0xff0000;\n  var hexUp = 0x00aaff;\n  var hexTarget = 0xffffff;\n  var hexCross = 0x333333; // near\n\n  addLine(\"n1\", \"n2\", hexFrustum);\n  addLine(\"n2\", \"n4\", hexFrustum);\n  addLine(\"n4\", \"n3\", hexFrustum);\n  addLine(\"n3\", \"n1\", hexFrustum); // far\n\n  addLine(\"f1\", \"f2\", hexFrustum);\n  addLine(\"f2\", \"f4\", hexFrustum);\n  addLine(\"f4\", \"f3\", hexFrustum);\n  addLine(\"f3\", \"f1\", hexFrustum); // sides\n\n  addLine(\"n1\", \"f1\", hexFrustum);\n  addLine(\"n2\", \"f2\", hexFrustum);\n  addLine(\"n3\", \"f3\", hexFrustum);\n  addLine(\"n4\", \"f4\", hexFrustum); // cone\n\n  addLine(\"p\", \"n1\", hexCone);\n  addLine(\"p\", \"n2\", hexCone);\n  addLine(\"p\", \"n3\", hexCone);\n  addLine(\"p\", \"n4\", hexCone); // up\n\n  addLine(\"u1\", \"u2\", hexUp);\n  addLine(\"u2\", \"u3\", hexUp);\n  addLine(\"u3\", \"u1\", hexUp); // target\n\n  addLine(\"c\", \"t\", hexTarget);\n  addLine(\"p\", \"c\", hexCross); // cross\n\n  addLine(\"cn1\", \"cn2\", hexCross);\n  addLine(\"cn3\", \"cn4\", hexCross);\n  addLine(\"cf1\", \"cf2\", hexCross);\n  addLine(\"cf3\", \"cf4\", hexCross);\n\n  function addLine(a, b, hex) {\n    addPoint(a, hex);\n    addPoint(b, hex);\n  }\n\n  function addPoint(id, hex) {\n    geometry.vertices.push(new THREE.Vector3());\n    geometry.colors.push(new THREE.Color(hex));\n\n    if (pointMap[id] === undefined) {\n      pointMap[id] = [];\n    }\n\n    pointMap[id].push(geometry.vertices.length - 1);\n  }\n\n  THREE.LineSegments.call(this, geometry, material);\n  this.camera = camera;\n  this.matrix = camera.matrixWorld;\n  this.matrixAutoUpdate = false;\n  this.pointMap = pointMap;\n  this.update();\n};\n\nTHREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype);\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\n\nTHREE.CameraHelper.prototype.update = function () {\n  var geometry, pointMap;\n  var vector = new THREE.Vector3();\n  var camera = new THREE.Camera();\n\n  var setPoint = function setPoint(point, x, y, z) {\n    vector.set(x, y, z).unproject(camera);\n    var points = pointMap[point];\n\n    if (points !== undefined) {\n      for (var i = 0, il = points.length; i < il; i++) {\n        geometry.vertices[points[i]].copy(vector);\n      }\n    }\n  };\n\n  return function () {\n    geometry = this.geometry;\n    pointMap = this.pointMap;\n    var w = 1,\n        h = 1; // we need just camera projection matrix\n    // world matrix must be identity\n\n    camera.projectionMatrix.copy(this.camera.projectionMatrix); // center / target\n\n    setPoint(\"c\", 0, 0, -1);\n    setPoint(\"t\", 0, 0, 1); // near\n\n    setPoint(\"n1\", -w, -h, -1);\n    setPoint(\"n2\", w, -h, -1);\n    setPoint(\"n3\", -w, h, -1);\n    setPoint(\"n4\", w, h, -1); // far\n\n    setPoint(\"f1\", -w, -h, 1);\n    setPoint(\"f2\", w, -h, 1);\n    setPoint(\"f3\", -w, h, 1);\n    setPoint(\"f4\", w, h, 1); // up\n\n    setPoint(\"u1\", w * 0.7, h * 1.1, -1);\n    setPoint(\"u2\", -w * 0.7, h * 1.1, -1);\n    setPoint(\"u3\", 0, h * 2, -1); // cross\n\n    setPoint(\"cf1\", -w, 0, 1);\n    setPoint(\"cf2\", w, 0, 1);\n    setPoint(\"cf3\", 0, -h, 1);\n    setPoint(\"cf4\", 0, h, 1);\n    setPoint(\"cn1\", -w, 0, -1);\n    setPoint(\"cn2\", w, 0, -1);\n    setPoint(\"cn3\", 0, -h, -1);\n    setPoint(\"cn4\", 0, h, -1);\n    geometry.verticesNeedUpdate = true;\n  };\n}(); // File:src/extras/helpers/DirectionalLightHelper.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\n\n\nTHREE.DirectionalLightHelper = function (light, size) {\n  THREE.Object3D.call(this);\n  this.light = light;\n  this.light.updateMatrixWorld();\n  this.matrix = light.matrixWorld;\n  this.matrixAutoUpdate = false;\n  size = size || 1;\n  var geometry = new THREE.Geometry();\n  geometry.vertices.push(new THREE.Vector3(-size, size, 0), new THREE.Vector3(size, size, 0), new THREE.Vector3(size, -size, 0), new THREE.Vector3(-size, -size, 0), new THREE.Vector3(-size, size, 0));\n  var material = new THREE.LineBasicMaterial({\n    fog: false\n  });\n  material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n  this.lightPlane = new THREE.Line(geometry, material);\n  this.add(this.lightPlane);\n  geometry = new THREE.Geometry();\n  geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());\n  material = new THREE.LineBasicMaterial({\n    fog: false\n  });\n  material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n  this.targetLine = new THREE.Line(geometry, material);\n  this.add(this.targetLine);\n  this.update();\n};\n\nTHREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\n\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\n  this.lightPlane.geometry.dispose();\n  this.lightPlane.material.dispose();\n  this.targetLine.geometry.dispose();\n  this.targetLine.material.dispose();\n};\n\nTHREE.DirectionalLightHelper.prototype.update = function () {\n  var v1 = new THREE.Vector3();\n  var v2 = new THREE.Vector3();\n  var v3 = new THREE.Vector3();\n  return function () {\n    v1.setFromMatrixPosition(this.light.matrixWorld);\n    v2.setFromMatrixPosition(this.light.target.matrixWorld);\n    v3.subVectors(v2, v1);\n    this.lightPlane.lookAt(v3);\n    this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n    this.targetLine.geometry.vertices[1].copy(v3);\n    this.targetLine.geometry.verticesNeedUpdate = true;\n    this.targetLine.material.color.copy(this.lightPlane.material.color);\n  };\n}(); // File:src/extras/helpers/EdgesHelper.js\n\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @param object THREE.Mesh whose geometry will be used\r\n * @param hex line color\r\n * @param thresholdAngle the minimum angle (in degrees),\r\n * between the face normals of adjacent faces,\r\n * that is required to render an edge. A value of 10 means\r\n * an edge is only rendered if the angle is at least 10 degrees.\r\n */\n\n\nTHREE.EdgesHelper = function (object, hex, thresholdAngle) {\n  var color = hex !== undefined ? hex : 0xffffff;\n  THREE.LineSegments.call(this, new THREE.EdgesGeometry(object.geometry, thresholdAngle), new THREE.LineBasicMaterial({\n    color: color\n  }));\n  this.matrix = object.matrixWorld;\n  this.matrixAutoUpdate = false;\n};\n\nTHREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype);\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper; // File:src/extras/helpers/FaceNormalsHelper.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\n\nTHREE.FaceNormalsHelper = function (object, size, hex, linewidth) {\n  // FaceNormalsHelper only supports THREE.Geometry\n  this.object = object;\n  this.size = size !== undefined ? size : 1;\n  var color = hex !== undefined ? hex : 0xffff00;\n  var width = linewidth !== undefined ? linewidth : 1; //\n\n  var nNormals = 0;\n  var objGeometry = this.object.geometry;\n\n  if (objGeometry instanceof THREE.Geometry) {\n    nNormals = objGeometry.faces.length;\n  } else {\n    console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');\n  } //\n\n\n  var geometry = new THREE.BufferGeometry();\n  var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);\n  geometry.addAttribute('position', positions);\n  THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({\n    color: color,\n    linewidth: width\n  })); //\n\n  this.matrixAutoUpdate = false;\n  this.update();\n};\n\nTHREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\n\nTHREE.FaceNormalsHelper.prototype.update = function () {\n  var v1 = new THREE.Vector3();\n  var v2 = new THREE.Vector3();\n  var normalMatrix = new THREE.Matrix3();\n  return function update() {\n    this.object.updateMatrixWorld(true);\n    normalMatrix.getNormalMatrix(this.object.matrixWorld);\n    var matrixWorld = this.object.matrixWorld;\n    var position = this.geometry.attributes.position; //\n\n    var objGeometry = this.object.geometry;\n    var vertices = objGeometry.vertices;\n    var faces = objGeometry.faces;\n    var idx = 0;\n\n    for (var i = 0, l = faces.length; i < l; i++) {\n      var face = faces[i];\n      var normal = face.normal;\n      v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);\n      v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);\n      position.setXYZ(idx, v1.x, v1.y, v1.z);\n      idx = idx + 1;\n      position.setXYZ(idx, v2.x, v2.y, v2.z);\n      idx = idx + 1;\n    }\n\n    position.needsUpdate = true;\n    return this;\n  };\n}(); // File:src/extras/helpers/GridHelper.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.GridHelper = function (size, step) {\n  var geometry = new THREE.Geometry();\n  var material = new THREE.LineBasicMaterial({\n    vertexColors: THREE.VertexColors\n  });\n  this.color1 = new THREE.Color(0x444444);\n  this.color2 = new THREE.Color(0x888888);\n\n  for (var i = -size; i <= size; i += step) {\n    geometry.vertices.push(new THREE.Vector3(-size, 0, i), new THREE.Vector3(size, 0, i), new THREE.Vector3(i, 0, -size), new THREE.Vector3(i, 0, size));\n    var color = i === 0 ? this.color1 : this.color2;\n    geometry.colors.push(color, color, color, color);\n  }\n\n  THREE.LineSegments.call(this, geometry, material);\n};\n\nTHREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype);\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\n\nTHREE.GridHelper.prototype.setColors = function (colorCenterLine, colorGrid) {\n  this.color1.set(colorCenterLine);\n  this.color2.set(colorGrid);\n  this.geometry.colorsNeedUpdate = true;\n}; // File:src/extras/helpers/HemisphereLightHelper.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.HemisphereLightHelper = function (light, sphereSize) {\n  THREE.Object3D.call(this);\n  this.light = light;\n  this.light.updateMatrixWorld();\n  this.matrix = light.matrixWorld;\n  this.matrixAutoUpdate = false;\n  this.colors = [new THREE.Color(), new THREE.Color()];\n  var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);\n  geometry.rotateX(-Math.PI / 2);\n\n  for (var i = 0, il = 8; i < il; i++) {\n    geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];\n  }\n\n  var material = new THREE.MeshBasicMaterial({\n    vertexColors: THREE.FaceColors,\n    wireframe: true\n  });\n  this.lightSphere = new THREE.Mesh(geometry, material);\n  this.add(this.lightSphere);\n  this.update();\n};\n\nTHREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\n\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\n  this.lightSphere.geometry.dispose();\n  this.lightSphere.material.dispose();\n};\n\nTHREE.HemisphereLightHelper.prototype.update = function () {\n  var vector = new THREE.Vector3();\n  return function () {\n    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);\n    this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);\n    this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());\n    this.lightSphere.geometry.colorsNeedUpdate = true;\n  };\n}(); // File:src/extras/helpers/PointLightHelper.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.PointLightHelper = function (light, sphereSize) {\n  this.light = light;\n  this.light.updateMatrixWorld();\n  var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);\n  var material = new THREE.MeshBasicMaterial({\n    wireframe: true,\n    fog: false\n  });\n  material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n  THREE.Mesh.call(this, geometry, material);\n  this.matrix = this.light.matrixWorld;\n  this.matrixAutoUpdate = false;\n  /*\r\n  var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n  var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n  \n  this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n  this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n  \n  var d = light.distance;\r\n  \n  if ( d === 0.0 ) {\r\n  \n  \tthis.lightDistance.visible = false;\r\n  \n  } else {\r\n  \n  \tthis.lightDistance.scale.set( d, d, d );\r\n  \n  }\r\n  \n  this.add( this.lightDistance );\r\n  */\n};\n\nTHREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\n\nTHREE.PointLightHelper.prototype.dispose = function () {\n  this.geometry.dispose();\n  this.material.dispose();\n};\n\nTHREE.PointLightHelper.prototype.update = function () {\n  this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n  /*\r\n  var d = this.light.distance;\r\n  \n  if ( d === 0.0 ) {\r\n  \n  \tthis.lightDistance.visible = false;\r\n  \n  } else {\r\n  \n  \tthis.lightDistance.visible = true;\r\n  \tthis.lightDistance.scale.set( d, d, d );\r\n  \n  }\r\n  */\n}; // File:src/extras/helpers/SkeletonHelper.js\n\n/**\r\n * @author Sean Griffin / http://twitter.com/sgrif\r\n * @author Michael Guerrero / http://realitymeltdown.com\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author ikerr / http://verold.com\r\n */\n\n\nTHREE.SkeletonHelper = function (object) {\n  this.bones = this.getBoneList(object);\n  var geometry = new THREE.Geometry();\n\n  for (var i = 0; i < this.bones.length; i++) {\n    var bone = this.bones[i];\n\n    if (bone.parent instanceof THREE.Bone) {\n      geometry.vertices.push(new THREE.Vector3());\n      geometry.vertices.push(new THREE.Vector3());\n      geometry.colors.push(new THREE.Color(0, 0, 1));\n      geometry.colors.push(new THREE.Color(0, 1, 0));\n    }\n  }\n\n  geometry.dynamic = true;\n  var material = new THREE.LineBasicMaterial({\n    vertexColors: THREE.VertexColors,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  THREE.LineSegments.call(this, geometry, material);\n  this.root = object;\n  this.matrix = object.matrixWorld;\n  this.matrixAutoUpdate = false;\n  this.update();\n};\n\nTHREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype);\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\n\nTHREE.SkeletonHelper.prototype.getBoneList = function (object) {\n  var boneList = [];\n\n  if (object instanceof THREE.Bone) {\n    boneList.push(object);\n  }\n\n  for (var i = 0; i < object.children.length; i++) {\n    boneList.push.apply(boneList, this.getBoneList(object.children[i]));\n  }\n\n  return boneList;\n};\n\nTHREE.SkeletonHelper.prototype.update = function () {\n  var geometry = this.geometry;\n  var matrixWorldInv = new THREE.Matrix4().getInverse(this.root.matrixWorld);\n  var boneMatrix = new THREE.Matrix4();\n  var j = 0;\n\n  for (var i = 0; i < this.bones.length; i++) {\n    var bone = this.bones[i];\n\n    if (bone.parent instanceof THREE.Bone) {\n      boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);\n      geometry.vertices[j].setFromMatrixPosition(boneMatrix);\n      boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);\n      geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);\n      j += 2;\n    }\n  }\n\n  geometry.verticesNeedUpdate = true;\n  geometry.computeBoundingSphere();\n}; // File:src/extras/helpers/SpotLightHelper.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\n\n\nTHREE.SpotLightHelper = function (light) {\n  THREE.Object3D.call(this);\n  this.light = light;\n  this.light.updateMatrixWorld();\n  this.matrix = light.matrixWorld;\n  this.matrixAutoUpdate = false;\n  var geometry = new THREE.CylinderGeometry(0, 1, 1, 8, 1, true);\n  geometry.translate(0, -0.5, 0);\n  geometry.rotateX(-Math.PI / 2);\n  var material = new THREE.MeshBasicMaterial({\n    wireframe: true,\n    fog: false\n  });\n  this.cone = new THREE.Mesh(geometry, material);\n  this.add(this.cone);\n  this.update();\n};\n\nTHREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\n\nTHREE.SpotLightHelper.prototype.dispose = function () {\n  this.cone.geometry.dispose();\n  this.cone.material.dispose();\n};\n\nTHREE.SpotLightHelper.prototype.update = function () {\n  var vector = new THREE.Vector3();\n  var vector2 = new THREE.Vector3();\n  return function () {\n    var coneLength = this.light.distance ? this.light.distance : 10000;\n    var coneWidth = coneLength * Math.tan(this.light.angle);\n    this.cone.scale.set(coneWidth, coneWidth, coneLength);\n    vector.setFromMatrixPosition(this.light.matrixWorld);\n    vector2.setFromMatrixPosition(this.light.target.matrixWorld);\n    this.cone.lookAt(vector2.sub(vector));\n    this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n  };\n}(); // File:src/extras/helpers/VertexNormalsHelper.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\n\n\nTHREE.VertexNormalsHelper = function (object, size, hex, linewidth) {\n  this.object = object;\n  this.size = size !== undefined ? size : 1;\n  var color = hex !== undefined ? hex : 0xff0000;\n  var width = linewidth !== undefined ? linewidth : 1; //\n\n  var nNormals = 0;\n  var objGeometry = this.object.geometry;\n\n  if (objGeometry instanceof THREE.Geometry) {\n    nNormals = objGeometry.faces.length * 3;\n  } else if (objGeometry instanceof THREE.BufferGeometry) {\n    nNormals = objGeometry.attributes.normal.count;\n  } //\n\n\n  var geometry = new THREE.BufferGeometry();\n  var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);\n  geometry.addAttribute('position', positions);\n  THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({\n    color: color,\n    linewidth: width\n  })); //\n\n  this.matrixAutoUpdate = false;\n  this.update();\n};\n\nTHREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\n\nTHREE.VertexNormalsHelper.prototype.update = function () {\n  var v1 = new THREE.Vector3();\n  var v2 = new THREE.Vector3();\n  var normalMatrix = new THREE.Matrix3();\n  return function update() {\n    var keys = ['a', 'b', 'c'];\n    this.object.updateMatrixWorld(true);\n    normalMatrix.getNormalMatrix(this.object.matrixWorld);\n    var matrixWorld = this.object.matrixWorld;\n    var position = this.geometry.attributes.position; //\n\n    var objGeometry = this.object.geometry;\n\n    if (objGeometry instanceof THREE.Geometry) {\n      var vertices = objGeometry.vertices;\n      var faces = objGeometry.faces;\n      var idx = 0;\n\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i];\n\n        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n          var vertex = vertices[face[keys[j]]];\n          var normal = face.vertexNormals[j];\n          v1.copy(vertex).applyMatrix4(matrixWorld);\n          v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);\n          position.setXYZ(idx, v1.x, v1.y, v1.z);\n          idx = idx + 1;\n          position.setXYZ(idx, v2.x, v2.y, v2.z);\n          idx = idx + 1;\n        }\n      }\n    } else if (objGeometry instanceof THREE.BufferGeometry) {\n      var objPos = objGeometry.attributes.position;\n      var objNorm = objGeometry.attributes.normal;\n      var idx = 0; // for simplicity, ignore index and drawcalls, and render every normal\n\n      for (var j = 0, jl = objPos.count; j < jl; j++) {\n        v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);\n        v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));\n        v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);\n        position.setXYZ(idx, v1.x, v1.y, v1.z);\n        idx = idx + 1;\n        position.setXYZ(idx, v2.x, v2.y, v2.z);\n        idx = idx + 1;\n      }\n    }\n\n    position.needsUpdate = true;\n    return this;\n  };\n}(); // File:src/extras/helpers/WireframeHelper.js\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\n\nTHREE.WireframeHelper = function (object, hex) {\n  var color = hex !== undefined ? hex : 0xffffff;\n  THREE.LineSegments.call(this, new THREE.WireframeGeometry(object.geometry), new THREE.LineBasicMaterial({\n    color: color\n  }));\n  this.matrix = object.matrixWorld;\n  this.matrixAutoUpdate = false;\n};\n\nTHREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype);\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper; // File:src/extras/objects/ImmediateRenderObject.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.ImmediateRenderObject = function () {\n  THREE.Object3D.call(this);\n\n  this.render = function (renderCallback) {};\n};\n\nTHREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject; // File:src/extras/objects/MorphBlendMesh.js\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.MorphBlendMesh = function (geometry, material) {\n  THREE.Mesh.call(this, geometry, material);\n  this.animationsMap = {};\n  this.animationsList = []; // prepare default animation\n  // (all frames played together in 1 second)\n\n  var numFrames = this.geometry.morphTargets.length;\n  var name = \"__default\";\n  var startFrame = 0;\n  var endFrame = numFrames - 1;\n  var fps = numFrames / 1;\n  this.createAnimation(name, startFrame, endFrame, fps);\n  this.setAnimationWeight(name, 1);\n};\n\nTHREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\n\nTHREE.MorphBlendMesh.prototype.createAnimation = function (name, start, end, fps) {\n  var animation = {\n    start: start,\n    end: end,\n    length: end - start + 1,\n    fps: fps,\n    duration: (end - start) / fps,\n    lastFrame: 0,\n    currentFrame: 0,\n    active: false,\n    time: 0,\n    direction: 1,\n    weight: 1,\n    directionBackwards: false,\n    mirroredLoop: false\n  };\n  this.animationsMap[name] = animation;\n  this.animationsList.push(animation);\n};\n\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function (fps) {\n  var pattern = /([a-z]+)_?(\\d+)/;\n  var firstAnimation,\n      frameRanges = {};\n  var geometry = this.geometry;\n\n  for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {\n    var morph = geometry.morphTargets[i];\n    var chunks = morph.name.match(pattern);\n\n    if (chunks && chunks.length > 1) {\n      var name = chunks[1];\n      if (!frameRanges[name]) frameRanges[name] = {\n        start: Infinity,\n        end: -Infinity\n      };\n      var range = frameRanges[name];\n      if (i < range.start) range.start = i;\n      if (i > range.end) range.end = i;\n      if (!firstAnimation) firstAnimation = name;\n    }\n  }\n\n  for (var name in frameRanges) {\n    var range = frameRanges[name];\n    this.createAnimation(name, range.start, range.end, fps);\n  }\n\n  this.firstAnimation = firstAnimation;\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (name) {\n  var animation = this.animationsMap[name];\n\n  if (animation) {\n    animation.direction = 1;\n    animation.directionBackwards = false;\n  }\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (name) {\n  var animation = this.animationsMap[name];\n\n  if (animation) {\n    animation.direction = -1;\n    animation.directionBackwards = true;\n  }\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function (name, fps) {\n  var animation = this.animationsMap[name];\n\n  if (animation) {\n    animation.fps = fps;\n    animation.duration = (animation.end - animation.start) / animation.fps;\n  }\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function (name, duration) {\n  var animation = this.animationsMap[name];\n\n  if (animation) {\n    animation.duration = duration;\n    animation.fps = (animation.end - animation.start) / animation.duration;\n  }\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function (name, weight) {\n  var animation = this.animationsMap[name];\n\n  if (animation) {\n    animation.weight = weight;\n  }\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function (name, time) {\n  var animation = this.animationsMap[name];\n\n  if (animation) {\n    animation.time = time;\n  }\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function (name) {\n  var time = 0;\n  var animation = this.animationsMap[name];\n\n  if (animation) {\n    time = animation.time;\n  }\n\n  return time;\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function (name) {\n  var duration = -1;\n  var animation = this.animationsMap[name];\n\n  if (animation) {\n    duration = animation.duration;\n  }\n\n  return duration;\n};\n\nTHREE.MorphBlendMesh.prototype.playAnimation = function (name) {\n  var animation = this.animationsMap[name];\n\n  if (animation) {\n    animation.time = 0;\n    animation.active = true;\n  } else {\n    console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n  }\n};\n\nTHREE.MorphBlendMesh.prototype.stopAnimation = function (name) {\n  var animation = this.animationsMap[name];\n\n  if (animation) {\n    animation.active = false;\n  }\n};\n\nTHREE.MorphBlendMesh.prototype.update = function (delta) {\n  for (var i = 0, il = this.animationsList.length; i < il; i++) {\n    var animation = this.animationsList[i];\n    if (!animation.active) continue;\n    var frameTime = animation.duration / animation.length;\n    animation.time += animation.direction * delta;\n\n    if (animation.mirroredLoop) {\n      if (animation.time > animation.duration || animation.time < 0) {\n        animation.direction *= -1;\n\n        if (animation.time > animation.duration) {\n          animation.time = animation.duration;\n          animation.directionBackwards = true;\n        }\n\n        if (animation.time < 0) {\n          animation.time = 0;\n          animation.directionBackwards = false;\n        }\n      }\n    } else {\n      animation.time = animation.time % animation.duration;\n      if (animation.time < 0) animation.time += animation.duration;\n    }\n\n    var keyframe = animation.start + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n    var weight = animation.weight;\n\n    if (keyframe !== animation.currentFrame) {\n      this.morphTargetInfluences[animation.lastFrame] = 0;\n      this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n      this.morphTargetInfluences[keyframe] = 0;\n      animation.lastFrame = animation.currentFrame;\n      animation.currentFrame = keyframe;\n    }\n\n    var mix = animation.time % frameTime / frameTime;\n    if (animation.directionBackwards) mix = 1 - mix;\n\n    if (animation.currentFrame !== animation.lastFrame) {\n      this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n      this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n    } else {\n      this.morphTargetInfluences[animation.currentFrame] = weight;\n    }\n  }\n}; // Export the THREE object for **Node.js**, with\n// backwards-compatibility for the old `require()` API. If we're in\n// the browser, add `_` as a global object via a string identifier,\n// for Closure Compiler \"advanced\" mode.\n\n\nif (typeof exports !== 'undefined') {\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = THREE;\n  }\n\n  exports.THREE = THREE;\n} else {\n  this['THREE'] = THREE;\n}","map":null,"metadata":{},"sourceType":"script"}